{"version":3,"sources":["../node_modules/tslint/lib/rules/preferConstRule.js"],"names":["Object","defineProperty","exports","value","tslib_1","__webpack_require__","ts","Lint","utils","Rule","_super","apply","this","arguments","__extends","FAILURE_STRING_FACTORY","identifier","blockScoped","prototype","sourceFile","options","destructuringAll","ruleArguments","length","destructuring","preferConstWalker","PreferConstWalker","ruleName","applyWithWalker","metadata","description","descriptionDetails","Utils","dedent","templateObject_1","__makeTemplateObject","hasFix","optionsDescription","templateObject_2","type","properties","enum","optionExamples","typescriptOnly","Rules","AbstractRule","Scope","functionScope","variables","Map","reassigned","Set","undefined","addVariable","declarationInfo","destructuringInfo","isBlockScoped","set","text","_this","scope","walk","isDeclarationFile","cb","node","savedScope","boundary","isScopeBoundary","kind","SyntaxKind","ModuleDeclaration","hasModifier","modifiers","DeclareKeyword","isFunctionDeclaration","isMethodDeclaration","isFunctionExpression","isArrowFunction","isConstructorDeclaration","body","_i","_a","parameters","param","settle","onScopeEnd","isForInStatement","isForOfStatement","initializer","VariableDeclarationList","handleExpression","handleVariableDeclaration","CatchClause","variableDeclaration","handleBindingName","name","canBeConst","Parameter","parent","IndexSignature","isPostfixUnaryExpression","isPrefixUnaryExpression","operator","PlusPlusToken","MinusMinusToken","isIdentifier","operand","add","isBinaryExpression","isAssignmentKind","operatorToken","left","forEachChild","isExternalModule","Identifier","ParenthesizedExpression","expression","ArrayLiteralExpression","elements","element","SpreadElement","ObjectLiteralExpression","_b","_c","property","ShorthandPropertyAssignment","SpreadAssignment","destructuringInfo_1","reassignedSiblings","forEachDestructuringIdentifier","declaration","declarationList","getVariableDeclarationKind","ExportKeyword","allInitialized","ForOfStatement","ForInStatement","declarations","every","isForLoop","ForStatement","forEach","variableInfo","get","clear","appliedFixes","info","fix","has","Replacement","getStart","addFailureAtNode","AbstractWalker"],"mappings":"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","file":"static/js/56.32777b44.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar utils = require(\"tsutils\");\nvar OPTION_DESTRUCTURING_ALL = \"all\";\nvar OPTION_DESTRUCTURING_ANY = \"any\";\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING_FACTORY = function (identifier, blockScoped) {\n        return \"Identifier '\" + identifier + \"' is never reassigned; use 'const' instead of '\" + (blockScoped ? \"let\" : \"var\") + \"'.\";\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        var options = {\n            destructuringAll: this.ruleArguments.length !== 0 &&\n                this.ruleArguments[0].destructuring ===\n                    OPTION_DESTRUCTURING_ALL,\n        };\n        var preferConstWalker = new PreferConstWalker(sourceFile, this.ruleName, options);\n        return this.applyWithWalker(preferConstWalker);\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"prefer-const\",\n        description: \"Requires that variable declarations use `const` instead of `let` and `var` if possible.\",\n        descriptionDetails: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            If a variable is only assigned to once when it is declared, it should be declared using 'const'\"], [\"\\n            If a variable is only assigned to once when it is declared, it should be declared using 'const'\"]))),\n        hasFix: true,\n        optionsDescription: Lint.Utils.dedent(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject([\"\\n            An optional object containing the property \\\"destructuring\\\" with two possible values:\\n\\n            * \\\"\", \"\\\" (default) - If any variable in destructuring can be const, this rule warns for those variables.\\n            * \\\"\", \"\\\" - Only warns if all variables in destructuring can be const.\"], [\"\\n            An optional object containing the property \\\"destructuring\\\" with two possible values:\\n\\n            * \\\"\", \"\\\" (default) - If any variable in destructuring can be const, this rule warns for those variables.\\n            * \\\"\", \"\\\" - Only warns if all variables in destructuring can be const.\"])), OPTION_DESTRUCTURING_ANY, OPTION_DESTRUCTURING_ALL),\n        options: {\n            type: \"object\",\n            properties: {\n                destructuring: {\n                    type: \"string\",\n                    enum: [OPTION_DESTRUCTURING_ALL, OPTION_DESTRUCTURING_ANY],\n                },\n            },\n        },\n        optionExamples: [true, [true, { destructuring: OPTION_DESTRUCTURING_ALL }]],\n        type: \"maintainability\",\n        typescriptOnly: false,\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nvar Scope = /** @class */ (function () {\n    function Scope(functionScope) {\n        this.variables = new Map();\n        this.reassigned = new Set();\n        // if no functionScope is provided we are in the process of creating a new function scope, which for consistency links to itself\n        this.functionScope = functionScope === undefined ? this : functionScope;\n    }\n    Scope.prototype.addVariable = function (identifier, declarationInfo, destructuringInfo) {\n        // block scoped variables go to the block scope, function scoped variables to the containing function scope\n        var scope = declarationInfo.isBlockScoped ? this : this.functionScope;\n        scope.variables.set(identifier.text, {\n            declarationInfo: declarationInfo,\n            destructuringInfo: destructuringInfo,\n            identifier: identifier,\n            reassigned: false,\n        });\n    };\n    return Scope;\n}());\nvar PreferConstWalker = /** @class */ (function (_super) {\n    tslib_1.__extends(PreferConstWalker, _super);\n    function PreferConstWalker() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.scope = new Scope();\n        return _this;\n    }\n    PreferConstWalker.prototype.walk = function (sourceFile) {\n        var _this = this;\n        // don't check anything on declaration files\n        if (sourceFile.isDeclarationFile) {\n            return;\n        }\n        this.scope = new Scope();\n        var cb = function (node) {\n            var savedScope = _this.scope;\n            var boundary = utils.isScopeBoundary(node);\n            if (boundary !== 0 /* None */) {\n                if (boundary === 1 /* Function */) {\n                    if (node.kind === ts.SyntaxKind.ModuleDeclaration &&\n                        utils.hasModifier(node.modifiers, ts.SyntaxKind.DeclareKeyword)) {\n                        // don't check ambient namespaces\n                        return;\n                    }\n                    _this.scope = new Scope();\n                    if (utils.isFunctionDeclaration(node) ||\n                        utils.isMethodDeclaration(node) ||\n                        utils.isFunctionExpression(node) ||\n                        utils.isArrowFunction(node) ||\n                        utils.isConstructorDeclaration(node)) {\n                        // special handling for function parameters\n                        // each parameter initializer can only reassign preceding parameters of variables of the containing scope\n                        if (node.body !== undefined) {\n                            for (var _i = 0, _a = node.parameters; _i < _a.length; _i++) {\n                                var param = _a[_i];\n                                cb(param);\n                                _this.settle(savedScope);\n                            }\n                            cb(node.body);\n                            _this.onScopeEnd(savedScope);\n                        }\n                        _this.scope = savedScope;\n                        return;\n                    }\n                }\n                else {\n                    _this.scope = new Scope(_this.scope.functionScope);\n                    if ((utils.isForInStatement(node) || utils.isForOfStatement(node)) &&\n                        node.initializer.kind !== ts.SyntaxKind.VariableDeclarationList) {\n                        _this.handleExpression(node.initializer);\n                    }\n                }\n            }\n            if (node.kind === ts.SyntaxKind.VariableDeclarationList) {\n                _this.handleVariableDeclaration(node);\n            }\n            else if (node.kind === ts.SyntaxKind.CatchClause) {\n                if (node.variableDeclaration !== undefined) {\n                    _this.handleBindingName(node.variableDeclaration.name, {\n                        canBeConst: false,\n                        isBlockScoped: true,\n                    });\n                }\n            }\n            else if (node.kind === ts.SyntaxKind.Parameter) {\n                if (node.parent.kind !== ts.SyntaxKind.IndexSignature) {\n                    _this.handleBindingName(node.name, {\n                        canBeConst: false,\n                        isBlockScoped: true,\n                    });\n                }\n            }\n            else if (utils.isPostfixUnaryExpression(node) ||\n                (utils.isPrefixUnaryExpression(node) &&\n                    (node.operator === ts.SyntaxKind.PlusPlusToken ||\n                        node.operator === ts.SyntaxKind.MinusMinusToken))) {\n                if (utils.isIdentifier(node.operand)) {\n                    _this.scope.reassigned.add(node.operand.text);\n                }\n            }\n            else if (utils.isBinaryExpression(node) &&\n                utils.isAssignmentKind(node.operatorToken.kind)) {\n                _this.handleExpression(node.left);\n            }\n            if (boundary !== 0 /* None */) {\n                ts.forEachChild(node, cb);\n                _this.onScopeEnd(savedScope);\n                _this.scope = savedScope;\n            }\n            else {\n                return ts.forEachChild(node, cb);\n            }\n        };\n        if (ts.isExternalModule(sourceFile)) {\n            ts.forEachChild(sourceFile, cb);\n            this.onScopeEnd();\n        }\n        else {\n            return ts.forEachChild(sourceFile, cb);\n        }\n    };\n    PreferConstWalker.prototype.handleExpression = function (node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.Identifier:\n                this.scope.reassigned.add(node.text);\n                break;\n            case ts.SyntaxKind.ParenthesizedExpression:\n                this.handleExpression(node.expression);\n                break;\n            case ts.SyntaxKind.ArrayLiteralExpression:\n                for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {\n                    var element = _a[_i];\n                    if (element.kind === ts.SyntaxKind.SpreadElement) {\n                        this.handleExpression(element.expression);\n                    }\n                    else {\n                        this.handleExpression(element);\n                    }\n                }\n                break;\n            case ts.SyntaxKind.ObjectLiteralExpression:\n                for (var _b = 0, _c = node.properties; _b < _c.length; _b++) {\n                    var property = _c[_b];\n                    switch (property.kind) {\n                        case ts.SyntaxKind.ShorthandPropertyAssignment:\n                            this.scope.reassigned.add(property.name.text);\n                            break;\n                        case ts.SyntaxKind.SpreadAssignment:\n                            if (property.name !== undefined) {\n                                this.scope.reassigned.add(property.name.text);\n                            }\n                            else {\n                                // handle `...(variable)`\n                                this.handleExpression(property.expression);\n                            }\n                            break;\n                        default:\n                            this.handleExpression(property.initializer);\n                    }\n                }\n        }\n    };\n    PreferConstWalker.prototype.handleBindingName = function (name, declarationInfo) {\n        var _this = this;\n        if (name.kind === ts.SyntaxKind.Identifier) {\n            this.scope.addVariable(name, declarationInfo);\n        }\n        else {\n            var destructuringInfo_1 = {\n                reassignedSiblings: false,\n            };\n            utils.forEachDestructuringIdentifier(name, function (declaration) {\n                return _this.scope.addVariable(declaration.name, declarationInfo, destructuringInfo_1);\n            });\n        }\n    };\n    PreferConstWalker.prototype.handleVariableDeclaration = function (declarationList) {\n        var declarationInfo;\n        var kind = utils.getVariableDeclarationKind(declarationList);\n        if (kind === 2 /* Const */ ||\n            utils.hasModifier(declarationList.parent.modifiers, ts.SyntaxKind.ExportKeyword, ts.SyntaxKind.DeclareKeyword)) {\n            declarationInfo = {\n                canBeConst: false,\n                isBlockScoped: kind !== 0 /* Var */,\n            };\n        }\n        else {\n            declarationInfo = {\n                allInitialized: declarationList.parent.kind === ts.SyntaxKind.ForOfStatement ||\n                    declarationList.parent.kind === ts.SyntaxKind.ForInStatement ||\n                    declarationList.declarations.every(function (declaration) { return declaration.initializer !== undefined; }),\n                canBeConst: true,\n                declarationList: declarationList,\n                isBlockScoped: kind === 1 /* Let */,\n                isForLoop: declarationList.parent.kind === ts.SyntaxKind.ForStatement ||\n                    declarationList.parent.kind === ts.SyntaxKind.ForOfStatement,\n                reassignedSiblings: false,\n            };\n        }\n        for (var _i = 0, _a = declarationList.declarations; _i < _a.length; _i++) {\n            var declaration = _a[_i];\n            this.handleBindingName(declaration.name, declarationInfo);\n        }\n    };\n    PreferConstWalker.prototype.settle = function (parent) {\n        var _a = this.scope, variables = _a.variables, reassigned = _a.reassigned;\n        reassigned.forEach(function (name) {\n            var variableInfo = variables.get(name);\n            if (variableInfo !== undefined) {\n                if (variableInfo.declarationInfo.canBeConst) {\n                    variableInfo.reassigned = true;\n                    variableInfo.declarationInfo.reassignedSiblings = true;\n                    if (variableInfo.destructuringInfo !== undefined) {\n                        variableInfo.destructuringInfo.reassignedSiblings = true;\n                    }\n                }\n            }\n            else if (parent !== undefined) {\n                // if the reassigned variable was not declared in this scope we defer to the parent scope\n                parent.reassigned.add(name);\n            }\n        });\n        reassigned.clear();\n    };\n    PreferConstWalker.prototype.onScopeEnd = function (parent) {\n        var _this = this;\n        this.settle(parent);\n        var appliedFixes = new Set();\n        this.scope.variables.forEach(function (info, name) {\n            if (info.declarationInfo.canBeConst &&\n                !info.reassigned &&\n                // don't add failures for reassigned variables in for loop initializer\n                !(info.declarationInfo.reassignedSiblings && info.declarationInfo.isForLoop) &&\n                // if {destructuring: \"all\"} is set, only add a failure if all variables in a destructuring assignment can be const\n                (!_this.options.destructuringAll ||\n                    info.destructuringInfo === undefined ||\n                    !info.destructuringInfo.reassignedSiblings)) {\n                var fix = void 0;\n                // only apply fixes if the VariableDeclarationList has no reassigned variables\n                // and the variable is block scoped aka `let` and initialized\n                if (info.declarationInfo.allInitialized &&\n                    !info.declarationInfo.reassignedSiblings &&\n                    info.declarationInfo.isBlockScoped &&\n                    !appliedFixes.has(info.declarationInfo.declarationList)) {\n                    fix = new Lint.Replacement(info.declarationInfo.declarationList.getStart(_this.sourceFile), 3, \"const\");\n                    // add only one fixer per VariableDeclarationList\n                    appliedFixes.add(info.declarationInfo.declarationList);\n                }\n                _this.addFailureAtNode(info.identifier, Rule.FAILURE_STRING_FACTORY(name, info.declarationInfo.isBlockScoped), fix);\n            }\n        });\n    };\n    return PreferConstWalker;\n}(Lint.AbstractWalker));\nvar templateObject_1, templateObject_2;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/preferConstRule.js\n// module id = 2125\n// module chunks = 56"],"sourceRoot":""}