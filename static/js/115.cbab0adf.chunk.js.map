{"version":3,"sources":["../node_modules/tslint/lib/rules/noConsecutiveBlankLinesRule.js"],"names":["Object","defineProperty","exports","value","templateObject_1","templateObject_2","tslib_1","__webpack_require__","utils","ts","Lint","Rule","_super","apply","this","arguments","__extends","FAILURE_STRING_FACTORY","allowed","prototype","isEnabled","option","ruleArguments","call","undefined","sourceFile","limit","applyWithFunction","walk","DEFAULT_ALLOWED_BLANKS","metadata","ruleName","description","hasFix","rationale","Utils","dedent","__makeTemplateObject","optionsDescription","options","type","minimum","optionExamples","typescriptOnly","Rules","AbstractRule","ctx","sourceText","text","threshold","possibleFailures","consecutiveBlankLines","_i","_a","getLineRanges","length","line","contentLength","substr","pos","search","push","end","failureString","templateRanges","getTemplateRanges","_loop_1","possibleFailure","some","template","addFailureAt","Replacement","deleteFromTo","getStartOfLineBreak","_b","possibleFailures_1","intervals","cb","node","kind","SyntaxKind","FirstTemplateToken","LastTemplateToken","forEachChild","getStart"],"mappings":"sDAiBAA,OAAAC,eAAAC,EAAA,cAA8CC,OAAA,IAC9C,IAkHAC,EAAAC,EAlHAC,EAAAC,EAAA,GACAC,EAAAD,EAAA,KACAE,EAAAF,EAAA,IACAG,EAAAH,EAAA,MACAI,EAAA,SAAAC,GAEA,SAAAD,IACA,cAAAC,KAAAC,MAAAC,KAAAC,YAAAD,KAmCA,OArCAR,EAAAU,UAAAL,EAAAC,GAKAD,EAAAM,uBAAA,SAAAC,GACA,WAAAA,EACA,wCACA,eAAAA,EAAA,oCAKAP,EAAAQ,UAAAC,UAAA,WACA,IAAAC,EAAAP,KAAAQ,cAAA,GACA,OAAAV,EAAAO,UAAAC,UAAAG,KAAAT,aAAAU,IAAAH,KAAA,IAEAV,EAAAQ,UAAAN,MAAA,SAAAY,GACA,IAAAC,EAAAZ,KAAAQ,cAAA,GACA,OAAAR,KAAAa,kBAAAF,EAAAG,OAAAJ,IAAAE,IAAAf,EAAAkB,yBAEAlB,EAAAkB,uBAAA,EAEAlB,EAAAmB,UACAC,SAAA,6BACAC,YAAA,8CACAC,QAAA,EACAC,UAAAxB,EAAAyB,MAAAC,OAAAhC,MAAAE,EAAA+B,sBAAA,45BACAC,mBAAA5B,EAAAyB,MAAAC,OAAA/B,MAAAC,EAAA+B,sBAAA,mUAAA1B,EAAAkB,wBACAU,SACAC,KAAA,SACAC,QAAA,KAEAC,iBAAA,UACAF,KAAA,QACAG,gBAAA,GAEAhC,EAtCA,CAuCCD,EAAAkC,MAAAC,cAED,SAAAjB,EAAAkB,GAKA,IAJA,IAAAC,EAAAD,EAAArB,WAAAuB,KACAC,EAAAH,EAAAP,QAAA,EACAW,KACAC,EAAA,EACAC,EAAA,EAAAC,EAAA7C,EAAA8C,cAAAR,EAAArB,YAA8D2B,EAAAC,EAAAE,OAAgBH,IAAA,CAC9E,IAAAI,EAAAH,EAAAD,GACA,IAAAI,EAAAC,gBACA,IAAAV,EAAAW,OAAAF,EAAAG,IAAAH,EAAAC,eAAAG,OAAA,QACAT,IACAF,EACAC,EAAAW,MACAC,IAAAN,EAAAM,IACAH,IAAAH,EAAAG,MAGAR,EAAAF,IACAC,IAAAK,OAAA,GAAAO,IAAAN,EAAAM,KAIAX,EAAA,EAGA,OAAAD,EAAAK,OAmBA,IAhBA,IAAAQ,EAAApD,EAAAM,uBAAA6B,EAAAP,SACAyB,EAAAC,EAAAnB,EAAArB,YACAyC,EAAA,SAAAC,GACAH,EAAAI,KAAA,SAAAC,GACA,OAAAA,EAAAV,IAAAQ,EAAAR,KAAAQ,EAAAR,IAAAU,EAAAP,OAEAhB,EAAAwB,aAAAH,EAAAR,IAAA,EAAAI,GACArD,EAAA6D,YAAAC,aAGAL,EAAAL,MAAAf,EAAAQ,OAWA,SAAAR,EAAAY,GACA,OAAAZ,EAAAY,EAAA,GAAAA,EAAA,EAXAc,CAAA1B,EAAAoB,EAAAR,KACAQ,EAAAR,IAAAQ,EAAAL,QAIAY,EAAA,EAAAC,EAAAzB,EAA2DwB,EAAAC,EAAApB,OAAgCmB,IAAA,CAE3FR,EADAS,EAAAD,KAOA,SAAAT,EAAAxC,GACA,IAAAmD,KACAC,EAAA,SAAAC,GACA,KAAAA,EAAAC,MAAAtE,EAAAuE,WAAAC,oBACAH,EAAAC,MAAAtE,EAAAuE,WAAAE,mBAOA,OAAAzE,EAAA0E,aAAAL,EAAAD,GANAD,EAAAf,MACAC,IAAAgB,EAAAhB,IACAH,IAAAmB,EAAAM,SAAA3D,MAQA,OADAhB,EAAA0E,aAAA1D,EAAAoD,GACAD,EAnEA1E,EAAAS,OAqEAT,EAAA+D","file":"static/js/115.cbab0adf.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING_FACTORY = function (allowed) {\n        return allowed === 1\n            ? \"Consecutive blank lines are forbidden\"\n            : \"Exceeds the \" + allowed + \" allowed consecutive blank lines\";\n    };\n    /**\n     * Disable the rule if the option is provided but non-numeric or less than the minimum.\n     */\n    Rule.prototype.isEnabled = function () {\n        var option = this.ruleArguments[0];\n        return _super.prototype.isEnabled.call(this) && (option === undefined || option > 0);\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        var limit = this.ruleArguments[0];\n        return this.applyWithFunction(sourceFile, walk, limit !== undefined ? limit : Rule.DEFAULT_ALLOWED_BLANKS);\n    };\n    Rule.DEFAULT_ALLOWED_BLANKS = 1;\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"no-consecutive-blank-lines\",\n        description: \"Disallows one or more blank lines in a row.\",\n        hasFix: true,\n        rationale: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            Helps maintain a readable style in your codebase.\\n\\n            Extra blank lines take up extra space and add little to a semantic understanding of the code.\\n            It can be harder to read through files when fewer components can fit into the screen.\\n            If you find a file is so large you feel a need to split them up with extra blank lines or comments,\\n            consider splitting your file into smaller files.\\n        \"], [\"\\n            Helps maintain a readable style in your codebase.\\n\\n            Extra blank lines take up extra space and add little to a semantic understanding of the code.\\n            It can be harder to read through files when fewer components can fit into the screen.\\n            If you find a file is so large you feel a need to split them up with extra blank lines or comments,\\n            consider splitting your file into smaller files.\\n        \"]))),\n        optionsDescription: Lint.Utils.dedent(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject([\"\\n            An optional number of maximum allowed sequential blanks can be specified. If no value\\n            is provided, a default of \", \" will be used.\"], [\"\\n            An optional number of maximum allowed sequential blanks can be specified. If no value\\n            is provided, a default of \", \" will be used.\"])), Rule.DEFAULT_ALLOWED_BLANKS),\n        options: {\n            type: \"number\",\n            minimum: \"1\",\n        },\n        optionExamples: [true, [true, 2]],\n        type: \"style\",\n        typescriptOnly: false,\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var sourceText = ctx.sourceFile.text;\n    var threshold = ctx.options + 1;\n    var possibleFailures = [];\n    var consecutiveBlankLines = 0;\n    for (var _i = 0, _a = utils.getLineRanges(ctx.sourceFile); _i < _a.length; _i++) {\n        var line = _a[_i];\n        if (line.contentLength === 0 ||\n            sourceText.substr(line.pos, line.contentLength).search(/\\S/) === -1) {\n            ++consecutiveBlankLines;\n            if (consecutiveBlankLines === threshold) {\n                possibleFailures.push({\n                    end: line.end,\n                    pos: line.pos,\n                });\n            }\n            else if (consecutiveBlankLines > threshold) {\n                possibleFailures[possibleFailures.length - 1].end = line.end;\n            }\n        }\n        else {\n            consecutiveBlankLines = 0;\n        }\n    }\n    if (possibleFailures.length === 0) {\n        return;\n    }\n    var failureString = Rule.FAILURE_STRING_FACTORY(ctx.options);\n    var templateRanges = getTemplateRanges(ctx.sourceFile);\n    var _loop_1 = function (possibleFailure) {\n        if (!templateRanges.some(function (template) {\n            return template.pos < possibleFailure.pos && possibleFailure.pos < template.end;\n        })) {\n            ctx.addFailureAt(possibleFailure.pos, 1, failureString, [\n                Lint.Replacement.deleteFromTo(\n                // special handling for fixing blank lines at the end of the file\n                // to fix this we need to cut off the line break of the last allowed blank line, too\n                possibleFailure.end === sourceText.length\n                    ? getStartOfLineBreak(sourceText, possibleFailure.pos)\n                    : possibleFailure.pos, possibleFailure.end),\n            ]);\n        }\n    };\n    for (var _b = 0, possibleFailures_1 = possibleFailures; _b < possibleFailures_1.length; _b++) {\n        var possibleFailure = possibleFailures_1[_b];\n        _loop_1(possibleFailure);\n    }\n}\nfunction getStartOfLineBreak(sourceText, pos) {\n    return sourceText[pos - 2] === \"\\r\" ? pos - 1 : pos - 1;\n}\nfunction getTemplateRanges(sourceFile) {\n    var intervals = [];\n    var cb = function (node) {\n        if (node.kind >= ts.SyntaxKind.FirstTemplateToken &&\n            node.kind <= ts.SyntaxKind.LastTemplateToken) {\n            intervals.push({\n                end: node.end,\n                pos: node.getStart(sourceFile),\n            });\n        }\n        else {\n            return ts.forEachChild(node, cb);\n        }\n    };\n    ts.forEachChild(sourceFile, cb);\n    return intervals;\n}\nexports.getTemplateRanges = getTemplateRanges;\nvar templateObject_1, templateObject_2;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/noConsecutiveBlankLinesRule.js\n// module id = 1958\n// module chunks = 6 115"],"sourceRoot":""}