{"version":3,"sources":["../node_modules/tslint/lib/rules/returnUndefinedRule.js"],"names":["Object","defineProperty","exports","value","ReturnKind","tslib_1","__webpack_require__","tsutils_1","ts","Lint","Rule","_super","apply","this","arguments","__extends","prototype","applyWithProgram","sourceFile","program","applyWithFunction","walk","undefined","getTypeChecker","metadata","ruleName","description","optionsDescription","options","optionExamples","type","typescriptOnly","requiresTypeInfo","FAILURE_STRING_VALUE_RETURN","FAILURE_STRING_VOID_RETURN","Rules","TypedRule","ctx","checker","forEachChild","cb","node","isReturnStatement","actualReturnKind","expression","Void","isIdentifier","text","Value","returnKindFromReturn","functionReturningFrom","ancestorWhere","isFunctionLike","returnKindFromType","kind","SyntaxKind","Constructor","SetAccessor","GetAccessor","asteriskToken","contextual","FunctionExpression","ArrowFunction","isFunctionExpressionLike","tryGetReturnType","getContextualType","returnType","getTypeAtLocation","isTypeFlagSet","TypeFlags","Any","hasModifier","modifiers","AsyncKeyword","isEffectivelyVoidPromise","isEffectivelyVoid","getReturnKind","addFailureAtNode","check","Undefined","isUnionType","types","every","isTypeReference","typeArguments","length","fnType","sigs","getSignaturesOfType","SignatureKind","Call","getReturnTypeOfSignature","FunctionDeclaration","MethodDeclaration"],"mappings":"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","file":"static/js/47.cb43da38.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        return this.applyWithFunction(sourceFile, walk, undefined, program.getTypeChecker());\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"return-undefined\",\n        description: \"Prefer `return;` in void functions and `return undefined;` in value-returning functions.\",\n        optionsDescription: \"Not configurable.\",\n        options: null,\n        optionExamples: [true],\n        type: \"style\",\n        typescriptOnly: false,\n        requiresTypeInfo: true,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING_VALUE_RETURN = \"Value-returning function should use `return undefined;`, not just `return;`.\";\n    Rule.FAILURE_STRING_VOID_RETURN = \"`void` function should use `return;`, not `return undefined;`.\";\n    return Rule;\n}(Lint.Rules.TypedRule));\nexports.Rule = Rule;\nfunction walk(ctx, checker) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (tsutils_1.isReturnStatement(node)) {\n            check(node);\n        }\n        return ts.forEachChild(node, cb);\n    });\n    function check(node) {\n        var actualReturnKind = returnKindFromReturn(node);\n        if (actualReturnKind === undefined) {\n            return;\n        }\n        var functionReturningFrom = Lint.ancestorWhere(node, isFunctionLike);\n        if (functionReturningFrom === undefined) {\n            // Return outside of function is invalid\n            return;\n        }\n        var returnKindFromType = getReturnKind(functionReturningFrom, checker);\n        if (returnKindFromType !== undefined && returnKindFromType !== actualReturnKind) {\n            ctx.addFailureAtNode(node, returnKindFromType === ReturnKind.Void\n                ? Rule.FAILURE_STRING_VOID_RETURN\n                : Rule.FAILURE_STRING_VALUE_RETURN);\n        }\n    }\n}\nfunction returnKindFromReturn(node) {\n    if (node.expression === undefined) {\n        return ReturnKind.Void;\n    }\n    else if (tsutils_1.isIdentifier(node.expression) && node.expression.text === \"undefined\") {\n        return ReturnKind.Value;\n    }\n    else {\n        return undefined;\n    }\n}\nvar ReturnKind;\n(function (ReturnKind) {\n    ReturnKind[ReturnKind[\"Void\"] = 0] = \"Void\";\n    ReturnKind[ReturnKind[\"Value\"] = 1] = \"Value\";\n})(ReturnKind || (ReturnKind = {}));\nfunction getReturnKind(node, checker) {\n    switch (node.kind) {\n        case ts.SyntaxKind.Constructor:\n        case ts.SyntaxKind.SetAccessor:\n            return ReturnKind.Void;\n        case ts.SyntaxKind.GetAccessor:\n            return ReturnKind.Value;\n    }\n    // Handle generator functions/methods:\n    if (node.asteriskToken !== undefined) {\n        return ReturnKind.Void;\n    }\n    var contextual = isFunctionExpressionLike(node) && node.type === undefined\n        ? tryGetReturnType(checker.getContextualType(node), checker)\n        : undefined;\n    var returnType = contextual !== undefined\n        ? contextual\n        : tryGetReturnType(checker.getTypeAtLocation(node), checker);\n    if (returnType === undefined || tsutils_1.isTypeFlagSet(returnType, ts.TypeFlags.Any)) {\n        return undefined;\n    }\n    if ((tsutils_1.hasModifier(node.modifiers, ts.SyntaxKind.AsyncKeyword)\n        ? isEffectivelyVoidPromise\n        : isEffectivelyVoid)(returnType)) {\n        return ReturnKind.Void;\n    }\n    return ReturnKind.Value;\n}\n/** True for `void`, `undefined`, Promise<void>, or `void | undefined | Promise<void>`. */\nfunction isEffectivelyVoidPromise(type) {\n    // Would need access to `checker.getPromisedTypeOfPromise` to do this properly.\n    // Assume that the return type is the global Promise (since this is an async function) and get its type argument.\n    return (\n    // tslint:disable-next-line:no-bitwise\n    tsutils_1.isTypeFlagSet(type, ts.TypeFlags.Void | ts.TypeFlags.Undefined) ||\n        (tsutils_1.isUnionType(type) && type.types.every(isEffectivelyVoidPromise)) ||\n        (tsutils_1.isTypeReference(type) &&\n            type.typeArguments !== undefined &&\n            type.typeArguments.length === 1 &&\n            isEffectivelyVoidPromise(type.typeArguments[0])));\n}\n/** True for `void`, `undefined`, or `void | undefined`. */\nfunction isEffectivelyVoid(type) {\n    return (\n    // tslint:disable-next-line:no-bitwise\n    tsutils_1.isTypeFlagSet(type, ts.TypeFlags.Void | ts.TypeFlags.Undefined) ||\n        (tsutils_1.isUnionType(type) && type.types.every(isEffectivelyVoid)));\n}\nfunction tryGetReturnType(fnType, checker) {\n    if (fnType === undefined) {\n        return undefined;\n    }\n    var sigs = checker.getSignaturesOfType(fnType, ts.SignatureKind.Call);\n    if (sigs.length !== 1) {\n        return undefined;\n    }\n    return checker.getReturnTypeOfSignature(sigs[0]);\n}\nfunction isFunctionLike(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.FunctionDeclaration:\n        case ts.SyntaxKind.FunctionExpression:\n        case ts.SyntaxKind.ArrowFunction:\n        case ts.SyntaxKind.MethodDeclaration:\n        case ts.SyntaxKind.Constructor:\n        case ts.SyntaxKind.GetAccessor:\n        case ts.SyntaxKind.SetAccessor:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isFunctionExpressionLike(node) {\n    return (node.kind === ts.SyntaxKind.FunctionExpression || node.kind === ts.SyntaxKind.ArrowFunction);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/returnUndefinedRule.js\n// module id = 2138\n// module chunks = 47"],"sourceRoot":""}