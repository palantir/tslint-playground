{"version":3,"sources":["../node_modules/tslint/lib/rules/noAngleBracketTypeAssertionRule.js"],"names":["Object","defineProperty","exports","value","templateObject_1","tslib_1","__webpack_require__","tsutils_1","ts","Lint","Rule","_super","apply","this","arguments","__extends","prototype","sourceFile","applyWithFunction","walk","metadata","ruleName","description","hasFix","rationale","Utils","dedent","__makeTemplateObject","optionsDescription","options","optionExamples","type","typescriptOnly","FAILURE_STRING","Rules","AbstractRule","ctx","forEachChild","cb","node","isTypeAssertion","expression","start","getStart","addParens","parent","isBinaryExpression","operatorToken","kind","SyntaxKind","AmpersandToken","BarToken","needsParens","replaceText","getText","addFailure","end","Replacement","appendText","replaceFromTo"],"mappings":"sDAiBAA,OAAAC,eAAAC,EAAA,cAA8CC,OAAA,IAC9C,IAuDAC,EAvDAC,EAAAC,EAAA,GACAC,EAAAD,EAAA,KACAE,EAAAF,EAAA,IACAG,EAAAH,EAAA,MACAI,EAAA,SAAAC,GAEA,SAAAD,IACA,cAAAC,KAAAC,MAAAC,KAAAC,YAAAD,KAmBA,OArBAR,EAAAU,UAAAL,EAAAC,GAIAD,EAAAM,UAAAJ,MAAA,SAAAK,GACA,OAAAJ,KAAAK,kBAAAD,EAAAE,IAGAT,EAAAU,UACAC,SAAA,kCACAC,YAAA,yEACAC,QAAA,EACAC,UAAAf,EAAAgB,MAAAC,OAAAtB,MAAAC,EAAAsB,sBAAA,seACAC,mBAAA,oBACAC,QAAA,KACAC,iBAAA,GACAC,KAAA,QACAC,gBAAA,GAGAtB,EAAAuB,eAAA,kFACAvB,EAtBA,CAuBCD,EAAAyB,MAAAC,cAED,SAAAhB,EAAAiB,GACA,OAAA5B,EAAA6B,aAAAD,EAAAnB,WAAA,SAAAqB,EAAAC,GACA,GAAAhC,EAAAiC,gBAAAD,GAAA,CAKA,IAJA,IAAAE,EAAAF,EAAAE,WACAC,EAAAH,EAAAI,SAAAP,EAAAnB,YACA2B,EAeA,SAAAL,GACA,IAAAM,EAAAN,EAAAM,OACA,OAAAtC,EAAAuC,mBAAAD,KACAA,EAAAE,cAAAC,OAAAxC,EAAAyC,WAAAC,gBACAL,EAAAE,cAAAC,OAAAxC,EAAAyC,WAAAE,UAnBAC,CAAAb,GACAc,EAAA,OAAAd,EAAAR,KAAAuB,QAAAlB,EAAAnB,aAAA2B,EAAA,QACArC,EAAAiC,gBAAAC,IACAY,EAAA,OAAAZ,EAAAV,KAAAuB,QAAAlB,EAAAnB,YAAAoC,EACAZ,eAMA,OAJAL,EAAAmB,WAAAb,EAAAH,EAAAiB,IAAA9C,EAAAuB,gBACAxB,EAAAgD,YAAAC,WAAAnB,EAAAiB,IAAAH,GACA5C,EAAAgD,YAAAE,cAAAjB,EAAAD,EAAAE,SAAAP,EAAAnB,YAAA2B,EAAA,UAEAN,EAAAG,GAEA,OAAAjC,EAAA6B,aAAAE,EAAAD,KAlBApC,EAAAQ","file":"static/js/120.3d1c33b2.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2018 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"no-angle-bracket-type-assertion\",\n        description: \"Requires the use of `as Type` for type assertions instead of `<Type>`.\",\n        hasFix: true,\n        rationale: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            Both formats of type assertions have the same effect, but only `as` type assertions\\n            work in `.tsx` files. This rule ensures that you have a consistent type assertion style\\n            across your codebase.\"], [\"\\n            Both formats of type assertions have the same effect, but only \\\\`as\\\\` type assertions\\n            work in \\\\`.tsx\\\\` files. This rule ensures that you have a consistent type assertion style\\n            across your codebase.\"]))),\n        optionsDescription: \"Not configurable.\",\n        options: null,\n        optionExamples: [true],\n        type: \"style\",\n        typescriptOnly: true,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = \"Type assertion using the '<>' syntax is forbidden. Use the 'as' syntax instead.\";\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (tsutils_1.isTypeAssertion(node)) {\n            var expression = node.expression;\n            var start = node.getStart(ctx.sourceFile);\n            var addParens = needsParens(node);\n            var replaceText = \" as \" + node.type.getText(ctx.sourceFile) + (addParens ? \")\" : \"\");\n            while (tsutils_1.isTypeAssertion(expression)) {\n                replaceText = \" as \" + expression.type.getText(ctx.sourceFile) + replaceText;\n                expression = expression.expression;\n            }\n            ctx.addFailure(start, node.end, Rule.FAILURE_STRING, [\n                Lint.Replacement.appendText(node.end, replaceText),\n                Lint.Replacement.replaceFromTo(start, expression.getStart(ctx.sourceFile), addParens ? \"(\" : \"\"),\n            ]);\n            return cb(expression);\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\nfunction needsParens(node) {\n    var parent = node.parent;\n    return (tsutils_1.isBinaryExpression(parent) &&\n        (parent.operatorToken.kind === ts.SyntaxKind.AmpersandToken ||\n            parent.operatorToken.kind === ts.SyntaxKind.BarToken));\n}\nvar templateObject_1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/noAngleBracketTypeAssertionRule.js\n// module id = 2051\n// module chunks = 120"],"sourceRoot":""}