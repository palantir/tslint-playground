{"version":3,"sources":["../node_modules/tslint/lib/rules/adjacentOverloadSignaturesRule.js"],"names":["Object","defineProperty","exports","value","tslib_1","__webpack_require__","utils","ts","Rule","_super","apply","this","arguments","__extends","FAILURE_STRING","name","prototype","sourceFile","applyWithFunction","walk","metadata","ruleName","description","optionsDescription","options","optionExamples","rationale","type","typescriptOnly","Rules","AbstractRule","ctx","visitStatements","statements","forEachChild","cb","node","kind","SyntaxKind","ModuleBlock","InterfaceDeclaration","ClassDeclaration","TypeLiteral","addFailures","getMisplacedOverloads","members","member","isSignatureDeclaration","getOverloadKey","undefined","statement","isFunctionDeclaration","text","misplacedOverloads","_i","misplacedOverloads_1","length","addFailureAtNode","printOverload","overloads","getKey","lastKey","result","seen","Set","overloads_1","SemicolonClassElement","key","has","push","add","info","getOverloadInfo","_a","computed","isStatic","hasModifier","modifiers","StaticKeyword","ConstructSignature","Constructor","CallSignature","Identifier","ComputedPropertyName","expression","isLiteralExpression","getText"],"mappings":"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","file":"static/js/157.ec5d3c7e.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = function (name) {\n        return \"All '\" + name + \"' signatures should be adjacent\";\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"adjacent-overload-signatures\",\n        description: \"Enforces function overloads to be consecutive.\",\n        optionsDescription: \"Not configurable.\",\n        options: null,\n        optionExamples: [true],\n        rationale: \"Improves readability and organization by grouping naturally related items together.\",\n        type: \"typescript\",\n        typescriptOnly: true,\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var sourceFile = ctx.sourceFile;\n    visitStatements(sourceFile.statements);\n    return ts.forEachChild(sourceFile, function cb(node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.ModuleBlock:\n                visitStatements(node.statements);\n                break;\n            case ts.SyntaxKind.InterfaceDeclaration:\n            case ts.SyntaxKind.ClassDeclaration:\n            case ts.SyntaxKind.TypeLiteral: {\n                var members = node.members;\n                addFailures(getMisplacedOverloads(members, function (member) {\n                    return utils.isSignatureDeclaration(member)\n                        ? getOverloadKey(member)\n                        : undefined;\n                }));\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n    function visitStatements(statements) {\n        addFailures(getMisplacedOverloads(statements, function (statement) {\n            return utils.isFunctionDeclaration(statement) && statement.name !== undefined\n                ? statement.name.text\n                : undefined;\n        }));\n    }\n    function addFailures(misplacedOverloads) {\n        for (var _i = 0, misplacedOverloads_1 = misplacedOverloads; _i < misplacedOverloads_1.length; _i++) {\n            var node = misplacedOverloads_1[_i];\n            ctx.addFailureAtNode(node, Rule.FAILURE_STRING(printOverload(node)));\n        }\n    }\n}\n/** 'getOverloadName' may return undefined for nodes that cannot be overloads, e.g. a `const` declaration. */\nfunction getMisplacedOverloads(overloads, getKey) {\n    var result = [];\n    var lastKey;\n    var seen = new Set();\n    for (var _i = 0, overloads_1 = overloads; _i < overloads_1.length; _i++) {\n        var node = overloads_1[_i];\n        if (node.kind === ts.SyntaxKind.SemicolonClassElement) {\n            continue;\n        }\n        var key = getKey(node);\n        if (key !== undefined) {\n            if (seen.has(key) && lastKey !== key) {\n                result.push(node);\n            }\n            seen.add(key);\n            lastKey = key;\n        }\n        else {\n            lastKey = undefined;\n        }\n    }\n    return result;\n}\nfunction printOverload(node) {\n    var info = getOverloadInfo(node);\n    return typeof info === \"string\" ? info : info === undefined ? \"<unknown>\" : info.name;\n}\nfunction getOverloadKey(node) {\n    var info = getOverloadInfo(node);\n    if (info === undefined) {\n        return undefined;\n    }\n    var _a = typeof info === \"string\" ? [false, info] : [info.computed, info.name], computed = _a[0], name = _a[1];\n    var isStatic = utils.hasModifier(node.modifiers, ts.SyntaxKind.StaticKeyword);\n    return (computed ? \"0\" : \"1\") + (isStatic ? \"0\" : \"1\") + name;\n}\nexports.getOverloadKey = getOverloadKey;\nfunction getOverloadInfo(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.ConstructSignature:\n        case ts.SyntaxKind.Constructor:\n            return \"constructor\";\n        case ts.SyntaxKind.CallSignature:\n            return \"()\";\n        default: {\n            var name = node.name;\n            if (name === undefined) {\n                return undefined;\n            }\n            switch (name.kind) {\n                case ts.SyntaxKind.Identifier:\n                    return name.text;\n                case ts.SyntaxKind.ComputedPropertyName:\n                    var expression = name.expression;\n                    return utils.isLiteralExpression(expression)\n                        ? expression.text\n                        : { name: expression.getText(), computed: true };\n                default:\n                    return utils.isLiteralExpression(name) ? name.text : undefined;\n            }\n        }\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/adjacentOverloadSignaturesRule.js\n// module id = 1957\n// module chunks = 27 157"],"sourceRoot":""}