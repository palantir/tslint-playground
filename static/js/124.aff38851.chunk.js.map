{"version":3,"sources":["../node_modules/tslint/lib/rules/memberOrderingRule.js"],"names":["Object","defineProperty","exports","value","MemberKind","tslib_1","__webpack_require__","tsutils_1","ts","error_1","Lint","utils_1","OPTION_ORDER","OPTION_ALPHABETIZE","PRESETS","Map","PRESET_NAMES","Array","from","keys","allMemberKindNames","mapDefined","key","mk","replace","cap","toLowerCase","undefined","namesMarkdown","names","map","name","join","optionsDescription","Utils","dedent","templateObject_1","__makeTemplateObject","Rule","_super","apply","this","arguments","__extends","FAILURE_STRING_ALPHABETIZE","prevName","curName","show","s","prototype","sourceFile","options","_a","allOptions","length","Error","firstOption","order","categories","kinds","hasOption","splitOldStyleOptions","kind","includes","x","indexOf","convertFromOldStyleOptions","alphabetize","orderOption","isArray","preset","get","JSON","stringify","categoryFromOption","getOptionsJson","orderJson","cat","MemberCategory","Set","memberKindFromName","flatMap","parseOptions","ruleArguments","e","showWarningOnce","ruleName","message","applyWithWalker","MemberOrderingWalker","metadata","description","hasFix","rationale","templateObject_2","type","properties","oneOf","enum","items","maxLength","additionalProperties","optionExamples","typescriptOnly","Rules","AbstractRule","_this","fixes","walk","cb","node","forEachChild","SyntaxKind","ClassDeclaration","ClassExpression","InterfaceDeclaration","TypeLiteral","checkMembers","members","forEach","failure","replacement","getFix","push","prevRank","failureExists","_i","members_1","member","rank","memberRank","nodeType","rankName","prevNodeType","lowerRank","findLowerRank","errorLine1","addFailureAtNode","nameString","caseInsensitiveLess","findLowerName","sortedMemberIndexes","_","i","sort","ai","bi","a","b","rankDiff","aName","bName","nameDiff","localeCompare","splits_1","text","result","getNextSplitIndex","getFullStart","arrayLast","getEnd","getSplitIndexes","sortedMembersText","start","end","nodeText","substring","fixIndex","arrayFindLastIndex","r","applyReplacementOffset","splice","failures","Replacement","replaceFromTo","targetRank","targetName","members_2","max","members_3","Math","optionName","accessLevel","hasModifier","modifiers","PrivateKeyword","ProtectedKeyword","Constructor","ConstructSignature","PropertyDeclaration","PropertySignature","methodOrField","ArrowFunction","FunctionExpression","isFunctionLiteral","initializer","MethodDeclaration","MethodSignature","isMethod","membership","StaticKeyword","access","memberKindForMethodOrField","getMemberKind","findIndex","category","has","AbstractWalker","allAccess","camelize","modifier","modifiedKind","filter","newCategories","_loop_1","yes","no","augmentName","categories_1","Identifier","StringLiteral","NumericLiteral","array","predicate","content","offset","pos","scan","ch","charCodeAt","nextChar","isLineBreak","isWhiteSpaceLike"],"mappings":"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","file":"static/js/124.aff38851.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar error_1 = require(\"../error\");\nvar Lint = require(\"../index\");\nvar utils_1 = require(\"../utils\");\nvar OPTION_ORDER = \"order\";\nvar OPTION_ALPHABETIZE = \"alphabetize\";\nvar MemberKind;\n(function (MemberKind) {\n    MemberKind[MemberKind[\"publicStaticField\"] = 0] = \"publicStaticField\";\n    MemberKind[MemberKind[\"publicStaticMethod\"] = 1] = \"publicStaticMethod\";\n    MemberKind[MemberKind[\"protectedStaticField\"] = 2] = \"protectedStaticField\";\n    MemberKind[MemberKind[\"protectedStaticMethod\"] = 3] = \"protectedStaticMethod\";\n    MemberKind[MemberKind[\"privateStaticField\"] = 4] = \"privateStaticField\";\n    MemberKind[MemberKind[\"privateStaticMethod\"] = 5] = \"privateStaticMethod\";\n    MemberKind[MemberKind[\"publicInstanceField\"] = 6] = \"publicInstanceField\";\n    MemberKind[MemberKind[\"protectedInstanceField\"] = 7] = \"protectedInstanceField\";\n    MemberKind[MemberKind[\"privateInstanceField\"] = 8] = \"privateInstanceField\";\n    MemberKind[MemberKind[\"publicConstructor\"] = 9] = \"publicConstructor\";\n    MemberKind[MemberKind[\"protectedConstructor\"] = 10] = \"protectedConstructor\";\n    MemberKind[MemberKind[\"privateConstructor\"] = 11] = \"privateConstructor\";\n    MemberKind[MemberKind[\"publicInstanceMethod\"] = 12] = \"publicInstanceMethod\";\n    MemberKind[MemberKind[\"protectedInstanceMethod\"] = 13] = \"protectedInstanceMethod\";\n    MemberKind[MemberKind[\"privateInstanceMethod\"] = 14] = \"privateInstanceMethod\";\n})(MemberKind || (MemberKind = {}));\nvar PRESETS = new Map([\n    [\n        \"fields-first\",\n        [\n            \"public-static-field\",\n            \"protected-static-field\",\n            \"private-static-field\",\n            \"public-instance-field\",\n            \"protected-instance-field\",\n            \"private-instance-field\",\n            \"constructor\",\n            \"public-static-method\",\n            \"protected-static-method\",\n            \"private-static-method\",\n            \"public-instance-method\",\n            \"protected-instance-method\",\n            \"private-instance-method\",\n        ],\n    ],\n    [\n        \"instance-sandwich\",\n        [\n            \"public-static-field\",\n            \"protected-static-field\",\n            \"private-static-field\",\n            \"public-instance-field\",\n            \"protected-instance-field\",\n            \"private-instance-field\",\n            \"constructor\",\n            \"public-instance-method\",\n            \"protected-instance-method\",\n            \"private-instance-method\",\n            \"public-static-method\",\n            \"protected-static-method\",\n            \"private-static-method\",\n        ],\n    ],\n    [\n        \"statics-first\",\n        [\n            \"public-static-field\",\n            \"public-static-method\",\n            \"protected-static-field\",\n            \"protected-static-method\",\n            \"private-static-field\",\n            \"private-static-method\",\n            \"public-instance-field\",\n            \"protected-instance-field\",\n            \"private-instance-field\",\n            \"constructor\",\n            \"public-instance-method\",\n            \"protected-instance-method\",\n            \"private-instance-method\",\n        ],\n    ],\n]);\nvar PRESET_NAMES = Array.from(PRESETS.keys());\nvar allMemberKindNames = utils_1.mapDefined(Object.keys(MemberKind), function (key) {\n    var mk = MemberKind[key];\n    return typeof mk === \"number\"\n        ? MemberKind[mk].replace(/[A-Z]/g, function (cap) { return \"-\" + cap.toLowerCase(); })\n        : undefined;\n});\nfunction namesMarkdown(names) {\n    return names.map(function (name) { return \"* `\" + name + \"`\"; }).join(\"\\n    \");\n}\nvar optionsDescription = Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n    One argument, which is an object, must be provided. It should contain an `order` property.\\n    The `order` property should have a value of one of the following strings:\\n\\n    \", \"\\n\\n    Alternatively, the value for `order` may be an array consisting of the following strings:\\n\\n    \", \"\\n\\n    You can also omit the access modifier to refer to \\\"public-\\\", \\\"protected-\\\", and \\\"private-\\\" all at once; for example, \\\"static-field\\\".\\n\\n    You can also make your own categories by using an object instead of a string:\\n\\n        {\\n            \\\"name\\\": \\\"static non-private\\\",\\n            \\\"kinds\\\": [\\n                \\\"public-static-field\\\",\\n                \\\"protected-static-field\\\",\\n                \\\"public-static-method\\\",\\n                \\\"protected-static-method\\\"\\n            ]\\n        }\\n\\n    The '\", \"' option will enforce that members within the same category should be alphabetically sorted by name.\"], [\"\\n    One argument, which is an object, must be provided. It should contain an \\\\`order\\\\` property.\\n    The \\\\`order\\\\` property should have a value of one of the following strings:\\n\\n    \", \"\\n\\n    Alternatively, the value for \\\\`order\\\\` may be an array consisting of the following strings:\\n\\n    \", \"\\n\\n    You can also omit the access modifier to refer to \\\"public-\\\", \\\"protected-\\\", and \\\"private-\\\" all at once; for example, \\\"static-field\\\".\\n\\n    You can also make your own categories by using an object instead of a string:\\n\\n        {\\n            \\\"name\\\": \\\"static non-private\\\",\\n            \\\"kinds\\\": [\\n                \\\"public-static-field\\\",\\n                \\\"protected-static-field\\\",\\n                \\\"public-static-method\\\",\\n                \\\"protected-static-method\\\"\\n            ]\\n        }\\n\\n    The '\", \"' option will enforce that members within the same category should be alphabetically sorted by name.\"])), namesMarkdown(PRESET_NAMES), namesMarkdown(allMemberKindNames), OPTION_ALPHABETIZE);\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.FAILURE_STRING_ALPHABETIZE = function (prevName, curName) {\n        return show(curName) + \" should come alphabetically before \" + show(prevName);\n        function show(s) {\n            return s === \"\" ? \"Computed property\" : \"'\" + s + \"'\";\n        }\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.prototype.apply = function (sourceFile) {\n        var options;\n        try {\n            options = parseOptions(this.ruleArguments);\n        }\n        catch (e) {\n            error_1.showWarningOnce(\"Warning: \" + this.ruleName + \" - \" + e.message);\n            return [];\n        }\n        return this.applyWithWalker(new MemberOrderingWalker(sourceFile, this.ruleName, options));\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"member-ordering\",\n        description: \"Enforces member ordering.\",\n        hasFix: true,\n        rationale: Lint.Utils.dedent(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject([\"\\n            A consistent ordering for class members can make classes easier to read, navigate, and edit.\\n\\n            A common opposite practice to `member-ordering` is to keep related groups of classes together.\\n            Instead of creating classes with multiple separate groups, consider splitting class responsibilities\\n            apart across multiple single-responsibility classes.\\n        \"], [\"\\n            A consistent ordering for class members can make classes easier to read, navigate, and edit.\\n\\n            A common opposite practice to \\\\`member-ordering\\\\` is to keep related groups of classes together.\\n            Instead of creating classes with multiple separate groups, consider splitting class responsibilities\\n            apart across multiple single-responsibility classes.\\n        \"]))),\n        optionsDescription: optionsDescription,\n        options: {\n            type: \"object\",\n            properties: {\n                order: {\n                    oneOf: [\n                        {\n                            type: \"string\",\n                            enum: PRESET_NAMES,\n                        },\n                        {\n                            type: \"array\",\n                            items: {\n                                type: \"string\",\n                                enum: allMemberKindNames,\n                            },\n                            maxLength: 13,\n                        },\n                    ],\n                },\n            },\n            additionalProperties: false,\n        },\n        optionExamples: [\n            [true, { order: \"fields-first\" }],\n            [\n                true,\n                {\n                    order: [\n                        \"public-static-field\",\n                        \"public-instance-field\",\n                        \"public-constructor\",\n                        \"private-static-field\",\n                        \"private-instance-field\",\n                        \"private-constructor\",\n                        \"public-instance-method\",\n                        \"protected-instance-method\",\n                        \"private-instance-method\",\n                    ],\n                },\n            ],\n            [\n                true,\n                {\n                    order: [\n                        {\n                            name: \"static non-private\",\n                            kinds: [\n                                \"public-static-field\",\n                                \"protected-static-field\",\n                                \"public-static-method\",\n                                \"protected-static-method\",\n                            ],\n                        },\n                        \"constructor\",\n                    ],\n                },\n            ],\n        ],\n        type: \"typescript\",\n        typescriptOnly: false,\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nvar MemberOrderingWalker = /** @class */ (function (_super) {\n    tslib_1.__extends(MemberOrderingWalker, _super);\n    function MemberOrderingWalker() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.fixes = [];\n        return _this;\n    }\n    MemberOrderingWalker.prototype.walk = function (sourceFile) {\n        var _this = this;\n        var cb = function (node) {\n            // NB: iterate through children first!\n            ts.forEachChild(node, cb);\n            switch (node.kind) {\n                case ts.SyntaxKind.ClassDeclaration:\n                case ts.SyntaxKind.ClassExpression:\n                case ts.SyntaxKind.InterfaceDeclaration:\n                case ts.SyntaxKind.TypeLiteral:\n                    _this.checkMembers(node.members);\n            }\n        };\n        ts.forEachChild(sourceFile, cb);\n        // assign Replacements which have not been merged into surrounding ones to their RuleFailures.\n        this.fixes.forEach(function (_a) {\n            var failure = _a[0], replacement = _a[1];\n            failure.getFix().push(replacement);\n        });\n    };\n    /**\n     * Check wether the passed members adhere to the configured order. If not, RuleFailures are generated and a single\n     * Lint.Replacement is generated, which replaces the entire NodeArray with a correctly sorted one. The Replacement\n     * is not immediately added to a RuleFailure, as incorrectly sorted nodes can be nested (e.g. a class declaration\n     * in a method implementation), but instead temporarily stored in `this.fixes`. Nested Replacements are manually\n     * merged, as TSLint doesn't handle overlapping ones. For this reason it is important that the recursion happens\n     * before the checkMembers call in this.walk().\n     */\n    MemberOrderingWalker.prototype.checkMembers = function (members) {\n        var _this = this;\n        var prevRank = -1;\n        var prevName;\n        var failureExists = false;\n        for (var _i = 0, members_1 = members; _i < members_1.length; _i++) {\n            var member = members_1[_i];\n            var rank = this.memberRank(member);\n            if (rank === -1) {\n                // no explicit ordering for this kind of node specified, so continue\n                continue;\n            }\n            if (rank < prevRank) {\n                var nodeType = this.rankName(rank);\n                var prevNodeType = this.rankName(prevRank);\n                var lowerRank = this.findLowerRank(members, rank);\n                var locationHint = lowerRank !== -1\n                    ? \"after \" + this.rankName(lowerRank) + \"s\"\n                    : \"at the beginning of the class/interface\";\n                var errorLine1 = \"Declaration of \" + nodeType + \" not allowed after declaration of \" + prevNodeType + \". \" +\n                    (\"Instead, this should come \" + locationHint + \".\");\n                // add empty array as fix so we can add a replacement later. (fix itself is readonly)\n                this.addFailureAtNode(member, errorLine1, []);\n                failureExists = true;\n            }\n            else {\n                if (this.options.alphabetize && member.name !== undefined) {\n                    if (rank !== prevRank) {\n                        // No alphabetical ordering between different ranks\n                        prevName = undefined;\n                    }\n                    var curName = nameString(member.name);\n                    if (prevName !== undefined && caseInsensitiveLess(curName, prevName)) {\n                        this.addFailureAtNode(member.name, Rule.FAILURE_STRING_ALPHABETIZE(this.findLowerName(members, rank, curName), curName), []);\n                        failureExists = true;\n                    }\n                    else {\n                        prevName = curName;\n                    }\n                }\n                // keep track of last good node\n                prevRank = rank;\n            }\n        }\n        if (failureExists) {\n            var sortedMemberIndexes = members.map(function (_, i) { return i; }).sort(function (ai, bi) {\n                var a = members[ai];\n                var b = members[bi];\n                // first, sort by member rank\n                var rankDiff = _this.memberRank(a) - _this.memberRank(b);\n                if (rankDiff !== 0) {\n                    return rankDiff;\n                }\n                // then lexicographically if alphabetize == true\n                if (_this.options.alphabetize && a.name !== undefined && b.name !== undefined) {\n                    var aName = nameString(a.name);\n                    var bName = nameString(b.name);\n                    var nameDiff = aName.localeCompare(bName);\n                    if (nameDiff !== 0) {\n                        return nameDiff;\n                    }\n                }\n                // finally, sort by position in original NodeArray so the sort remains stable.\n                return ai - bi;\n            });\n            var splits_1 = getSplitIndexes(members, this.sourceFile.text);\n            var sortedMembersText = sortedMemberIndexes.map(function (i) {\n                var start = splits_1[i];\n                var end = splits_1[i + 1];\n                var nodeText = _this.sourceFile.text.substring(start, end);\n                while (true) {\n                    // check if there are previous fixes which we need to merge into this one\n                    // if yes, remove it from the list so that we do not return overlapping Replacements\n                    var fixIndex = arrayFindLastIndex(_this.fixes, function (_a) {\n                        var r = _a[1];\n                        return r.start >= start && r.start + r.length <= end;\n                    });\n                    if (fixIndex === -1) {\n                        break;\n                    }\n                    var fix = _this.fixes.splice(fixIndex, 1)[0];\n                    var replacement = fix[1];\n                    nodeText = applyReplacementOffset(nodeText, replacement, start);\n                }\n                return nodeText;\n            });\n            // instead of assigning the fix immediately to the last failure, we temporarily store it in `this.fixes`,\n            // in case a containing node needs to be fixed too. We only \"add\" the fix to the last failure, although\n            // it fixes all failures in this NodeArray, as TSLint doesn't handle duplicate Replacements.\n            this.fixes.push([\n                arrayLast(this.failures),\n                Lint.Replacement.replaceFromTo(splits_1[0], arrayLast(splits_1), sortedMembersText.join(\"\")),\n            ]);\n        }\n    };\n    /** Finds the lowest name higher than 'targetName'. */\n    MemberOrderingWalker.prototype.findLowerName = function (members, targetRank, targetName) {\n        for (var _i = 0, members_2 = members; _i < members_2.length; _i++) {\n            var member = members_2[_i];\n            if (member.name === undefined || this.memberRank(member) !== targetRank) {\n                continue;\n            }\n            var name = nameString(member.name);\n            if (caseInsensitiveLess(targetName, name)) {\n                return name;\n            }\n        }\n        throw new Error(\"Expected to find a name\");\n    };\n    /** Finds the highest existing rank lower than `targetRank`. */\n    MemberOrderingWalker.prototype.findLowerRank = function (members, targetRank) {\n        var max = -1;\n        for (var _i = 0, members_3 = members; _i < members_3.length; _i++) {\n            var member = members_3[_i];\n            var rank = this.memberRank(member);\n            if (rank !== -1 && rank < targetRank) {\n                max = Math.max(max, rank);\n            }\n        }\n        return max;\n    };\n    MemberOrderingWalker.prototype.memberRank = function (member) {\n        var optionName = getMemberKind(member);\n        if (optionName === undefined) {\n            return -1;\n        }\n        return this.options.order.findIndex(function (category) { return category.has(optionName); });\n    };\n    MemberOrderingWalker.prototype.rankName = function (rank) {\n        return this.options.order[rank].name;\n    };\n    return MemberOrderingWalker;\n}(Lint.AbstractWalker));\nfunction caseInsensitiveLess(a, b) {\n    return a.toLowerCase() < b.toLowerCase();\n}\nfunction memberKindForConstructor(access) {\n    return MemberKind[access + \"Constructor\"];\n}\nfunction memberKindForMethodOrField(access, membership, kind) {\n    return MemberKind[access + membership + kind];\n}\nvar allAccess = [\"public\", \"protected\", \"private\"];\nfunction memberKindFromName(name) {\n    var kind = MemberKind[Lint.Utils.camelize(name)];\n    return typeof kind === \"number\" ? [kind] : allAccess.map(addModifier);\n    function addModifier(modifier) {\n        var modifiedKind = MemberKind[Lint.Utils.camelize(modifier + \"-\" + name)];\n        if (typeof modifiedKind !== \"number\") {\n            throw new Error(\"Bad member kind: \" + name);\n        }\n        return modifiedKind;\n    }\n}\nfunction getMemberKind(member) {\n    var accessLevel = tsutils_1.hasModifier(member.modifiers, ts.SyntaxKind.PrivateKeyword)\n        ? \"private\"\n        : tsutils_1.hasModifier(member.modifiers, ts.SyntaxKind.ProtectedKeyword)\n            ? \"protected\"\n            : \"public\";\n    switch (member.kind) {\n        case ts.SyntaxKind.Constructor:\n        case ts.SyntaxKind.ConstructSignature:\n            return memberKindForConstructor(accessLevel);\n        case ts.SyntaxKind.PropertyDeclaration:\n        case ts.SyntaxKind.PropertySignature:\n            return methodOrField(isFunctionLiteral(member.initializer));\n        case ts.SyntaxKind.MethodDeclaration:\n        case ts.SyntaxKind.MethodSignature:\n            return methodOrField(true);\n        default:\n            return undefined;\n    }\n    function methodOrField(isMethod) {\n        var membership = tsutils_1.hasModifier(member.modifiers, ts.SyntaxKind.StaticKeyword)\n            ? \"Static\"\n            : \"Instance\";\n        return memberKindForMethodOrField(accessLevel, membership, isMethod ? \"Method\" : \"Field\");\n    }\n}\nvar MemberCategory = /** @class */ (function () {\n    function MemberCategory(name, kinds) {\n        this.name = name;\n        this.kinds = kinds;\n    }\n    MemberCategory.prototype.has = function (kind) {\n        return this.kinds.has(kind);\n    };\n    return MemberCategory;\n}());\nfunction parseOptions(options) {\n    var _a = getOptionsJson(options), orderJson = _a.order, alphabetize = _a.alphabetize;\n    var order = orderJson.map(function (cat) {\n        return typeof cat === \"string\"\n            ? new MemberCategory(cat.replace(/-/g, \" \"), new Set(memberKindFromName(cat)))\n            : new MemberCategory(cat.name, new Set(utils_1.flatMap(cat.kinds, memberKindFromName)));\n    });\n    return { order: order, alphabetize: alphabetize };\n}\nfunction getOptionsJson(allOptions) {\n    if (allOptions == undefined || allOptions.length === 0 || allOptions[0] == undefined) {\n        throw new Error(\"Got empty options\");\n    }\n    var firstOption = allOptions[0];\n    if (typeof firstOption !== \"object\") {\n        // Undocumented direct string option. Deprecate eventually.\n        return { order: convertFromOldStyleOptions(allOptions), alphabetize: false }; // presume allOptions to be string[]\n    }\n    return {\n        alphabetize: firstOption[OPTION_ALPHABETIZE] === true,\n        order: categoryFromOption(firstOption[OPTION_ORDER]),\n    };\n}\nfunction categoryFromOption(orderOption) {\n    if (Array.isArray(orderOption)) {\n        return orderOption;\n    }\n    var preset = PRESETS.get(orderOption);\n    if (preset === undefined) {\n        throw new Error(\"Bad order: \" + JSON.stringify(orderOption));\n    }\n    return preset;\n}\n/**\n * Convert from undocumented old-style options.\n * This is designed to mimic the old behavior and should be removed eventually.\n */\nfunction convertFromOldStyleOptions(options) {\n    var categories = [{ name: \"member\", kinds: allMemberKindNames }];\n    if (hasOption(\"variables-before-functions\")) {\n        categories = splitOldStyleOptions(categories, function (kind) { return kind.includes(\"field\"); }, \"field\", \"method\");\n    }\n    if (hasOption(\"static-before-instance\")) {\n        categories = splitOldStyleOptions(categories, function (kind) { return kind.includes(\"static\"); }, \"static\", \"instance\");\n    }\n    if (hasOption(\"public-before-private\")) {\n        // 'protected' is considered public\n        categories = splitOldStyleOptions(categories, function (kind) { return !kind.includes(\"private\"); }, \"public\", \"private\");\n    }\n    return categories;\n    function hasOption(x) {\n        return options.indexOf(x) !== -1;\n    }\n}\nfunction splitOldStyleOptions(categories, filter, a, b) {\n    var newCategories = [];\n    var _loop_1 = function (cat) {\n        var yes = [];\n        var no = [];\n        for (var _i = 0, _a = cat.kinds; _i < _a.length; _i++) {\n            var kind = _a[_i];\n            if (filter(kind)) {\n                yes.push(kind);\n            }\n            else {\n                no.push(kind);\n            }\n        }\n        var augmentName = function (s) {\n            if (a === \"field\") {\n                // Replace \"member\" with \"field\"/\"method\" instead of augmenting.\n                return s;\n            }\n            return s + \" \" + cat.name;\n        };\n        newCategories.push({ name: augmentName(a), kinds: yes });\n        newCategories.push({ name: augmentName(b), kinds: no });\n    };\n    for (var _i = 0, categories_1 = categories; _i < categories_1.length; _i++) {\n        var cat = categories_1[_i];\n        _loop_1(cat);\n    }\n    return newCategories;\n}\nfunction isFunctionLiteral(node) {\n    if (node === undefined) {\n        return false;\n    }\n    switch (node.kind) {\n        case ts.SyntaxKind.ArrowFunction:\n        case ts.SyntaxKind.FunctionExpression:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction nameString(name) {\n    switch (name.kind) {\n        case ts.SyntaxKind.Identifier:\n        case ts.SyntaxKind.StringLiteral:\n        case ts.SyntaxKind.NumericLiteral:\n            return name.text;\n        default:\n            return \"\";\n    }\n}\n/**\n * Returns the last element of an array. (Or undefined).\n */\nfunction arrayLast(array) {\n    return array[array.length - 1];\n}\n/**\n * Array.prototype.findIndex, but the last index.\n */\nfunction arrayFindLastIndex(array, predicate) {\n    for (var i = array.length; i-- > 0;) {\n        if (predicate(array[i], i, array)) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Applies a Replacement to a part of the text which starts at offset.\n * See also Replacement.apply\n */\nfunction applyReplacementOffset(content, replacement, offset) {\n    return (content.substring(0, replacement.start - offset) +\n        replacement.text +\n        content.substring(replacement.start - offset + replacement.length));\n}\n/**\n * Get the indexes of the boundaries between nodes in the node array. The following points must be taken into account:\n * - Trivia should stay with its corresponding node (comments on the same line following the token belong to the\n *   previous token, the rest to the next).\n * - Reordering the subtexts should not result in code being commented out due to being moved between a \"//\" and\n *   the following newline.\n * - The end of one node must be the start of the next, otherwise the intravening whitespace will be lost when\n *   reordering.\n *\n * Hence, the boundaries are chosen to be _after_ the newline following the node, or the beginning of the next token,\n * if that comes first.\n */\nfunction getSplitIndexes(members, text) {\n    var result = members.map(function (member) { return getNextSplitIndex(text, member.getFullStart()); });\n    result.push(getNextSplitIndex(text, arrayLast(members).getEnd()));\n    return result;\n}\n/**\n * Calculates the index after the newline following pos, or the beginning of the next token, whichever comes first.\n * See also getSplitIndexes.\n * This method is a modified version of TypeScript's internal iterateCommentRanges function.\n */\nfunction getNextSplitIndex(text, pos) {\n    scan: while (pos >= 0 && pos < text.length) {\n        var ch = text.charCodeAt(pos);\n        switch (ch) {\n            case 13 /* carriageReturn */:\n                if (text.charCodeAt(pos + 1) === 10 /* lineFeed */) {\n                    pos++;\n                }\n            // falls through\n            case 10 /* lineFeed */:\n                pos++;\n                // split is after new line\n                return pos;\n            case 9 /* tab */:\n            case 11 /* verticalTab */:\n            case 12 /* formFeed */:\n            case 32 /* space */:\n                // skip whitespace\n                pos++;\n                continue;\n            case 47 /* slash */:\n                var nextChar = text.charCodeAt(pos + 1);\n                if (nextChar === 47 /* slash */ || nextChar === 42 /* asterisk */) {\n                    var isSingleLineComment = nextChar === 47 /* slash */;\n                    pos += 2;\n                    if (isSingleLineComment) {\n                        while (pos < text.length) {\n                            if (ts.isLineBreak(text.charCodeAt(pos))) {\n                                // the comment ends here, go back to default logic to handle parsing new line and result\n                                continue scan;\n                            }\n                            pos++;\n                        }\n                    }\n                    else {\n                        while (pos < text.length) {\n                            if (text.charCodeAt(pos) === 42 /* asterisk */ &&\n                                text.charCodeAt(pos + 1) === 47 /* slash */) {\n                                pos += 2;\n                                continue scan;\n                            }\n                            pos++;\n                        }\n                    }\n                    // if we arrive here, it's because pos == text.length\n                    return pos;\n                }\n                break scan;\n            default:\n                // skip whitespace:\n                if (ch > 127 /* maxAsciiCharacter */ && ts.isWhiteSpaceLike(ch)) {\n                    pos++;\n                    continue;\n                }\n                break scan;\n        }\n    }\n    return pos;\n}\nvar templateObject_1, templateObject_2;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/memberOrderingRule.js\n// module id = 2047\n// module chunks = 124"],"sourceRoot":""}