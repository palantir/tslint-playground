{"version":3,"sources":["../node_modules/tslint/lib/rules/promiseFunctionAsyncRule.js"],"names":["Object","defineProperty","exports","value","_a","tslib_1","__webpack_require__","tsutils_1","ts","Lint","KIND_FOR_OPTION","SyntaxKind","FunctionDeclaration","FunctionExpression","ArrowFunction","MethodDeclaration","templateObject_1","Rule","_super","apply","this","arguments","__extends","prototype","applyWithProgram","sourceFile","program","applyWithFunction","walk","ruleArguments","length","keys","enabledKinds","Set","_i","ruleArguments_1","arg","add","parseOptions","getTypeChecker","metadata","ruleName","description","rationale","Utils","dedent","__makeTemplateObject","optionsDescription","options","type","items","enum","minLength","maxLength","optionExamples","typescriptOnly","requiresTypeInfo","FAILURE_STRING","Rules","TypedRule","ctx","tc","forEachChild","cb","node","has","kind","undefined","body","hasModifier","modifiers","AsyncKeyword","getReturnTypeOfSignature","getTypeAtLocation","getCallSignatures","symbol","name","returnsPromise","addFailure","getStart","pos"],"mappings":"qDAiBAA,OAAAC,eAAAC,EAAA,cAA8CC,OAAA,IAC9C,IACAC,EADAC,EAAAC,EAAA,GAEAC,EAAAD,EAAA,KACAE,EAAAF,EAAA,IACAG,EAAAH,EAAA,MAKAI,IAAAN,MAJA,8BAKAI,EAAAG,WAAAC,oBACAR,EALA,6BAKAI,EAAAG,WAAAE,mBACAT,EALA,wBAKAI,EAAAG,WAAAG,cACAV,EALA,4BAKAI,EAAAG,WAAAI,kBACAX,GAYA,IAgEAY,EAhEAC,EAAA,SAAAC,GAEA,SAAAD,IACA,cAAAC,KAAAC,MAAAC,KAAAC,YAAAD,KAgCA,OAlCAf,EAAAiB,UAAAL,EAAAC,GAIAD,EAAAM,UAAAC,iBAAA,SAAAC,EAAAC,GACA,OAAAN,KAAAO,kBAAAF,EAAAG,EAjBA,SAAAC,GACA,IAAAA,EAAAC,SACAD,EAAA7B,OAAA+B,KAAArB,IAGA,IADA,IAAAsB,EAAA,IAAAC,IACAC,EAAA,EAAAC,EAAAN,EAAqDK,EAAAC,EAAAL,OAA6BI,IAAA,CAClF,IAAAE,EAAAD,EAAAD,GACAF,EAAAK,IAAA3B,EAAA0B,IAEA,OAAAJ,EAQAM,CAAAlB,KAAAS,eAAAH,EAAAa,mBAGAtB,EAAAuB,UACAC,SAAA,yBACAC,YAAA,6EACAC,UAAAlC,EAAAmC,MAAAC,OAAA7B,MAAAX,EAAAyC,sBAAA,i5CAjCA,6BACA,4BACA,uBACA,4BA+BAC,mBAAA,oBACAC,SACAC,KAAA,QACAC,OACAD,KAAA,SACAE,MAvCA,6BACA,4BACA,uBACA,6BA2CAC,UAAA,EACAC,UAAA,GAEAC,iBAAA,MAjDA,6BAGA,6BA+CAL,KAAA,aACAM,gBAAA,EACAC,kBAAA,GAGAvC,EAAAwC,eAAA,+CACAxC,EAnCA,CAoCCR,EAAAiD,MAAAC,WAED,SAAA/B,EAAAgC,EAAAC,GACA,IAAApC,EAAAmC,EAAAnC,WAAAuB,EAAAY,EAAAZ,QACA,OAAAxC,EAAAsD,aAAArC,EAAA,SAAAsC,EAAAC,GACA,GAAAhB,EAAAiB,IAAAD,EAAAE,MACA,OAAAF,EAAAE,MACA,KAAA1D,EAAAG,WAAAI,kBACA,KAAAP,EAAAG,WAAAC,oBACA,QAAAuD,IAAAH,EAAAI,KACA,MAGA,KAAA5D,EAAAG,WAAAE,mBACA,KAAAL,EAAAG,WAAAG,eACAP,EAAA8D,YAAAL,EAAAM,UAAA9D,EAAAG,WAAA4D,eASA,SAAAP,EAAAH,GACA,IAAAZ,EAAAY,EAAAW,yBAAAX,EAAAY,kBAAAT,GAAAU,oBAAA,IACA,YAAAP,IAAAlB,EAAA0B,QAAA,YAAA1B,EAAA0B,OAAAC,KAVAC,CAAAb,EAAAH,IACAD,EAAAkB,WAAAd,EAAAe,SAAAtD,GAAAuC,EAAAI,KAAAY,IAAA/D,EAAAwC,gBAIA,OAAAjD,EAAAsD,aAAAE,EAAAD,KApBA7D,EAAAe","file":"static/js/50.266ecd37.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2018 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar _a;\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_FUNCTION_DECLARATION = \"check-function-declaration\";\nvar OPTION_FUNCTION_EXPRESSION = \"check-function-expression\";\nvar OPTION_ARROW_FUNCTION = \"check-arrow-function\";\nvar OPTION_METHOD_DECLARATION = \"check-method-declaration\";\nvar KIND_FOR_OPTION = (_a = {},\n    _a[OPTION_FUNCTION_DECLARATION] = ts.SyntaxKind.FunctionDeclaration,\n    _a[OPTION_FUNCTION_EXPRESSION] = ts.SyntaxKind.FunctionExpression,\n    _a[OPTION_ARROW_FUNCTION] = ts.SyntaxKind.ArrowFunction,\n    _a[OPTION_METHOD_DECLARATION] = ts.SyntaxKind.MethodDeclaration,\n    _a);\nfunction parseOptions(ruleArguments) {\n    if (ruleArguments.length === 0) {\n        ruleArguments = Object.keys(KIND_FOR_OPTION);\n    }\n    var enabledKinds = new Set();\n    for (var _i = 0, ruleArguments_1 = ruleArguments; _i < ruleArguments_1.length; _i++) {\n        var arg = ruleArguments_1[_i];\n        enabledKinds.add(KIND_FOR_OPTION[arg]);\n    }\n    return enabledKinds;\n}\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        return this.applyWithFunction(sourceFile, walk, parseOptions(this.ruleArguments), program.getTypeChecker());\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"promise-function-async\",\n        description: \"Requires any function or method that returns a promise to be marked async.\",\n        rationale: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            Ensures that each function is only capable of 1) returning a rejected promise, or 2)\\n            throwing an Error object. In contrast, non-`async` `Promise`-returning functions\\n            are technically capable of either. This practice removes a requirement for consuming\\n            code to handle both cases.\\n\\n            If no optional arguments are provided then all function types are checked,\\n            otherwise the specific function types are checked:\\n\\n            * `\\\"\", \"\\\"` check function declarations.\\n            * `\\\"\", \"\\\"` check function expressions.\\n            * `\\\"\", \"\\\"` check arrow functions.\\n            * `\\\"\", \"\\\"` check method declarations.\\n        \"], [\"\\n            Ensures that each function is only capable of 1) returning a rejected promise, or 2)\\n            throwing an Error object. In contrast, non-\\\\`async\\\\` \\\\`Promise\\\\`-returning functions\\n            are technically capable of either. This practice removes a requirement for consuming\\n            code to handle both cases.\\n\\n            If no optional arguments are provided then all function types are checked,\\n            otherwise the specific function types are checked:\\n\\n            * \\\\`\\\"\", \"\\\"\\\\` check function declarations.\\n            * \\\\`\\\"\", \"\\\"\\\\` check function expressions.\\n            * \\\\`\\\"\", \"\\\"\\\\` check arrow functions.\\n            * \\\\`\\\"\", \"\\\"\\\\` check method declarations.\\n        \"])), OPTION_FUNCTION_DECLARATION, OPTION_FUNCTION_EXPRESSION, OPTION_ARROW_FUNCTION, OPTION_METHOD_DECLARATION),\n        optionsDescription: \"Not configurable.\",\n        options: {\n            type: \"array\",\n            items: {\n                type: \"string\",\n                enum: [\n                    OPTION_FUNCTION_DECLARATION,\n                    OPTION_FUNCTION_EXPRESSION,\n                    OPTION_ARROW_FUNCTION,\n                    OPTION_METHOD_DECLARATION,\n                ],\n            },\n            minLength: 0,\n            maxLength: 4,\n        },\n        optionExamples: [true, [true, OPTION_FUNCTION_DECLARATION, OPTION_METHOD_DECLARATION]],\n        type: \"typescript\",\n        typescriptOnly: false,\n        requiresTypeInfo: true,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = \"functions that return promises must be async\";\n    return Rule;\n}(Lint.Rules.TypedRule));\nexports.Rule = Rule;\nfunction walk(ctx, tc) {\n    var sourceFile = ctx.sourceFile, options = ctx.options;\n    return ts.forEachChild(sourceFile, function cb(node) {\n        if (options.has(node.kind)) {\n            switch (node.kind) {\n                case ts.SyntaxKind.MethodDeclaration:\n                case ts.SyntaxKind.FunctionDeclaration:\n                    if (node.body === undefined) {\n                        break;\n                    }\n                // falls through\n                case ts.SyntaxKind.FunctionExpression:\n                case ts.SyntaxKind.ArrowFunction:\n                    if (!tsutils_1.hasModifier(node.modifiers, ts.SyntaxKind.AsyncKeyword) &&\n                        returnsPromise(node, tc)) {\n                        ctx.addFailure(node.getStart(sourceFile), node.body.pos, Rule.FAILURE_STRING);\n                    }\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\nfunction returnsPromise(node, tc) {\n    var type = tc.getReturnTypeOfSignature(tc.getTypeAtLocation(node).getCallSignatures()[0]);\n    return type.symbol !== undefined && type.symbol.name === \"Promise\";\n}\nvar templateObject_1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/promiseFunctionAsyncRule.js\n// module id = 2134\n// module chunks = 50"],"sourceRoot":""}