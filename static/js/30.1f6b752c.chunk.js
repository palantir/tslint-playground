webpackJsonp([30],{2135:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var o=t(1),a=t(843),r=t(55),s=t(1117),i={enum:["always","never"],type:"string"},c=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return o.__extends(n,e),n.prototype.apply=function(e){return this.applyWithFunction(e,h,function(e){for(var n={constructor:void 0},t=0,o=d;t<o.length;t++){var a=o[t];n[a]="object"===typeof e?e[a]:void 0===e?"always":e}return n}(this.ruleArguments[0]))},n.metadata={description:"Require or disallow a space before function parenthesis",hasFix:!0,optionExamples:[!0,[!0,"always"],[!0,"never"],[!0,{anonymous:"always",named:"never",asyncArrow:"always"}]],options:{properties:{anonymous:i,asyncArrow:i,constructor:i,method:i,named:i},type:"object"},optionsDescription:s.Utils.dedent(u||(u=o.__makeTemplateObject(['\n            One argument which is an object which may contain the keys `anonymous`, `named`, and `asyncArrow`\n            These should be set to either `"always"` or `"never"`.\n\n            * `"anonymous"` checks before the opening paren in anonymous functions\n            * `"named"` checks before the opening paren in named functions\n            * `"asyncArrow"` checks before the opening paren in async arrow functions\n            * `"method"` checks before the opening paren in class methods\n            * `"constructor"` checks before the opening paren in class constructors\n        '],['\n            One argument which is an object which may contain the keys \\`anonymous\\`, \\`named\\`, and \\`asyncArrow\\`\n            These should be set to either \\`"always"\\` or \\`"never"\\`.\n\n            * \\`"anonymous"\\` checks before the opening paren in anonymous functions\n            * \\`"named"\\` checks before the opening paren in named functions\n            * \\`"asyncArrow"\\` checks before the opening paren in async arrow functions\n            * \\`"method"\\` checks before the opening paren in class methods\n            * \\`"constructor"\\` checks before the opening paren in class constructors\n        ']))),ruleName:"space-before-function-paren",type:"style",typescriptOnly:!1},n.INVALID_WHITESPACE_ERROR="Spaces before function parens are disallowed",n.MISSING_WHITESPACE_ERROR="Missing whitespace before function parens",n}(s.Rules.AbstractRule);n.Rule=c;var u,d=["anonymous","asyncArrow","constructor","method","named"];function h(e){var n=e.options,t=e.sourceFile;r.forEachChild(t,function o(i){var u=function(e,n){switch(e.kind){case r.SyntaxKind.ArrowFunction:return!p(e)&&a.hasModifier(e.modifiers,r.SyntaxKind.AsyncKeyword)?n.asyncArrow:void 0;case r.SyntaxKind.Constructor:return n.constructor;case r.SyntaxKind.FunctionDeclaration:case r.SyntaxKind.FunctionExpression:var t=e.name,o=void 0!==t&&""!==t.text;return o?n.named:p(e)?void 0:n.anonymous;case r.SyntaxKind.MethodDeclaration:case r.SyntaxKind.MethodSignature:case r.SyntaxKind.GetAccessor:case r.SyntaxKind.SetAccessor:return n.method;default:return}}(i,n);void 0!==u&&function(n,o){var i=a.getChildOfKind(n,r.SyntaxKind.OpenParenToken,t);if(void 0===i)return;var u=s.isWhiteSpace(t.text.charCodeAt(i.end-2));if(u&&"never"===o){var d=i.getStart()-1;e.addFailureAt(d,1,c.INVALID_WHITESPACE_ERROR,s.Replacement.deleteText(d,1))}else if(!u&&"always"===o){var d=i.getStart();e.addFailureAt(d,1,c.MISSING_WHITESPACE_ERROR,s.Replacement.appendText(d," "))}}(i,u),r.forEachChild(i,o)})}function p(e){return void 0!==e.typeParameters}}});
//# sourceMappingURL=30.1f6b752c.chunk.js.map