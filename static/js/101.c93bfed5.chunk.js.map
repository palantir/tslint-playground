{"version":3,"sources":["../node_modules/tslint/lib/rules/noDuplicateSuperRule.js"],"names":["Object","defineProperty","exports","value","tslib_1","__webpack_require__","tsutils_1","ts","Rule","_super","apply","this","arguments","__extends","prototype","sourceFile","applyWithFunction","walk","metadata","ruleName","description","rationale","optionsDescription","options","optionExamples","type","typescriptOnly","FAILURE_STRING_DUPLICATE","FAILURE_STRING_LOOP","Rules","AbstractRule","ctx","forEachChild","cb","node","isConstructorDeclaration","undefined","body","getSuperForNode","isIterationStatement","bodySuper","combineSequentialChildren","break","addFailureAtNode","__assign","kind","SyntaxKind","ReturnStatement","ThrowStatement","BreakStatement","ClassDeclaration","ClassExpression","SuperKeyword","parent","CallExpression","expression","ConditionalExpression","_a","condition","whenTrue","whenFalse","inCondition","inBranches","worse","addDuplicateFailure","IfStatement","_b","thenStatement","elseStatement","SwitchStatement","foundSingle","fallthroughSingle","_i","caseBlock","clauses","length","clause","clauseSuper","getSuperForSwitch","seenSingle","res","child","childSuper","a","b","addFailure","getStart","end"],"mappings":"sDAiBAA,OAAAC,eAAAC,EAAA,cAA8CC,OAAA,IAC9C,IAAAC,EAAAC,EAAA,GACAC,EAAAD,EAAA,KACAE,EAAAF,EAAA,IAEAG,EAAA,SAAAC,GAEA,SAAAD,IACA,cAAAC,KAAAC,MAAAC,KAAAC,YAAAD,KAmBA,OArBAP,EAAAS,UAAAL,EAAAC,GAIAD,EAAAM,UAAAJ,MAAA,SAAAK,GACA,OAAAJ,KAAAK,kBAAAD,EAAAE,IAGAT,EAAAU,UACAC,SAAA,qBACAC,YAAA,qDACAC,UAAA,qDACAC,mBAAA,oBACAC,QAAA,KACAC,iBAAA,GACAC,KAAA,gBACAC,gBAAA,GAGAlB,EAAAmB,yBAAA,kEACAnB,EAAAoB,oBAAA,2DACApB,EAtBA,CADAH,EAAA,MAwBCwB,MAAAC,cAED,SAAAb,EAAAc,GACA,OAAAxB,EAAAyB,aAAAD,EAAAhB,WAAA,SAAAkB,EAAAC,GAIA,OAHA5B,EAAA6B,yBAAAD,SAAAE,IAAAF,EAAAG,MACAC,EAAAJ,EAAAG,MAEA9B,EAAAyB,aAAAE,EAAAD,KAEA,SAAAK,EAAAJ,GACA,GAAA5B,EAAAiC,qBAAAL,GAAA,CACA,IAAAM,EAAAC,EAAAP,GACA,wBAAAM,EACA,GAEAA,EAAAE,OACAX,EAAAY,iBAAAH,EAAAN,KAAA1B,EAAAoB,qBAEAxB,EAAAwC,YAAsCJ,GAAcE,OAAA,KAEpD,OAAAR,EAAAW,MACA,KAAAtC,EAAAuC,WAAAC,gBACA,KAAAxC,EAAAuC,WAAAE,eACA,SACA,KAAAzC,EAAAuC,WAAAG,eACA,SACA,KAAA1C,EAAAuC,WAAAI,iBACA,KAAA3C,EAAAuC,WAAAK,gBAEA,SACA,KAAA5C,EAAAuC,WAAAM,aACA,OAAAlB,EAAAmB,OAAAR,OAAAtC,EAAAuC,WAAAQ,gBAAApB,EAAAmB,OAAAE,aAAArB,GACuBA,OAAAmB,OAAAX,OAAA,GACvB,EACA,KAAAnC,EAAAuC,WAAAU,sBACA,IAAAC,EAAAvB,EAAAwB,EAAAD,EAAAC,UAAAC,EAAAF,EAAAE,SAAAC,EAAAH,EAAAG,UACAC,EAAAvB,EAAAoB,GACAI,EAAAC,EAAAzB,EAAAqB,GAAArB,EAAAsB,IAIA,MAHA,kBAAAC,GAAA,kBAAAC,GACAE,EAAAH,EAAA3B,KAAA4B,EAAA5B,MAEA6B,EAAAF,EAAAC,GAEA,KAAAvD,EAAAuC,WAAAmB,YACA,IAAAC,EAAAhC,EAAAiC,EAAAD,EAAAC,cAAAC,EAAAF,EAAAE,cACA,OAAAL,EAAAzB,EAAA6B,QAAA/B,IAAAgC,EAAA9B,EAAA8B,GAAA,GAEA,KAAA7D,EAAAuC,WAAAuB,gBACA,OAKA,SAAAnC,GAKA,IAHA,IAAAoC,EAEAC,EACAC,EAAA,EAAAf,EAAAvB,EAAAuC,UAAAC,QAAqDF,EAAAf,EAAAkB,OAAgBH,IAAA,CACrE,IAAAI,EAAAnB,EAAAe,GACAK,EAAApC,EAAAmC,GACA,OAAAC,GACA,OACA,MACA,OACAN,OAAAnC,EACA,MACA,OACA,SACA,aACAA,IAAAmC,GACAP,EAAAO,EAAAM,EAAA3C,MAEA2C,EAAAnC,QACA6B,EAAAM,EAAA3C,MAEAoC,EAAAO,EAAA3C,MAGA,YAAAE,IAAAkC,GAA4CpC,KAAAoC,EAAA5B,OAAA,GAAkC,EA/B9EoC,CAAA5C,GACA,QACA,OAAAO,EAAAP,IAmCA,SAAAO,EAAAP,GACA,IAAA6C,EACAC,EAAAzE,EAAAyB,aAAAE,EAAA,SAAA+C,GACA,IAAAC,EAAA5C,EAAA2C,GACA,OAAAC,GACA,OACA,OACA,OACA,YAAA9C,IAAA2C,EACA3E,EAAAwC,YAAkDmC,GAAerC,OAAA,IAEjEwC,EACA,OACA,OAAAA,EACA,QAKA,YAJA9C,IAAA2C,KAAArC,OACAsB,EAAAe,EAAA7C,KAAAgD,EAAAhD,WAEA6C,EAAAG,MAIA,YAAA9C,IAAA4C,SAAA5C,IAAA2C,IAAA,EAEA,SAAAf,EAAAmB,EAAAC,GACArD,EAAAsD,WAAAF,EAAAG,WAAAF,EAAAG,IAAA/E,EAAAmB,2BAIA,SAAAoC,EAAAoB,EAAAC,GACA,wBAAAD,EACA,kBAAAC,EAAAD,EAAAC,IAAAD,EAAAC,EACA,kBAAAA,EAAAD,IAAAzC,MAAA0C,EAAAD,EApHAjF,EAAAM","file":"static/js/101.c93bfed5.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"no-duplicate-super\",\n        description: \"Warns if 'super()' appears twice in a constructor.\",\n        rationale: \"The second call to 'super()' will fail at runtime.\",\n        optionsDescription: \"Not configurable.\",\n        options: null,\n        optionExamples: [true],\n        type: \"functionality\",\n        typescriptOnly: false,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING_DUPLICATE = \"Multiple calls to 'super()' found. It must be called only once.\";\n    Rule.FAILURE_STRING_LOOP = \"'super()' called in a loop. It must be called only once.\";\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (tsutils_1.isConstructorDeclaration(node) && node.body !== undefined) {\n            getSuperForNode(node.body);\n        }\n        return ts.forEachChild(node, cb);\n    });\n    function getSuperForNode(node) {\n        if (tsutils_1.isIterationStatement(node)) {\n            var bodySuper = combineSequentialChildren(node);\n            if (typeof bodySuper === \"number\") {\n                return 0 /* NoSuper */;\n            }\n            if (!bodySuper.break) {\n                ctx.addFailureAtNode(bodySuper.node, Rule.FAILURE_STRING_LOOP);\n            }\n            return tslib_1.__assign({}, bodySuper, { break: false });\n        }\n        switch (node.kind) {\n            case ts.SyntaxKind.ReturnStatement:\n            case ts.SyntaxKind.ThrowStatement:\n                return 1 /* Return */;\n            case ts.SyntaxKind.BreakStatement:\n                return 2 /* Break */;\n            case ts.SyntaxKind.ClassDeclaration:\n            case ts.SyntaxKind.ClassExpression:\n                // 'super()' is bound differently inside, so ignore.\n                return 0 /* NoSuper */;\n            case ts.SyntaxKind.SuperKeyword:\n                return node.parent.kind === ts.SyntaxKind.CallExpression && node.parent.expression === node\n                    ? { node: node.parent, break: false }\n                    : 0 /* NoSuper */;\n            case ts.SyntaxKind.ConditionalExpression: {\n                var _a = node, condition = _a.condition, whenTrue = _a.whenTrue, whenFalse = _a.whenFalse;\n                var inCondition = getSuperForNode(condition);\n                var inBranches = worse(getSuperForNode(whenTrue), getSuperForNode(whenFalse));\n                if (typeof inCondition !== \"number\" && typeof inBranches !== \"number\") {\n                    addDuplicateFailure(inCondition.node, inBranches.node);\n                }\n                return worse(inCondition, inBranches);\n            }\n            case ts.SyntaxKind.IfStatement: {\n                var _b = node, thenStatement = _b.thenStatement, elseStatement = _b.elseStatement;\n                return worse(getSuperForNode(thenStatement), elseStatement !== undefined ? getSuperForNode(elseStatement) : 0 /* NoSuper */);\n            }\n            case ts.SyntaxKind.SwitchStatement:\n                return getSuperForSwitch(node);\n            default:\n                return combineSequentialChildren(node);\n        }\n    }\n    function getSuperForSwitch(node) {\n        // 'super()' from any clause. Used to track whether 'super()' happens in the switch at all.\n        var foundSingle;\n        // 'super()' from the previous clause if it did not 'break;'.\n        var fallthroughSingle;\n        for (var _i = 0, _a = node.caseBlock.clauses; _i < _a.length; _i++) {\n            var clause = _a[_i];\n            var clauseSuper = combineSequentialChildren(clause);\n            switch (clauseSuper) {\n                case 0 /* NoSuper */:\n                    break;\n                case 2 /* Break */:\n                    fallthroughSingle = undefined;\n                    break;\n                case 1 /* Return */:\n                    return 0 /* NoSuper */;\n                default:\n                    if (fallthroughSingle !== undefined) {\n                        addDuplicateFailure(fallthroughSingle, clauseSuper.node);\n                    }\n                    if (!clauseSuper.break) {\n                        fallthroughSingle = clauseSuper.node;\n                    }\n                    foundSingle = clauseSuper.node;\n            }\n        }\n        return foundSingle !== undefined ? { node: foundSingle, break: false } : 0 /* NoSuper */;\n    }\n    /**\n     * Combines children that come one after another.\n     * (As opposed to if/else, switch, or loops, which need their own handling.)\n     */\n    function combineSequentialChildren(node) {\n        var seenSingle;\n        var res = ts.forEachChild(node, function (child) {\n            var childSuper = getSuperForNode(child);\n            switch (childSuper) {\n                case 0 /* NoSuper */:\n                    return undefined;\n                case 2 /* Break */:\n                    if (seenSingle !== undefined) {\n                        return tslib_1.__assign({}, seenSingle, { break: true });\n                    }\n                    return childSuper;\n                case 1 /* Return */:\n                    return childSuper;\n                default:\n                    if (seenSingle !== undefined && !seenSingle.break) {\n                        addDuplicateFailure(seenSingle.node, childSuper.node);\n                    }\n                    seenSingle = childSuper;\n                    return undefined;\n            }\n        });\n        return res !== undefined ? res : seenSingle !== undefined ? seenSingle : 0 /* NoSuper */;\n    }\n    function addDuplicateFailure(a, b) {\n        ctx.addFailure(a.getStart(), b.end, Rule.FAILURE_STRING_DUPLICATE);\n    }\n}\n// If/else run separately, so return the branch more likely to result in eventual errors.\nfunction worse(a, b) {\n    return typeof a === \"number\"\n        ? typeof b === \"number\" ? (a < b ? b : a) : b\n        : typeof b === \"number\" ? a : a.break ? b : a;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/noDuplicateSuperRule.js\n// module id = 2057\n// module chunks = 101"],"sourceRoot":""}