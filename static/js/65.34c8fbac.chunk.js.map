{"version":3,"sources":["../node_modules/tslint/lib/rules/noUnboundMethodRule.js"],"names":["Object","defineProperty","exports","value","templateObject_1","tslib_1","__webpack_require__","tsutils_1","ts","Lint","Rule","_super","apply","this","arguments","__extends","prototype","applyWithProgram","sourceFile","program","applyWithFunction","walk","ignoreStatic","ruleArguments","indexOf","getTypeChecker","metadata","ruleName","description","optionsDescription","options","type","enum","optionExamples","rationale","Utils","dedent","__makeTemplateObject","typescriptOnly","requiresTypeInfo","FAILURE_STRING","Rules","TypedRule","ctx","tc","forEachChild","cb","node","isPropertyAccessExpression","isSafeUse","parent","kind","SyntaxKind","CallExpression","expression","TaggedTemplateExpression","tag","PropertyAccessExpression","ElementAccessExpression","BinaryExpression","operatorToken","BarBarToken","NonNullExpression","AsExpression","TypeAssertionExpression","ParenthesizedExpression","ConditionalExpression","condition","IfStatement","WhileStatement","DoStatement","ForStatement","PrefixUnaryExpression","symbol","getSymbolAtLocation","declaration","undefined","valueDeclaration","MethodDeclaration","MethodSignature","hasModifier","modifiers","StaticKeyword","isMethod","addFailureAtNode"],"mappings":"qDAiBAA,OAAAC,eAAAC,EAAA,cAA8CC,OAAA,IAC9C,IAwFAC,EAxFAC,EAAAC,EAAA,GACAC,EAAAD,EAAA,KACAE,EAAAF,EAAA,IACAG,EAAAH,EAAA,MAEAI,EAAA,SAAAC,GAEA,SAAAD,IACA,cAAAC,KAAAC,MAAAC,KAAAC,YAAAD,KAwBA,OA1BAR,EAAAU,UAAAL,EAAAC,GAIAD,EAAAM,UAAAC,iBAAA,SAAAC,EAAAC,GACA,OAAAN,KAAAO,kBAAAF,EAAAG,GACAC,cAAA,IAAAT,KAAAU,cAAAC,QARA,kBASSL,EAAAM,mBAGTf,EAAAgB,UACAC,SAAA,oBACAC,YAAA,wDACAC,mBAAA,oEACAC,SACAC,KAAA,SACAC,MAlBA,kBAoBAC,iBAAA,MApBA,kBAqBAC,UAAAzB,EAAA0B,MAAAC,OAAAhC,MAAAC,EAAAgC,sBAAA,6oCAAytC,mrCACztCN,KAAA,gBACAO,gBAAA,EACAC,kBAAA,GAGA7B,EAAA8B,eAAA,qFACA9B,EA3BA,CA4BCD,EAAAgC,MAAAC,WAED,SAAArB,EAAAsB,EAAAC,GACA,OAAApC,EAAAqC,aAAAF,EAAAzB,WAAA,SAAA4B,EAAAC,GACA,GAAAxC,EAAAyC,2BAAAD,KAmBA,SAAAE,EAAAF,GACA,IAAAG,EAAAH,EAAAG,OACA,OAAAA,EAAAC,MACA,KAAA3C,EAAA4C,WAAAC,eACA,OAAAH,EAAAI,aAAAP,EACA,KAAAvC,EAAA4C,WAAAG,yBACA,OAAAL,EAAAM,MAAAT,EAEA,KAAAvC,EAAA4C,WAAAK,yBACA,KAAAjD,EAAA4C,WAAAM,wBACA,SAEA,KAAAlD,EAAA4C,WAAAO,iBACA,OAAAT,EAAAU,cAAAT,OAAA3C,EAAA4C,WAAAS,YACA,KAAArD,EAAA4C,WAAAU,kBACA,KAAAtD,EAAA4C,WAAAW,aACA,KAAAvD,EAAA4C,WAAAY,wBACA,KAAAxD,EAAA4C,WAAAa,wBACA,OAAAhB,EAAAC,GAEA,KAAA1C,EAAA4C,WAAAc,sBACA,OAAAhB,EAAAiB,YAAApB,EACA,KAAAvC,EAAA4C,WAAAgB,YACA,KAAA5D,EAAA4C,WAAAiB,eACA,KAAA7D,EAAA4C,WAAAkB,YACA,KAAA9D,EAAA4C,WAAAmB,aACA,KAAA/D,EAAA4C,WAAAoB,sBACA,SACA,QACA,UAhDAvB,CAAAF,GAAA,CACA,IAAA0B,EAAA7B,EAAA8B,oBAAA3B,GACA4B,OAAAC,IAAAH,OAAAG,EAAAH,EAAAI,sBACAD,IAAAD,GAOA,SAAA5B,EAAAzB,GACA,OAAAyB,EAAAI,MACA,KAAA3C,EAAA4C,WAAA0B,kBACA,KAAAtE,EAAA4C,WAAA2B,gBACA,QAAAzD,GAAAf,EAAAyE,YAAAjC,EAAAkC,UAAAzE,EAAA4C,WAAA8B,gBACA,QACA,UAbAC,CAAAR,EAAAhC,EAAAb,QAAAR,eACAqB,EAAAyC,iBAAArC,EAAArC,EAAA8B,gBAGA,OAAAhC,EAAAqC,aAAAE,EAAAD,KAVA5C,EAAAQ","file":"static/js/65.34c8fbac.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_IGNORE_STATIC = \"ignore-static\";\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        return this.applyWithFunction(sourceFile, walk, {\n            ignoreStatic: this.ruleArguments.indexOf(OPTION_IGNORE_STATIC) !== -1,\n        }, program.getTypeChecker());\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"no-unbound-method\",\n        description: \"Warns when a method is used outside of a method call.\",\n        optionsDescription: \"You may optionally pass \\\"\" + OPTION_IGNORE_STATIC + \"\\\" to ignore static methods.\",\n        options: {\n            type: \"string\",\n            enum: [OPTION_IGNORE_STATIC],\n        },\n        optionExamples: [true, [true, OPTION_IGNORE_STATIC]],\n        rationale: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            Class functions don't preserve the class scope when passed as standalone variables.\\n            For example, this code will log the global scope (`window`/`global`), not the class instance:\\n\\n            ```\\n            class MyClass {\\n                public log(): void {\\n                    console.log(this);\\n                }\\n            }\\n\\n            const instance = new MyClass();\\n            const log = instance.log;\\n\\n            log();\\n            ```\\n\\n            You need to either use an arrow lambda (`() => {...}`) or call the function with the correct scope.\\n\\n            ```\\n            class MyClass {\\n                public logArrowBound = (): void => {\\n                    console.log(bound);\\n                };\\n\\n                public logManualBind(): void {\\n                    console.log(this);\\n                }\\n            }\\n\\n            const instance = new MyClass();\\n            const logArrowBound = instance.logArrowBound;\\n            const logManualBind = instance.logManualBind.bind(instance);\\n\\n            logArrowBound();\\n            logManualBind();\\n            ```\\n        \"], [\"\\n            Class functions don't preserve the class scope when passed as standalone variables.\\n            For example, this code will log the global scope (\\\\`window\\\\`/\\\\`global\\\\`), not the class instance:\\n\\n            \\\\`\\\\`\\\\`\\n            class MyClass {\\n                public log(): void {\\n                    console.log(this);\\n                }\\n            }\\n\\n            const instance = new MyClass();\\n            const log = instance.log;\\n\\n            log();\\n            \\\\`\\\\`\\\\`\\n\\n            You need to either use an arrow lambda (\\\\`() => {...}\\\\`) or call the function with the correct scope.\\n\\n            \\\\`\\\\`\\\\`\\n            class MyClass {\\n                public logArrowBound = (): void => {\\n                    console.log(bound);\\n                };\\n\\n                public logManualBind(): void {\\n                    console.log(this);\\n                }\\n            }\\n\\n            const instance = new MyClass();\\n            const logArrowBound = instance.logArrowBound;\\n            const logManualBind = instance.logManualBind.bind(instance);\\n\\n            logArrowBound();\\n            logManualBind();\\n            \\\\`\\\\`\\\\`\\n        \"]))),\n        type: \"functionality\",\n        typescriptOnly: true,\n        requiresTypeInfo: true,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = \"Avoid referencing unbound methods which may cause unintentional scoping of 'this'.\";\n    return Rule;\n}(Lint.Rules.TypedRule));\nexports.Rule = Rule;\nfunction walk(ctx, tc) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (tsutils_1.isPropertyAccessExpression(node) && !isSafeUse(node)) {\n            var symbol = tc.getSymbolAtLocation(node);\n            var declaration = symbol === undefined ? undefined : symbol.valueDeclaration;\n            if (declaration !== undefined && isMethod(declaration, ctx.options.ignoreStatic)) {\n                ctx.addFailureAtNode(node, Rule.FAILURE_STRING);\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\nfunction isMethod(node, ignoreStatic) {\n    switch (node.kind) {\n        case ts.SyntaxKind.MethodDeclaration:\n        case ts.SyntaxKind.MethodSignature:\n            return !(ignoreStatic && tsutils_1.hasModifier(node.modifiers, ts.SyntaxKind.StaticKeyword));\n        default:\n            return false;\n    }\n}\nfunction isSafeUse(node) {\n    var parent = node.parent;\n    switch (parent.kind) {\n        case ts.SyntaxKind.CallExpression:\n            return parent.expression === node;\n        case ts.SyntaxKind.TaggedTemplateExpression:\n            return parent.tag === node;\n        // E.g. `obj.method.bind(obj) or obj.method[\"prop\"]`.\n        case ts.SyntaxKind.PropertyAccessExpression:\n        case ts.SyntaxKind.ElementAccessExpression:\n            return true;\n        // Allow most binary operators, but don't allow e.g. `myArray.forEach(obj.method || otherObj.otherMethod)`.\n        case ts.SyntaxKind.BinaryExpression:\n            return parent.operatorToken.kind !== ts.SyntaxKind.BarBarToken;\n        case ts.SyntaxKind.NonNullExpression:\n        case ts.SyntaxKind.AsExpression:\n        case ts.SyntaxKind.TypeAssertionExpression:\n        case ts.SyntaxKind.ParenthesizedExpression:\n            return isSafeUse(parent);\n        // Allow use in conditions\n        case ts.SyntaxKind.ConditionalExpression:\n            return parent.condition === node;\n        case ts.SyntaxKind.IfStatement:\n        case ts.SyntaxKind.WhileStatement:\n        case ts.SyntaxKind.DoStatement:\n        case ts.SyntaxKind.ForStatement:\n        case ts.SyntaxKind.PrefixUnaryExpression:\n            return true;\n        default:\n            return false;\n    }\n}\nvar templateObject_1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/noUnboundMethodRule.js\n// module id = 2096\n// module chunks = 65"],"sourceRoot":""}