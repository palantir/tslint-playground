{"version":3,"sources":["../node_modules/tslint/lib/rules/noUnnecessaryTypeAssertionRule.js"],"names":["Object","defineProperty","exports","value","tslib_1","__webpack_require__","tsutils_1","ts","Lint","Rule","_super","apply","this","arguments","__extends","prototype","applyWithProgram","sourceFile","program","applyWithWalker","Walker","ruleName","ruleArguments","getTypeChecker","metadata","description","options","type","listType","items","optionsDescription","hasFix","typescriptOnly","requiresTypeInfo","FAILURE_STRING","Rules","TypedRule","checker","_this","call","walk","cb","node","kind","SyntaxKind","NonNullExpression","checkNonNullAssertion","TypeAssertionExpression","AsExpression","verifyCast","forEachChild","getTypeAtLocation","expression","getNonNullableType","addFailureAtNode","Replacement","deleteFromTo","end","indexOf","getText","castType","isTypeFlagSet","TypeFlags","Literal","isObjectType","isObjectFlagSet","ObjectFlags","Tuple","properties","getProperties","length","i","name","String","couldBeTupleType","getStart","AbstractWalker"],"mappings":"qDAiBAA,OAAAC,eAAAC,EAAA,cAA8CC,OAAA,IAC9C,IAAAC,EAAAC,EAAA,GACAC,EAAAD,EAAA,KACAE,EAAAF,EAAA,IACAG,EAAAH,EAAA,MACAI,EAAA,SAAAC,GAEA,SAAAD,IACA,cAAAC,KAAAC,MAAAC,KAAAC,YAAAD,KAwBA,OA1BAR,EAAAU,UAAAL,EAAAC,GAIAD,EAAAM,UAAAC,iBAAA,SAAAC,EAAAC,GACA,OAAAN,KAAAO,gBAAA,IAAAC,EAAAH,EAAAL,KAAAS,SAAAT,KAAAU,cAAAJ,EAAAK,oBAGAd,EAAAe,UACAH,SAAA,gCACAI,YAAA,uEACAC,SACAC,KAAA,OACAC,UACAD,KAAA,QACAE,OAAwBF,KAAA,YAGxBG,mBAAA,kDACAH,KAAA,aACAI,QAAA,EACAC,gBAAA,EACAC,kBAAA,GAGAxB,EAAAyB,eAAA,qFACAzB,EA3BA,CA4BCD,EAAA2B,MAAAC,WACDlC,EAAAO,OACA,IAAAW,EAAA,SAAAV,GAEA,SAAAU,EAAAH,EAAAI,EAAAK,EAAAW,GACA,IAAAC,EAAA5B,EAAA6B,KAAA3B,KAAAK,EAAAI,EAAAK,IAAAd,KAEA,OADA0B,EAAAD,UACAC,EA0CA,OA9CAlC,EAAAU,UAAAM,EAAAV,GAMAU,EAAAL,UAAAyB,KAAA,SAAAvB,GACA,IAAAqB,EAAA1B,KACA6B,EAAA,SAAAC,GACA,OAAAA,EAAAC,MACA,KAAApC,EAAAqC,WAAAC,kBACAP,EAAAQ,sBAAAJ,GACA,MACA,KAAAnC,EAAAqC,WAAAG,wBACA,KAAAxC,EAAAqC,WAAAI,aACAV,EAAAW,WAAAP,GAEA,OAAAnC,EAAA2C,aAAAR,EAAAD,IAEA,OAAAlC,EAAA2C,aAAAjC,EAAAwB,IAEArB,EAAAL,UAAA+B,sBAAA,SAAAJ,GACA,IAAAf,EAAAf,KAAAyB,QAAAc,kBAAAT,EAAAU,YACAzB,IAAAf,KAAAyB,QAAAgB,mBAAA1B,IACAf,KAAA0C,iBAAAZ,EAAAjC,EAAAyB,eAAA1B,EAAA+C,YAAAC,aAAAd,EAAAU,WAAAK,IAAAf,EAAAe,OAGArC,EAAAL,UAAAkC,WAAA,SAAAP,GACA,QAAA9B,KAAAc,QAAAgC,QAAAhB,EAAAf,KAAAgC,QAAA/C,KAAAK,aAAA,CAGA,IAAA2C,EAAAhD,KAAAyB,QAAAc,kBAAAT,GACA,KAAApC,EAAAuD,cAAAD,EAAArD,EAAAuD,UAAAC,UACAzD,EAAA0D,aAAAJ,KACAtD,EAAA2D,gBAAAL,EAAArD,EAAA2D,YAAAC,QAkBA,SAAAxC,GACA,IAAAyC,EAAAzC,EAAA0C,gBACA,OAAAD,EAAAE,OACA,SAGA,IADA,IAAAC,EAAA,EACUA,EAAAH,EAAAE,SAAuBC,EAAA,CACjC,IAAAC,EAAAJ,EAAAG,GAAAC,KACA,GAAAC,OAAAF,KAAAC,EAAA,CACA,OAAAD,EAEA,SAEA,OAGA,KAAUA,EAAAH,EAAAE,SAAuBC,EACjC,GAAAE,QAAAL,EAAAG,GAAAC,QAAAJ,EAAAG,GAAAC,KACA,SAGA,SAvCAE,CAAAd,KAKAhD,KAAAyB,QAAAc,kBAAAT,EAAAU,cACAQ,GACAhD,KAAA0C,iBAAAZ,EAAAjC,EAAAyB,eAAAQ,EAAAC,OAAApC,EAAAqC,WAAAG,wBACAvC,EAAA+C,YAAAC,aAAAd,EAAAiC,WAAAjC,EAAAU,WAAAuB,YACAnE,EAAA+C,YAAAC,aAAAd,EAAAU,WAAAK,IAAAf,EAAAe,QAGArC,EA/CA,CAgDCZ,EAAAoE","file":"static/js/70.9693a356.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2018 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        return this.applyWithWalker(new Walker(sourceFile, this.ruleName, this.ruleArguments, program.getTypeChecker()));\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"no-unnecessary-type-assertion\",\n        description: \"Warns if a type assertion does not change the type of an expression.\",\n        options: {\n            type: \"list\",\n            listType: {\n                type: \"array\",\n                items: { type: \"string\" },\n            },\n        },\n        optionsDescription: \"A list of whitelisted assertion types to ignore\",\n        type: \"typescript\",\n        hasFix: true,\n        typescriptOnly: true,\n        requiresTypeInfo: true,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = \"This assertion is unnecessary since it does not change the type of the expression.\";\n    return Rule;\n}(Lint.Rules.TypedRule));\nexports.Rule = Rule;\nvar Walker = /** @class */ (function (_super) {\n    tslib_1.__extends(Walker, _super);\n    function Walker(sourceFile, ruleName, options, checker) {\n        var _this = _super.call(this, sourceFile, ruleName, options) || this;\n        _this.checker = checker;\n        return _this;\n    }\n    Walker.prototype.walk = function (sourceFile) {\n        var _this = this;\n        var cb = function (node) {\n            switch (node.kind) {\n                case ts.SyntaxKind.NonNullExpression:\n                    _this.checkNonNullAssertion(node);\n                    break;\n                case ts.SyntaxKind.TypeAssertionExpression:\n                case ts.SyntaxKind.AsExpression:\n                    _this.verifyCast(node);\n            }\n            return ts.forEachChild(node, cb);\n        };\n        return ts.forEachChild(sourceFile, cb);\n    };\n    Walker.prototype.checkNonNullAssertion = function (node) {\n        var type = this.checker.getTypeAtLocation(node.expression);\n        if (type === this.checker.getNonNullableType(type)) {\n            this.addFailureAtNode(node, Rule.FAILURE_STRING, Lint.Replacement.deleteFromTo(node.expression.end, node.end));\n        }\n    };\n    Walker.prototype.verifyCast = function (node) {\n        if (this.options.indexOf(node.type.getText(this.sourceFile)) !== -1) {\n            return;\n        }\n        var castType = this.checker.getTypeAtLocation(node);\n        if (tsutils_1.isTypeFlagSet(castType, ts.TypeFlags.Literal) ||\n            (tsutils_1.isObjectType(castType) &&\n                (tsutils_1.isObjectFlagSet(castType, ts.ObjectFlags.Tuple) || couldBeTupleType(castType)))) {\n            // It's not always safe to remove a cast to a literal type or tuple\n            // type, as those types are sometimes widened without the cast.\n            return;\n        }\n        var uncastType = this.checker.getTypeAtLocation(node.expression);\n        if (uncastType === castType) {\n            this.addFailureAtNode(node, Rule.FAILURE_STRING, node.kind === ts.SyntaxKind.TypeAssertionExpression\n                ? Lint.Replacement.deleteFromTo(node.getStart(), node.expression.getStart())\n                : Lint.Replacement.deleteFromTo(node.expression.end, node.end));\n        }\n    };\n    return Walker;\n}(Lint.AbstractWalker));\n/**\n * Sometimes tuple types don't have ObjectFlags.Tuple set, like when they're being matched against an inferred type.\n * So, in addition, check if there are integer properties 0..n and no other numeric keys\n */\nfunction couldBeTupleType(type) {\n    var properties = type.getProperties();\n    if (properties.length === 0) {\n        return false;\n    }\n    var i = 0;\n    for (; i < properties.length; ++i) {\n        var name = properties[i].name;\n        if (String(i) !== name) {\n            if (i === 0) {\n                // if there are no integer properties, this is not a tuple\n                return false;\n            }\n            break;\n        }\n    }\n    for (; i < properties.length; ++i) {\n        if (String(+properties[i].name) === properties[i].name) {\n            return false; // if there are any other numeric properties, this is not a tuple\n        }\n    }\n    return true;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/noUnnecessaryTypeAssertionRule.js\n// module id = 2107\n// module chunks = 70"],"sourceRoot":""}