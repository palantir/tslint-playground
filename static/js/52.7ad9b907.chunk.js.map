{"version":3,"sources":["../node_modules/tslint/lib/rules/preferObjectSpreadRule.js"],"names":["Object","defineProperty","exports","value","tslib_1","__webpack_require__","tsutils_1","ts","Lint","Rule","_super","apply","this","arguments","__extends","prototype","sourceFile","applyWithFunction","walk","metadata","ruleName","description","rationale","optionsDescription","options","optionExamples","type","typescriptOnly","hasFix","FAILURE_STRING","ASSIGNMENT_FAILURE_STRING","Rules","AbstractRule","ctx","forEachChild","cb","node","isCallExpression","length","isPropertyAccessExpression","expression","name","text","isIdentifier","isFunctionLike","some","isSpreadElement","isThisKeyword","kind","SyntaxKind","ObjectLiteralExpression","addFailureAtNode","createFix","isExpressionValueUsed","hasSideEffects","args","objectNeedsParens","parent","ArrowFunction","fix","Replacement","replaceFromTo","getStart","end","i","arg","isObjectLiteralExpression","properties","hasTrailingComma","push","deleteFromTo","deleteText","parens","needsParens","appendText","ThisKeyword","ConditionalExpression","BinaryExpression"],"mappings":"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","file":"static/js/52.7ad9b907.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"prefer-object-spread\",\n        description: \"Enforces the use of the ES2018 object spread operator over `Object.assign()` where appropriate.\",\n        rationale: \"Object spread allows for better type checking and inference.\",\n        optionsDescription: \"Not configurable.\",\n        options: null,\n        optionExamples: [true],\n        type: \"functionality\",\n        typescriptOnly: false,\n        hasFix: true,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = \"Use the object spread operator instead.\";\n    Rule.ASSIGNMENT_FAILURE_STRING = \"'Object.assign' returns the first argument. Prefer object spread if you want a new object.\";\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (tsutils_1.isCallExpression(node) &&\n            node.arguments.length !== 0 &&\n            tsutils_1.isPropertyAccessExpression(node.expression) &&\n            node.expression.name.text === \"assign\" &&\n            tsutils_1.isIdentifier(node.expression.expression) &&\n            node.expression.expression.text === \"Object\" &&\n            !ts.isFunctionLike(node.arguments[0]) &&\n            // Object.assign(...someArray) cannot be written as object spread\n            !node.arguments.some(tsutils_1.isSpreadElement) &&\n            /**\n             * @TODO\n             * Remove !node.arguments.some(isThisKeyword) when typescript get's\n             * support for spread types.\n             * PR: https://github.com/Microsoft/TypeScript/issues/10727\n             */\n            !node.arguments.some(isThisKeyword)) {\n            if (node.arguments[0].kind === ts.SyntaxKind.ObjectLiteralExpression) {\n                ctx.addFailureAtNode(node, Rule.FAILURE_STRING, createFix(node, ctx.sourceFile));\n            }\n            else if (tsutils_1.isExpressionValueUsed(node) &&\n                !tsutils_1.hasSideEffects(node.arguments[0], 2 /* Constructor */)) {\n                ctx.addFailureAtNode(node, Rule.ASSIGNMENT_FAILURE_STRING, createFix(node, ctx.sourceFile));\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\nfunction createFix(node, sourceFile) {\n    var args = node.arguments;\n    var objectNeedsParens = node.parent.kind === ts.SyntaxKind.ArrowFunction;\n    var fix = [\n        Lint.Replacement.replaceFromTo(node.getStart(sourceFile), args[0].getStart(sourceFile), (objectNeedsParens ? \"(\" : \"\") + \"{\"),\n        new Lint.Replacement(node.end - 1, 1, \"}\" + (objectNeedsParens ? \")\" : \"\")),\n    ];\n    for (var i = 0; i < args.length; ++i) {\n        var arg = args[i];\n        if (tsutils_1.isObjectLiteralExpression(arg)) {\n            if (arg.properties.length === 0) {\n                var end = arg.end;\n                if (i !== args.length - 1) {\n                    end = args[i + 1].getStart(sourceFile);\n                }\n                else if (args.hasTrailingComma) {\n                    end = args.end;\n                }\n                // remove empty object iteral and the following comma if exists\n                fix.push(Lint.Replacement.deleteFromTo(arg.getStart(sourceFile), end));\n            }\n            else {\n                fix.push(\n                // remove open brace\n                Lint.Replacement.deleteText(arg.getStart(sourceFile), 1), \n                // remove trailing comma if exists and close brace\n                Lint.Replacement.deleteFromTo(arg.properties[arg.properties.length - 1].end, arg.end));\n            }\n        }\n        else {\n            var parens = needsParens(arg);\n            fix.push(Lint.Replacement.appendText(arg.getStart(sourceFile), parens ? \"...(\" : \"...\"));\n            if (parens) {\n                fix.push(Lint.Replacement.appendText(arg.end, \")\"));\n            }\n        }\n    }\n    return fix;\n}\nfunction isThisKeyword(node) {\n    return node.kind === ts.SyntaxKind.ThisKeyword;\n}\nfunction needsParens(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.ConditionalExpression:\n        case ts.SyntaxKind.BinaryExpression:\n            return true;\n        default:\n            return false;\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/preferObjectSpreadRule.js\n// module id = 2129\n// module chunks = 52"],"sourceRoot":""}