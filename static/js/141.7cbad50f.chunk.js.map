{"version":3,"sources":["../node_modules/tslint/lib/rules/fileHeaderRule.js"],"names":["Object","defineProperty","exports","value","templateObject_1","tslib_1","__webpack_require__","ts","Lint","Rule","_super","apply","this","arguments","__extends","prototype","sourceFile","text","headerFormat","RegExp","ruleArguments","textToInsert","enforceExtraTrailingLine","indexOf","offset","startsWith","commentText","forEachLeadingCommentRange","pos","end","kind","substring","SyntaxKind","SingleLineCommentTrivia","undefined","test","isErrorAtStart","leadingNewlines","trailingNewlines","fix","Replacement","appendText","createComment","RuleFailure","MISSING_HEADER_FAILURE_STRING","ruleName","doesNewLineEndingViolationExist","endOfComment","getTrailingCommentRanges","lineEnding","generateLineEnding","MISSING_NEW_LINE_FAILURE_STRING","repeat","concat","split","map","line","replace","join","getLineEndOfPosition","entireComment","metadata","description","optionsDescription","Utils","dedent","__makeTemplateObject","options","type","items","additionalItems","minLength","maxLength","optionExamples","hasFix","typescriptOnly","Rules","AbstractRule"],"mappings":"sDAiBAA,OAAAC,eAAAC,EAAA,cAA8CC,OAAA,IAC9C,IA0GAC,EA1GAC,EAAAC,EAAA,GACAC,EAAAD,EAAA,IACAE,EAAAF,EAAA,MAEAG,EAAA,SAAAC,GAEA,SAAAD,IACA,cAAAC,KAAAC,MAAAC,KAAAC,YAAAD,KAgGA,OAlGAP,EAAAS,UAAAL,EAAAC,GAIAD,EAAAM,UAAAJ,MAAA,SAAAK,GACA,IAAAC,EAAAD,EAAAC,KACAC,EAAA,IAAAC,OAAAP,KAAAQ,cAAA,IACAC,EAAAT,KAAAQ,cAAA,GACAE,GAAA,IAAAV,KAAAQ,cAAAG,QAVA,4BAYAC,EAAAP,EAAAQ,WAAA,MAAAR,EAAAM,QAAA,QAEAG,EAAAnB,EAAAoB,2BAAAV,EAAAO,EAAA,SAAAI,EAAAC,EAAAC,GACA,OAAAb,EAAAc,UAAAH,EAAA,EAAAE,IAAAvB,EAAAyB,WAAAC,wBAAAJ,IAAA,KAEA,QAAAK,IAAAR,IAAAR,EAAAiB,KAAAT,GAAA,CACA,IAAAU,EAAA,IAAAZ,EACAY,KACAZ,EAEA,IAAAa,EAAAD,EAAA,IACAE,EAAAF,EAAA,IACAG,OAAAL,IAAAb,EACAb,EAAAgC,YAAAC,WAAAjB,EAAAZ,KAAA8B,cAAA1B,EAAAK,EAAAgB,EAAAC,SACAJ,EACA,OACA,IAAA1B,EAAAmC,YAAA3B,EAAAQ,IAAAf,EAAAmC,8BAAAhC,KAAAiC,SAAAN,IAMA,GAHAjB,GACAJ,EAAAiB,KAAAT,IACAd,KAAAkC,gCAAA7B,EAAAO,GACA,CACA,IACAuB,EADAxC,EAAAyC,yBAAA/B,EAAAO,GACA,GAAAK,IACAoB,EAAArC,KAAAsC,mBAAAlC,GACAuB,OAAAL,IAAAb,EACAb,EAAAgC,YAAAC,WAAAM,EAAAE,QACAf,EACA,OACA,IAAA1B,EAAAmC,YAAA3B,EAAAQ,IAAAf,EAAA0C,gCAAAvC,KAAAiC,SAAAN,IAGA,UAEA9B,EAAAM,UAAA2B,cAAA,SAAA1B,EAAAU,EAAAW,EAAAC,QACA,IAAAD,IAAyCA,EAAA,QACzC,IAAAC,IAA0CA,EAAA,GAC1C,IAAAW,EAAArC,KAAAsC,mBAAAlC,GACA,OAAAiC,EAAAG,OAAAf,IAEA,OACAgB,OAAA3B,EAAA4B,MAAA,UAAAC,IAAA,SAAAC,GAAsE,aAAAA,GAAAC,QAAA,cACtE,QACAC,KAAAT,GACAA,EAAAG,OAAAd,IAEA7B,EAAAM,UAAAmC,mBAAA,SAAAlC,GAEA,OADA,OAAAA,EAAAC,KAAAD,EAAA2C,qBAAA,aACA,MAEAlD,EAAAM,UAAA+B,gCAAA,SAAA7B,EAAAO,GACA,IAAAoC,EAAArD,EAAAoB,2BAAAV,EAAAO,EAAA,SAAAI,EAAAC,GACA,OAAAZ,EAAAc,UAAAH,EAAAC,EAAA,KAGA,YAAAK,IAAA0B,GAAA,OADA,sBACAzB,KAAAyB,IAGAnD,EAAAoD,UACAhB,SAAA,cACAiB,YAAA,oFACAC,mBAAAvD,EAAAwD,MAAAC,OAAA7D,MAAAC,EAAA6D,sBAAA,44BACAC,SACAC,KAAA,QACAC,QAEAD,KAAA,WAGAA,KAAA,WAGAA,KAAA,WAGAE,iBAAA,EACAC,UAAA,EACAC,UAAA,GAEAC,kBAAA,qBAAiD,iBA5FjD,6BA6FAC,QAAA,EACAN,KAAA,QACAO,gBAAA,GAGAlE,EAAAmC,8BAAA,sBACAnC,EAAA0C,gCAAA,6CACA1C,EAnGA,CAoGCD,EAAAoE,MAAAC,cACD3E,EAAAO","file":"static/js/141.7cbad50f.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2018 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar ENFORCE_TRAILING_NEWLINE = \"enforce-trailing-newline\";\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var text = sourceFile.text;\n        var headerFormat = new RegExp(this.ruleArguments[0]);\n        var textToInsert = this.ruleArguments[1];\n        var enforceExtraTrailingLine = this.ruleArguments.indexOf(ENFORCE_TRAILING_NEWLINE) !== -1;\n        // ignore shebang if it exists\n        var offset = text.startsWith(\"#!\") ? text.indexOf(\"\\n\") : 0;\n        // returns the text of the first comment or undefined\n        var commentText = ts.forEachLeadingCommentRange(text, offset, function (pos, end, kind) {\n            return text.substring(pos + 2, kind === ts.SyntaxKind.SingleLineCommentTrivia ? end : end - 2);\n        });\n        if (commentText === undefined || !headerFormat.test(commentText)) {\n            var isErrorAtStart = offset === 0;\n            if (!isErrorAtStart) {\n                ++offset; // show warning in next line after shebang\n            }\n            var leadingNewlines = isErrorAtStart ? 0 : 1;\n            var trailingNewlines = isErrorAtStart ? 2 : 1;\n            var fix = textToInsert !== undefined\n                ? Lint.Replacement.appendText(offset, this.createComment(sourceFile, textToInsert, leadingNewlines, trailingNewlines))\n                : undefined;\n            return [\n                new Lint.RuleFailure(sourceFile, offset, offset, Rule.MISSING_HEADER_FAILURE_STRING, this.ruleName, fix),\n            ];\n        }\n        var trailingNewLineViolation = enforceExtraTrailingLine &&\n            headerFormat.test(commentText) &&\n            this.doesNewLineEndingViolationExist(text, offset);\n        if (trailingNewLineViolation) {\n            var trailingCommentRanges = ts.getTrailingCommentRanges(text, offset);\n            var endOfComment = trailingCommentRanges[0].end;\n            var lineEnding = this.generateLineEnding(sourceFile);\n            var fix = textToInsert !== undefined\n                ? Lint.Replacement.appendText(endOfComment, lineEnding)\n                : undefined;\n            return [\n                new Lint.RuleFailure(sourceFile, offset, offset, Rule.MISSING_NEW_LINE_FAILURE_STRING, this.ruleName, fix),\n            ];\n        }\n        return [];\n    };\n    Rule.prototype.createComment = function (sourceFile, commentText, leadingNewlines, trailingNewlines) {\n        if (leadingNewlines === void 0) { leadingNewlines = 1; }\n        if (trailingNewlines === void 0) { trailingNewlines = 1; }\n        var lineEnding = this.generateLineEnding(sourceFile);\n        return (lineEnding.repeat(leadingNewlines) +\n            [\n                \"/*!\"\n            ].concat(commentText.split(/\\r?\\n/g).map(function (line) { return (\" * \" + line).replace(/\\s+$/, \"\"); }), [\n                \" */\",\n            ]).join(lineEnding) +\n            lineEnding.repeat(trailingNewlines));\n    };\n    Rule.prototype.generateLineEnding = function (sourceFile) {\n        var maybeCarriageReturn = sourceFile.text[sourceFile.getLineEndOfPosition(0)] === \"\\r\" ? \"\\r\" : \"\";\n        return maybeCarriageReturn + \"\\n\";\n    };\n    Rule.prototype.doesNewLineEndingViolationExist = function (text, offset) {\n        var entireComment = ts.forEachLeadingCommentRange(text, offset, function (pos, end) {\n            return text.substring(pos, end + 2);\n        });\n        var NEW_LINE_FOLLOWING_HEADER = /^.*((\\r)?\\n){2,}$/gm;\n        return (entireComment !== undefined && NEW_LINE_FOLLOWING_HEADER.test(entireComment) !== null);\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"file-header\",\n        description: \"Enforces a certain header comment for all files, matched by a regular expression.\",\n        optionsDescription: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            The first option, which is mandatory, is a regular expression that all headers should match.\\n            The second argument, which is optional, is a string that should be inserted as a header comment\\n            if fixing is enabled and no header that matches the first argument is found.\\n            The third argument, which is optional, is a string that denotes whether or not a newline should\\n            exist on the header.\"], [\"\\n            The first option, which is mandatory, is a regular expression that all headers should match.\\n            The second argument, which is optional, is a string that should be inserted as a header comment\\n            if fixing is enabled and no header that matches the first argument is found.\\n            The third argument, which is optional, is a string that denotes whether or not a newline should\\n            exist on the header.\"]))),\n        options: {\n            type: \"array\",\n            items: [\n                {\n                    type: \"string\",\n                },\n                {\n                    type: \"string\",\n                },\n                {\n                    type: \"string\",\n                },\n            ],\n            additionalItems: false,\n            minLength: 1,\n            maxLength: 3,\n        },\n        optionExamples: [[true, \"Copyright \\\\d{4}\", \"Copyright 2018\", ENFORCE_TRAILING_NEWLINE]],\n        hasFix: true,\n        type: \"style\",\n        typescriptOnly: false,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.MISSING_HEADER_FAILURE_STRING = \"missing file header\";\n    Rule.MISSING_NEW_LINE_FAILURE_STRING = \"missing new line following the file header\";\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nvar templateObject_1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/fileHeaderRule.js\n// module id = 2029\n// module chunks = 141"],"sourceRoot":""}