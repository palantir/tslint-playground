{"version":3,"sources":["../node_modules/tslint/lib/rules/alignRule.js"],"names":["Object","defineProperty","exports","value","tslib_1","__webpack_require__","tsutils_1","ts","Lint","Rule","_super","apply","this","arguments","__extends","prototype","sourceFile","applyWithWalker","AlignWalker","ruleName","ruleArguments","indexOf","elements","members","parameters","statements","metadata","description","hasFix","rationale","Utils","dedent","templateObject_1","__makeTemplateObject","optionsDescription","templateObject_2","options","type","items","enum","minLength","maxLength","optionExamples","typescriptOnly","FAILURE_STRING_SUFFIX","Rules","AbstractRule","walk","_this","cb","node","isBlockLike","checkAlignment","filter","s","kind","SyntaxKind","EmptyStatement","NewExpression","undefined","CallExpression","FunctionDeclaration","FunctionExpression","Constructor","MethodDeclaration","ArrowFunction","CallSignature","ConstructSignature","MethodSignature","FunctionType","ConstructorType","ArrayLiteralExpression","ArrayBindingPattern","TupleType","elementTypes","ObjectLiteralExpression","properties","ObjectBindingPattern","ClassDeclaration","ClassExpression","m","SemicolonClassElement","InterfaceDeclaration","TypeLiteral","forEachChild","nodes","length","pos","result","getLineAndCharacterOfPosition","line","text","character","getLineAndCharacterWithoutBom","getStart","alignToColumn","i","start","diff","fix","Replacement","appendText","repeat","test","substring","deleteText","addFailure","Math","max","end","OmittedExpression","getNextToken","AbstractWalker"],"mappings":"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","file":"static/js/156.4d519f38.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_STATEMENTS = \"statements\";\nvar OPTION_MEMBERS = \"members\";\nvar OPTION_ELEMENTS = \"elements\";\nvar OPTION_PARAMETERS = \"parameters\";\nvar OPTION_ARGUMENTS = \"arguments\";\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new AlignWalker(sourceFile, this.ruleName, {\n            arguments: this.ruleArguments.indexOf(OPTION_ARGUMENTS) !== -1,\n            elements: this.ruleArguments.indexOf(OPTION_ELEMENTS) !== -1,\n            members: this.ruleArguments.indexOf(OPTION_MEMBERS) !== -1,\n            parameters: this.ruleArguments.indexOf(OPTION_PARAMETERS) !== -1,\n            statements: this.ruleArguments.indexOf(OPTION_STATEMENTS) !== -1,\n        }));\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"align\",\n        description: \"Enforces vertical alignment.\",\n        hasFix: true,\n        rationale: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            Helps maintain a readable, consistent style in your codebase.\\n\\n            Consistent alignment for code statements helps keep code readable and clear.\\n            Statements misaligned from the standard can be harder to read and understand.\"], [\"\\n            Helps maintain a readable, consistent style in your codebase.\\n\\n            Consistent alignment for code statements helps keep code readable and clear.\\n            Statements misaligned from the standard can be harder to read and understand.\"]))),\n        optionsDescription: Lint.Utils.dedent(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject([\"\\n            Five arguments may be optionally provided:\\n\\n            * `\\\"\", \"\\\"` checks alignment of function parameters.\\n            * `\\\"\", \"\\\"` checks alignment of function call arguments.\\n            * `\\\"\", \"\\\"` checks alignment of statements.\\n            * `\\\"\", \"\\\"` checks alignment of members of classes, interfaces, type literal, object literals and\\n            object destructuring.\\n            * `\\\"\", \"\\\"` checks alignment of elements of array literals, array destructuring and tuple types.\"], [\"\\n            Five arguments may be optionally provided:\\n\\n            * \\\\`\\\"\", \"\\\"\\\\` checks alignment of function parameters.\\n            * \\\\`\\\"\", \"\\\"\\\\` checks alignment of function call arguments.\\n            * \\\\`\\\"\", \"\\\"\\\\` checks alignment of statements.\\n            * \\\\`\\\"\", \"\\\"\\\\` checks alignment of members of classes, interfaces, type literal, object literals and\\n            object destructuring.\\n            * \\\\`\\\"\", \"\\\"\\\\` checks alignment of elements of array literals, array destructuring and tuple types.\"])), OPTION_PARAMETERS, OPTION_ARGUMENTS, OPTION_STATEMENTS, OPTION_MEMBERS, OPTION_ELEMENTS),\n        options: {\n            type: \"array\",\n            items: {\n                type: \"string\",\n                enum: [\n                    OPTION_ARGUMENTS,\n                    OPTION_ELEMENTS,\n                    OPTION_MEMBERS,\n                    OPTION_PARAMETERS,\n                    OPTION_STATEMENTS,\n                ],\n            },\n            minLength: 1,\n            maxLength: 5,\n        },\n        optionExamples: [[true, \"parameters\", \"statements\"]],\n        type: \"style\",\n        typescriptOnly: false,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING_SUFFIX = \" are not aligned\";\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nvar AlignWalker = /** @class */ (function (_super) {\n    tslib_1.__extends(AlignWalker, _super);\n    function AlignWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AlignWalker.prototype.walk = function (sourceFile) {\n        var _this = this;\n        var cb = function (node) {\n            if (_this.options.statements && tsutils_1.isBlockLike(node)) {\n                _this.checkAlignment(node.statements.filter(function (s) { return s.kind !== ts.SyntaxKind.EmptyStatement; }), OPTION_STATEMENTS);\n            }\n            else {\n                switch (node.kind) {\n                    case ts.SyntaxKind.NewExpression:\n                        if (node.arguments === undefined) {\n                            break;\n                        }\n                    // falls through\n                    case ts.SyntaxKind.CallExpression:\n                        if (_this.options.arguments) {\n                            _this.checkAlignment(node.arguments, OPTION_ARGUMENTS);\n                        }\n                        break;\n                    case ts.SyntaxKind.FunctionDeclaration:\n                    case ts.SyntaxKind.FunctionExpression:\n                    case ts.SyntaxKind.Constructor:\n                    case ts.SyntaxKind.MethodDeclaration:\n                    case ts.SyntaxKind.ArrowFunction:\n                    case ts.SyntaxKind.CallSignature:\n                    case ts.SyntaxKind.ConstructSignature:\n                    case ts.SyntaxKind.MethodSignature:\n                    case ts.SyntaxKind.FunctionType:\n                    case ts.SyntaxKind.ConstructorType:\n                        if (_this.options.parameters) {\n                            _this.checkAlignment(node.parameters, OPTION_PARAMETERS);\n                        }\n                        break;\n                    case ts.SyntaxKind.ArrayLiteralExpression:\n                    case ts.SyntaxKind.ArrayBindingPattern:\n                        if (_this.options.elements) {\n                            _this.checkAlignment(node.elements, OPTION_ELEMENTS);\n                        }\n                        break;\n                    case ts.SyntaxKind.TupleType:\n                        if (_this.options.elements) {\n                            _this.checkAlignment(node.elementTypes, OPTION_ELEMENTS);\n                        }\n                        break;\n                    case ts.SyntaxKind.ObjectLiteralExpression:\n                        if (_this.options.members) {\n                            _this.checkAlignment(node.properties, OPTION_MEMBERS);\n                        }\n                        break;\n                    case ts.SyntaxKind.ObjectBindingPattern:\n                        if (_this.options.members) {\n                            _this.checkAlignment(node.elements, OPTION_MEMBERS);\n                        }\n                        break;\n                    case ts.SyntaxKind.ClassDeclaration:\n                    case ts.SyntaxKind.ClassExpression:\n                        if (_this.options.members) {\n                            _this.checkAlignment(node.members.filter(function (m) { return m.kind !== ts.SyntaxKind.SemicolonClassElement; }), OPTION_MEMBERS);\n                        }\n                        break;\n                    case ts.SyntaxKind.InterfaceDeclaration:\n                    case ts.SyntaxKind.TypeLiteral:\n                        if (_this.options.members) {\n                            _this.checkAlignment(node.members, OPTION_MEMBERS);\n                        }\n                }\n            }\n            return ts.forEachChild(node, cb);\n        };\n        return cb(sourceFile);\n    };\n    AlignWalker.prototype.checkAlignment = function (nodes, kind) {\n        if (nodes.length <= 1) {\n            return;\n        }\n        var sourceFile = this.sourceFile;\n        var pos = getLineAndCharacterWithoutBom(sourceFile, this.getStart(nodes[0]));\n        var alignToColumn = pos.character;\n        var line = pos.line;\n        // skip first node in list\n        for (var i = 1; i < nodes.length; ++i) {\n            var node = nodes[i];\n            var start = this.getStart(node);\n            pos = ts.getLineAndCharacterOfPosition(sourceFile, start);\n            if (line !== pos.line && pos.character !== alignToColumn) {\n                var diff = alignToColumn - pos.character;\n                var fix = void 0;\n                if (diff >= 0) {\n                    fix = Lint.Replacement.appendText(start, \" \".repeat(diff));\n                }\n                else if (node.pos <= start + diff &&\n                    /^\\s+$/.test(sourceFile.text.substring(start + diff, start))) {\n                    // only delete text if there is only whitespace\n                    fix = Lint.Replacement.deleteText(start + diff, -diff);\n                }\n                this.addFailure(start, Math.max(node.end, start), kind + Rule.FAILURE_STRING_SUFFIX, fix);\n            }\n            line = pos.line;\n        }\n    };\n    AlignWalker.prototype.getStart = function (node) {\n        return node.kind !== ts.SyntaxKind.OmittedExpression\n            ? node.getStart(this.sourceFile)\n            : // find the comma token following the OmmitedExpression\n                tsutils_1.getNextToken(node, this.sourceFile).getStart(this.sourceFile);\n    };\n    return AlignWalker;\n}(Lint.AbstractWalker));\nfunction getLineAndCharacterWithoutBom(sourceFile, pos) {\n    var result = ts.getLineAndCharacterOfPosition(sourceFile, pos);\n    if (result.line === 0 && sourceFile.text[0] === \"\\uFEFF\") {\n        result.character -= 1;\n    }\n    return result;\n}\nvar templateObject_1, templateObject_2;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/alignRule.js\n// module id = 2010\n// module chunks = 156"],"sourceRoot":""}