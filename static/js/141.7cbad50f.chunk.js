webpackJsonp([141],{2029:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var i,r=n(1),a=n(54),s=n(1116),o=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return r.__extends(t,e),t.prototype.apply=function(e){var n=e.text,i=new RegExp(this.ruleArguments[0]),r=this.ruleArguments[1],o=-1!==this.ruleArguments.indexOf("enforce-trailing-newline"),h=n.startsWith("#!")?n.indexOf("\n"):0,d=a.forEachLeadingCommentRange(n,h,function(e,t,i){return n.substring(e+2,i===a.SyntaxKind.SingleLineCommentTrivia?t:t-2)});if(void 0===d||!i.test(d)){var l=0===h;l||++h;var u=l?0:1,g=l?2:1,p=void 0!==r?s.Replacement.appendText(h,this.createComment(e,r,u,g)):void 0;return[new s.RuleFailure(e,h,h,t.MISSING_HEADER_FAILURE_STRING,this.ruleName,p)]}if(o&&i.test(d)&&this.doesNewLineEndingViolationExist(n,h)){var m=a.getTrailingCommentRanges(n,h)[0].end,c=this.generateLineEnding(e);p=void 0!==r?s.Replacement.appendText(m,c):void 0;return[new s.RuleFailure(e,h,h,t.MISSING_NEW_LINE_FAILURE_STRING,this.ruleName,p)]}return[]},t.prototype.createComment=function(e,t,n,i){void 0===n&&(n=1),void 0===i&&(i=1);var r=this.generateLineEnding(e);return r.repeat(n)+["/*!"].concat(t.split(/\r?\n/g).map(function(e){return(" * "+e).replace(/\s+$/,"")}),[" */"]).join(r)+r.repeat(i)},t.prototype.generateLineEnding=function(e){return("\r"===e.text[e.getLineEndOfPosition(0)]?"\r":"")+"\n"},t.prototype.doesNewLineEndingViolationExist=function(e,t){var n=a.forEachLeadingCommentRange(e,t,function(t,n){return e.substring(t,n+2)});return void 0!==n&&null!==/^.*((\r)?\n){2,}$/gm.test(n)},t.metadata={ruleName:"file-header",description:"Enforces a certain header comment for all files, matched by a regular expression.",optionsDescription:s.Utils.dedent(i||(i=r.__makeTemplateObject(["\n            The first option, which is mandatory, is a regular expression that all headers should match.\n            The second argument, which is optional, is a string that should be inserted as a header comment\n            if fixing is enabled and no header that matches the first argument is found.\n            The third argument, which is optional, is a string that denotes whether or not a newline should\n            exist on the header."],["\n            The first option, which is mandatory, is a regular expression that all headers should match.\n            The second argument, which is optional, is a string that should be inserted as a header comment\n            if fixing is enabled and no header that matches the first argument is found.\n            The third argument, which is optional, is a string that denotes whether or not a newline should\n            exist on the header."]))),options:{type:"array",items:[{type:"string"},{type:"string"},{type:"string"}],additionalItems:!1,minLength:1,maxLength:3},optionExamples:[[!0,"Copyright \\d{4}","Copyright 2018","enforce-trailing-newline"]],hasFix:!0,type:"style",typescriptOnly:!1},t.MISSING_HEADER_FAILURE_STRING="missing file header",t.MISSING_NEW_LINE_FAILURE_STRING="missing new line following the file header",t}(s.Rules.AbstractRule);t.Rule=o}});
//# sourceMappingURL=141.7cbad50f.chunk.js.map