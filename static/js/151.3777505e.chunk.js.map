{"version":3,"sources":["../node_modules/tslint/lib/rules/banRule.js"],"names":["Object","defineProperty","exports","value","tslib_1","__webpack_require__","tsutils_1","ts","Lint","Rule","_super","apply","this","arguments","__extends","FAILURE_STRING_FACTORY","expression","messageAddition","undefined","prototype","sourceFile","applyWithWalker","BanFunctionWalker","ruleName","args","functions","methods","_i","args_1","length","arg","push","name","Array","isArray","object","message","slice","parseOptions","ruleArguments","metadata","description","optionsDescription","Utils","dedent","templateObject_1","__makeTemplateObject","options","type","listType","anyOf","items","minLength","maxLength","properties","required","optionExamples","typescriptOnly","Rules","AbstractRule","walk","_this","cb","node","isCallExpression","isIdentifier","checkFunctionBan","isPropertyAccessExpression","checkForObjectMethodBan","forEachChild","_a","ban","text","current","i","addFailureAtNode","join","AbstractWalker"],"mappings":"sDACAA,OAAAC,eAAAC,EAAA,cAA8CC,OAAA,IAC9C,IAAAC,EAAAC,EAAA,GAiBAC,EAAAD,EAAA,KACAE,EAAAF,EAAA,IACAG,EAAAH,EAAA,MACAI,EAAA,SAAAC,GAEA,SAAAD,IACA,cAAAC,KAAAC,MAAAC,KAAAC,YAAAD,KAyDA,OA3DAR,EAAAU,UAAAL,EAAAC,GAKAD,EAAAM,uBAAA,SAAAC,EAAAC,GACA,mBAAAD,EAAA,2BAAAE,IAAAD,EAAA,IAAAA,EAAA,KAEAR,EAAAU,UAAAR,MAAA,SAAAS,GACA,OAAAR,KAAAS,gBAAA,IAAAC,EAAAF,EAAAR,KAAAW,SAqDA,SAAAC,GAGA,IAFA,IAAAC,KACAC,KACAC,EAAA,EAAAC,EAAAJ,EAAmCG,EAAAC,EAAAC,OAAoBF,IAAA,CACvD,IAAAG,EAAAF,EAAAD,GACA,qBAAAG,EACAL,EAAAM,MAA4BC,KAAAF,SAE5B,GAAAG,MAAAC,QAAAJ,GACA,OAAAA,EAAAD,QACA,OACA,MACA,OACAJ,EAAAM,MAAoCC,KAAAF,EAAA,KACpC,MACA,QACAJ,EAAAK,MAAkCI,QAAAL,EAAA,IAAAE,KAAAF,EAAA,GAAAM,QAAAN,EAAA,UAGlC,GAAAG,MAAAC,QAAAJ,EAAAE,MAIA,OAAAF,EAAAE,KAAAH,QACA,OACA,MACA,OACAJ,EAAAM,MAAoCC,KAAAF,EAAAE,KAAA,GAAAI,QAAAN,EAAAM,UACpC,MACA,QACAV,EAAAK,MACAK,QAAAN,EAAAM,QACAJ,KAAAF,EAAAE,KAAAF,EAAAE,KAAAH,OAAA,GACAM,OAAAL,EAAAE,KAAAK,MAAA,aAbAZ,EAAAM,KAAAD,GAkBA,OAAYL,YAAAC,WA3FZY,CAAA1B,KAAA2B,kBAGA9B,EAAA+B,UACAjB,SAAA,MACAkB,YAAA,wDACAC,mBAAAlC,EAAAmC,MAAAC,OAAAC,MAAAzC,EAAA0C,sBAAA,6/BAA+iC,mjCAC/iCC,SACAC,KAAA,OACAC,UACAC,QAEAF,KAAA,WAGAA,KAAA,QACAG,OAAgCH,KAAA,UAChCI,UAAA,EACAC,UAAA,IAGAL,KAAA,SACAM,YACAtB,MACAkB,QACqCF,KAAA,WACAA,KAAA,QAAAG,OAAwBH,KAAA,UAAiBI,UAAA,KAG9EhB,SAAsCY,KAAA,WAEtCO,UAAA,YAKAC,kBAEA,EACA,QACiBxB,KAAA,IAAAI,QAAA,iBACjB,oBACiBJ,MAAA,aAAAI,QAAA,sBACAJ,MAAA,yBAAAI,QAAA,+BACAJ,MAAA,eAAAI,QAAA,qCAGjBY,KAAA,gBACAS,gBAAA,GAEAhD,EA5DA,CA6DCD,EAAAkD,MAAAC,cACDzD,EAAAO,OAyCA,IAoDAoC,EApDAvB,EAAA,SAAAZ,GAEA,SAAAY,IACA,cAAAZ,KAAAC,MAAAC,KAAAC,YAAAD,KA+CA,OAjDAR,EAAAU,UAAAQ,EAAAZ,GAIAY,EAAAH,UAAAyC,KAAA,SAAAxC,GACA,IAAAyC,EAAAjD,KACAkD,EAAA,SAAAC,GASA,OARAzD,EAAA0D,iBAAAD,KACAzD,EAAA2D,aAAAF,EAAA/C,YACA6C,EAAAK,iBAAAH,EAAA/C,YAEAV,EAAA6D,2BAAAJ,EAAA/C,aACA6C,EAAAO,wBAAAL,EAAA/C,aAGAT,EAAA8D,aAAAN,EAAAD,IAEA,OAAAvD,EAAA8D,aAAAjD,EAAA0C,IAEAxC,EAAAH,UAAAiD,wBAAA,SAAApD,GACA,QAAAW,EAAA,EAAA2C,EAAA1D,KAAAmC,QAAArB,QAAmDC,EAAA2C,EAAAzC,OAAgBF,IAAA,CACnE,IAAA4C,EAAAD,EAAA3C,GACA,GAAAX,EAAAgB,KAAAwC,OAAAD,EAAAvC,KAAA,CAIA,IADA,IAAAyC,EAAAzD,aACA0D,EAAAH,EAAApC,OAAAN,OAAA,EAA+C6C,EAAA,IAAOA,EACtDpE,EAAA6D,2BAAAM,MAAAzC,KAAAwC,OAAAD,EAAApC,OAAAuC,KAGAD,IAAAzD,YAEA,SAAAuD,EAAApC,OAAA,IACA7B,EAAA2D,aAAAQ,MAAAD,OAAAD,EAAApC,OAAA,IACAvB,KAAA+D,iBAAA3D,EAAAP,EAAAM,uBAAAwD,EAAApC,OAAAyC,KAAA,SAAAL,EAAAvC,KAAAuC,EAAAnC,UACA,UAIAd,EAAAH,UAAA+C,iBAAA,SAAAlC,GAEA,IADA,IAAAwC,EAAAxC,EAAAwC,KACA7C,EAAA,EAAA2C,EAAA1D,KAAAmC,QAAAtB,UAAqDE,EAAA2C,EAAAzC,OAAgBF,IAAA,CACrE,IAAA4C,EAAAD,EAAA3C,GACA,GAAA4C,EAAAvC,OAAAwC,EAAA,CACA5D,KAAA+D,iBAAA3C,EAAAvB,EAAAM,uBAAAyD,EAAAD,EAAAnC,UACA,SAIAd,EAlDA,CAmDCd,EAAAqE","file":"static/js/151.3777505e.chunk.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\n/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING_FACTORY = function (expression, messageAddition) {\n        return \"Calls to '\" + expression + \"' are not allowed.\" + (messageAddition !== undefined ? \" \" + messageAddition : \"\");\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new BanFunctionWalker(sourceFile, this.ruleName, parseOptions(this.ruleArguments)));\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"ban\",\n        description: \"Bans the use of specific functions or global methods.\",\n        optionsDescription: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            A list of banned functions or methods in the following format:\\n\\n            * banning functions:\\n              * just the name of the function: `\\\"functionName\\\"`\\n              * the name of the function in an array with one element: `[\\\"functionName\\\"]`\\n              * an object in the following format: `{\\\"name\\\": \\\"functionName\\\", \\\"message\\\": \\\"optional explanation message\\\"}`\\n            * banning methods:\\n              * an array with the object name, method name and optional message: `[\\\"objectName\\\", \\\"methodName\\\", \\\"optional message\\\"]`\\n              * an object in the following format: `{\\\"name\\\": [\\\"objectName\\\", \\\"methodName\\\"], \\\"message\\\": \\\"optional message\\\"}`\\n                * you can also ban deeply nested methods: `{\\\"name\\\": [\\\"foo\\\", \\\"bar\\\", \\\"baz\\\"]}` bans `foo.bar.baz()`\\n                * the first element can contain a wildcard (`*`) that matches everything. `{\\\"name\\\": [\\\"*\\\", \\\"forEach\\\"]}` bans                  `[].forEach(...)`, `$(...).forEach(...)`, `arr.forEach(...)`, etc.\\n            \"], [\"\\n            A list of banned functions or methods in the following format:\\n\\n            * banning functions:\\n              * just the name of the function: \\\\`\\\"functionName\\\"\\\\`\\n              * the name of the function in an array with one element: \\\\`[\\\"functionName\\\"]\\\\`\\n              * an object in the following format: \\\\`{\\\"name\\\": \\\"functionName\\\", \\\"message\\\": \\\"optional explanation message\\\"}\\\\`\\n            * banning methods:\\n              * an array with the object name, method name and optional message: \\\\`[\\\"objectName\\\", \\\"methodName\\\", \\\"optional message\\\"]\\\\`\\n              * an object in the following format: \\\\`{\\\"name\\\": [\\\"objectName\\\", \\\"methodName\\\"], \\\"message\\\": \\\"optional message\\\"}\\\\`\\n                * you can also ban deeply nested methods: \\\\`{\\\"name\\\": [\\\"foo\\\", \\\"bar\\\", \\\"baz\\\"]}\\\\` bans \\\\`foo.bar.baz()\\\\`\\n                * the first element can contain a wildcard (\\\\`*\\\\`) that matches everything. \\\\`{\\\"name\\\": [\\\"*\\\", \\\"forEach\\\"]}\\\\` bans\\\\\\n                  \\\\`[].forEach(...)\\\\`, \\\\`$(...).forEach(...)\\\\`, \\\\`arr.forEach(...)\\\\`, etc.\\n            \"]))),\n        options: {\n            type: \"list\",\n            listType: {\n                anyOf: [\n                    {\n                        type: \"string\",\n                    },\n                    {\n                        type: \"array\",\n                        items: { type: \"string\" },\n                        minLength: 1,\n                        maxLength: 3,\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            name: {\n                                anyOf: [\n                                    { type: \"string\" },\n                                    { type: \"array\", items: { type: \"string\" }, minLength: 1 },\n                                ],\n                            },\n                            message: { type: \"string\" },\n                        },\n                        required: [\"name\"],\n                    },\n                ],\n            },\n        },\n        optionExamples: [\n            [\n                true,\n                \"eval\",\n                { name: \"$\", message: \"please don't\" },\n                [\"describe\", \"only\"],\n                { name: [\"it\", \"only\"], message: \"don't focus tests\" },\n                { name: [\"chai\", \"assert\", \"equal\"], message: \"Use 'strictEqual' instead.\" },\n                { name: [\"*\", \"forEach\"], message: \"Use a regular for loop instead.\" },\n            ],\n        ],\n        type: \"functionality\",\n        typescriptOnly: false,\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nfunction parseOptions(args) {\n    var functions = [];\n    var methods = [];\n    for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {\n        var arg = args_1[_i];\n        if (typeof arg === \"string\") {\n            functions.push({ name: arg });\n        }\n        else if (Array.isArray(arg)) {\n            switch (arg.length) {\n                case 0:\n                    break;\n                case 1:\n                    functions.push({ name: arg[0] });\n                    break;\n                default:\n                    methods.push({ object: [arg[0]], name: arg[1], message: arg[2] });\n            }\n        }\n        else if (!Array.isArray(arg.name)) {\n            functions.push(arg);\n        }\n        else {\n            switch (arg.name.length) {\n                case 0:\n                    break;\n                case 1:\n                    functions.push({ name: arg.name[0], message: arg.message });\n                    break;\n                default:\n                    methods.push({\n                        message: arg.message,\n                        name: arg.name[arg.name.length - 1],\n                        object: arg.name.slice(0, -1),\n                    });\n            }\n        }\n    }\n    return { functions: functions, methods: methods };\n}\nvar BanFunctionWalker = /** @class */ (function (_super) {\n    tslib_1.__extends(BanFunctionWalker, _super);\n    function BanFunctionWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    BanFunctionWalker.prototype.walk = function (sourceFile) {\n        var _this = this;\n        var cb = function (node) {\n            if (tsutils_1.isCallExpression(node)) {\n                if (tsutils_1.isIdentifier(node.expression)) {\n                    _this.checkFunctionBan(node.expression);\n                }\n                else if (tsutils_1.isPropertyAccessExpression(node.expression)) {\n                    _this.checkForObjectMethodBan(node.expression);\n                }\n            }\n            return ts.forEachChild(node, cb);\n        };\n        return ts.forEachChild(sourceFile, cb);\n    };\n    BanFunctionWalker.prototype.checkForObjectMethodBan = function (expression) {\n        for (var _i = 0, _a = this.options.methods; _i < _a.length; _i++) {\n            var ban = _a[_i];\n            if (expression.name.text !== ban.name) {\n                continue;\n            }\n            var current = expression.expression;\n            for (var i = ban.object.length - 1; i > 0; --i) {\n                if (!tsutils_1.isPropertyAccessExpression(current) || current.name.text !== ban.object[i]) {\n                    continue;\n                }\n                current = current.expression;\n            }\n            if (ban.object[0] === \"*\" ||\n                (tsutils_1.isIdentifier(current) && current.text === ban.object[0])) {\n                this.addFailureAtNode(expression, Rule.FAILURE_STRING_FACTORY(ban.object.join(\".\") + \".\" + ban.name, ban.message));\n                break;\n            }\n        }\n    };\n    BanFunctionWalker.prototype.checkFunctionBan = function (name) {\n        var text = name.text;\n        for (var _i = 0, _a = this.options.functions; _i < _a.length; _i++) {\n            var ban = _a[_i];\n            if (ban.name === text) {\n                this.addFailureAtNode(name, Rule.FAILURE_STRING_FACTORY(text, ban.message));\n                break;\n            }\n        }\n    };\n    return BanFunctionWalker;\n}(Lint.AbstractWalker));\nvar templateObject_1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/banRule.js\n// module id = 2016\n// module chunks = 151"],"sourceRoot":""}