{"version":3,"sources":["../node_modules/tslint/lib/rules/adjacentOverloadSignaturesRule.js","../node_modules/tslint/lib/rules/unifiedSignaturesRule.js"],"names":["Object","defineProperty","exports","value","tslib_1","__webpack_require__","utils","ts","Rule","_super","apply","this","arguments","__extends","FAILURE_STRING","name","prototype","sourceFile","applyWithFunction","walk","metadata","ruleName","description","optionsDescription","options","optionExamples","rationale","type","typescriptOnly","Rules","AbstractRule","ctx","visitStatements","statements","forEachChild","cb","node","kind","SyntaxKind","ModuleBlock","InterfaceDeclaration","ClassDeclaration","TypeLiteral","addFailures","getMisplacedOverloads","members","member","isSignatureDeclaration","getOverloadKey","undefined","statement","isFunctionDeclaration","text","misplacedOverloads","_i","misplacedOverloads_1","length","addFailureAtNode","printOverload","overloads","getKey","lastKey","result","seen","Set","overloads_1","SemicolonClassElement","key","has","push","add","info","getOverloadInfo","_a","computed","isStatic","hasModifier","modifiers","StaticKeyword","ConstructSignature","Constructor","CallSignature","Identifier","ComputedPropertyName","expression","isLiteralExpression","getText","Lint","utils_1","adjacentOverloadSignaturesRule_1","FAILURE_STRING_OMITTING_SINGLE_PARAMETER","otherLine","FAILURE_STRING_START","FAILURE_STRING_OMITTING_REST_PARAMETER","FAILURE_STRING_SINGLE_PARAMETER_DIFFERENCE","type1","type2","checkStatements","checkMembers","typeParameters","checkOverloads","body","signature","MethodSignature","MethodDeclaration","failures","failures_1","failure","unify","only2","p0","p1","lineOfOtherOverload","getLine","getStart","typeText","extraParameter","otherSignature","pos","dotDotDotToken","getLineAndCharacterOfPosition","line","signatures","getOverload","isTypeParameter","set","typeParameters_1","t","typeName","getIsTypeParameter","nodes","map","Map","nodes_1","sig","overload","get","Array","from","values","collectOverloads","compareSignatures","forEachPair","a","b","typesAreEqual","arraysAreEqual","typeParametersAreEqual","signatureUsesTypeParameter","signaturesCanBeUnified","parameters","types1","types2","index","equal","i","getIndexOfFirstDifference","parametersAreEqual","slice","parametersHaveEqualSigils","signaturesDifferBySingleParameter","sig1","sig2","minLength","Math","min","longer","shorter","p","questionToken","signaturesDifferByOptionalOrRestParameter","some","typeContainsTypeParameter","isTypeReferenceNode","constraint","action","j"],"mappings":"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","file":"static/js/27.3b08aaf9.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = function (name) {\n        return \"All '\" + name + \"' signatures should be adjacent\";\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"adjacent-overload-signatures\",\n        description: \"Enforces function overloads to be consecutive.\",\n        optionsDescription: \"Not configurable.\",\n        options: null,\n        optionExamples: [true],\n        rationale: \"Improves readability and organization by grouping naturally related items together.\",\n        type: \"typescript\",\n        typescriptOnly: true,\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var sourceFile = ctx.sourceFile;\n    visitStatements(sourceFile.statements);\n    return ts.forEachChild(sourceFile, function cb(node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.ModuleBlock:\n                visitStatements(node.statements);\n                break;\n            case ts.SyntaxKind.InterfaceDeclaration:\n            case ts.SyntaxKind.ClassDeclaration:\n            case ts.SyntaxKind.TypeLiteral: {\n                var members = node.members;\n                addFailures(getMisplacedOverloads(members, function (member) {\n                    return utils.isSignatureDeclaration(member)\n                        ? getOverloadKey(member)\n                        : undefined;\n                }));\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n    function visitStatements(statements) {\n        addFailures(getMisplacedOverloads(statements, function (statement) {\n            return utils.isFunctionDeclaration(statement) && statement.name !== undefined\n                ? statement.name.text\n                : undefined;\n        }));\n    }\n    function addFailures(misplacedOverloads) {\n        for (var _i = 0, misplacedOverloads_1 = misplacedOverloads; _i < misplacedOverloads_1.length; _i++) {\n            var node = misplacedOverloads_1[_i];\n            ctx.addFailureAtNode(node, Rule.FAILURE_STRING(printOverload(node)));\n        }\n    }\n}\n/** 'getOverloadName' may return undefined for nodes that cannot be overloads, e.g. a `const` declaration. */\nfunction getMisplacedOverloads(overloads, getKey) {\n    var result = [];\n    var lastKey;\n    var seen = new Set();\n    for (var _i = 0, overloads_1 = overloads; _i < overloads_1.length; _i++) {\n        var node = overloads_1[_i];\n        if (node.kind === ts.SyntaxKind.SemicolonClassElement) {\n            continue;\n        }\n        var key = getKey(node);\n        if (key !== undefined) {\n            if (seen.has(key) && lastKey !== key) {\n                result.push(node);\n            }\n            seen.add(key);\n            lastKey = key;\n        }\n        else {\n            lastKey = undefined;\n        }\n    }\n    return result;\n}\nfunction printOverload(node) {\n    var info = getOverloadInfo(node);\n    return typeof info === \"string\" ? info : info === undefined ? \"<unknown>\" : info.name;\n}\nfunction getOverloadKey(node) {\n    var info = getOverloadInfo(node);\n    if (info === undefined) {\n        return undefined;\n    }\n    var _a = typeof info === \"string\" ? [false, info] : [info.computed, info.name], computed = _a[0], name = _a[1];\n    var isStatic = utils.hasModifier(node.modifiers, ts.SyntaxKind.StaticKeyword);\n    return (computed ? \"0\" : \"1\") + (isStatic ? \"0\" : \"1\") + name;\n}\nexports.getOverloadKey = getOverloadKey;\nfunction getOverloadInfo(node) {\n    switch (node.kind) {\n        case ts.SyntaxKind.ConstructSignature:\n        case ts.SyntaxKind.Constructor:\n            return \"constructor\";\n        case ts.SyntaxKind.CallSignature:\n            return \"()\";\n        default: {\n            var name = node.name;\n            if (name === undefined) {\n                return undefined;\n            }\n            switch (name.kind) {\n                case ts.SyntaxKind.Identifier:\n                    return name.text;\n                case ts.SyntaxKind.ComputedPropertyName:\n                    var expression = name.expression;\n                    return utils.isLiteralExpression(expression)\n                        ? expression.text\n                        : { name: expression.getText(), computed: true };\n                default:\n                    return utils.isLiteralExpression(name) ? name.text : undefined;\n            }\n        }\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/adjacentOverloadSignaturesRule.js\n// module id = 1957\n// module chunks = 27 157","\"use strict\";\n/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar utils_1 = require(\"../utils\");\nvar adjacentOverloadSignaturesRule_1 = require(\"./adjacentOverloadSignaturesRule\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING_OMITTING_SINGLE_PARAMETER = function (otherLine) {\n        return this.FAILURE_STRING_START(otherLine) + \" with an optional parameter.\";\n    };\n    Rule.FAILURE_STRING_OMITTING_REST_PARAMETER = function (otherLine) {\n        return this.FAILURE_STRING_START(otherLine) + \" with a rest parameter.\";\n    };\n    Rule.FAILURE_STRING_SINGLE_PARAMETER_DIFFERENCE = function (otherLine, type1, type2) {\n        return this.FAILURE_STRING_START(otherLine) + \" taking `\" + type1 + \" | \" + type2 + \"`.\";\n    };\n    Rule.FAILURE_STRING_START = function (otherLine) {\n        // For only 2 overloads we don't need to specify which is the other one.\n        var overloads = otherLine === undefined\n            ? \"These overloads\"\n            : \"This overload and the one on line \" + otherLine;\n        return overloads + \" can be combined into one signature\";\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"unified-signatures\",\n        description: \"Warns for any two overloads that could be unified into one by using a union or an optional/rest parameter.\",\n        optionsDescription: \"Not configurable.\",\n        options: null,\n        optionExamples: [true],\n        type: \"typescript\",\n        typescriptOnly: true,\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var sourceFile = ctx.sourceFile;\n    checkStatements(sourceFile.statements);\n    return ts.forEachChild(sourceFile, function cb(node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.ModuleBlock:\n                checkStatements(node.statements);\n                break;\n            case ts.SyntaxKind.InterfaceDeclaration:\n            case ts.SyntaxKind.ClassDeclaration: {\n                var _a = node, members = _a.members, typeParameters = _a.typeParameters;\n                checkMembers(members, typeParameters);\n                break;\n            }\n            case ts.SyntaxKind.TypeLiteral:\n                checkMembers(node.members);\n        }\n        return ts.forEachChild(node, cb);\n    });\n    function checkStatements(statements) {\n        addFailures(checkOverloads(statements, undefined, function (statement) {\n            if (utils.isFunctionDeclaration(statement)) {\n                var body = statement.body, name = statement.name;\n                return body === undefined && name !== undefined\n                    ? { signature: statement, key: name.text }\n                    : undefined;\n            }\n            else {\n                return undefined;\n            }\n        }));\n    }\n    function checkMembers(members, typeParameters) {\n        addFailures(checkOverloads(members, typeParameters, function (member) {\n            switch (member.kind) {\n                case ts.SyntaxKind.CallSignature:\n                case ts.SyntaxKind.ConstructSignature:\n                case ts.SyntaxKind.MethodSignature:\n                    break;\n                case ts.SyntaxKind.MethodDeclaration:\n                case ts.SyntaxKind.Constructor:\n                    if (member.body !==\n                        undefined) {\n                        return undefined;\n                    }\n                    break;\n                default:\n                    return undefined;\n            }\n            var signature = member;\n            var key = adjacentOverloadSignaturesRule_1.getOverloadKey(signature);\n            return key === undefined ? undefined : { signature: signature, key: key };\n        }));\n    }\n    function addFailures(failures) {\n        for (var _i = 0, failures_1 = failures; _i < failures_1.length; _i++) {\n            var failure = failures_1[_i];\n            var unify = failure.unify, only2 = failure.only2;\n            switch (unify.kind) {\n                case \"single-parameter-difference\": {\n                    var p0 = unify.p0, p1 = unify.p1;\n                    var lineOfOtherOverload = only2 ? undefined : getLine(p0.getStart());\n                    ctx.addFailureAtNode(p1, Rule.FAILURE_STRING_SINGLE_PARAMETER_DIFFERENCE(lineOfOtherOverload, typeText(p0), typeText(p1)));\n                    break;\n                }\n                case \"extra-parameter\": {\n                    var extraParameter = unify.extraParameter, otherSignature = unify.otherSignature;\n                    var lineOfOtherOverload = only2 ? undefined : getLine(otherSignature.pos);\n                    ctx.addFailureAtNode(extraParameter, extraParameter.dotDotDotToken !== undefined\n                        ? Rule.FAILURE_STRING_OMITTING_REST_PARAMETER(lineOfOtherOverload)\n                        : Rule.FAILURE_STRING_OMITTING_SINGLE_PARAMETER(lineOfOtherOverload));\n                }\n            }\n        }\n    }\n    function getLine(pos) {\n        return ts.getLineAndCharacterOfPosition(sourceFile, pos).line + 1;\n    }\n}\nfunction checkOverloads(signatures, typeParameters, getOverload) {\n    var result = [];\n    var isTypeParameter = getIsTypeParameter(typeParameters);\n    for (var _i = 0, _a = collectOverloads(signatures, getOverload); _i < _a.length; _i++) {\n        var overloads = _a[_i];\n        if (overloads.length === 2) {\n            var unify = compareSignatures(overloads[0], overloads[1], isTypeParameter);\n            if (unify !== undefined) {\n                result.push({ unify: unify, only2: true });\n            }\n        }\n        else {\n            forEachPair(overloads, function (a, b) {\n                var unify = compareSignatures(a, b, isTypeParameter);\n                if (unify !== undefined) {\n                    result.push({ unify: unify, only2: false });\n                }\n            });\n        }\n    }\n    return result;\n}\nfunction compareSignatures(a, b, isTypeParameter) {\n    if (!signaturesCanBeUnified(a, b, isTypeParameter)) {\n        return undefined;\n    }\n    return a.parameters.length === b.parameters.length\n        ? signaturesDifferBySingleParameter(a.parameters, b.parameters)\n        : signaturesDifferByOptionalOrRestParameter(a.parameters, b.parameters);\n}\nfunction signaturesCanBeUnified(a, b, isTypeParameter) {\n    // Must return the same type.\n    return (typesAreEqual(a.type, b.type) &&\n        // Must take the same type parameters.\n        utils_1.arraysAreEqual(a.typeParameters, b.typeParameters, typeParametersAreEqual) &&\n        // If one uses a type parameter (from outside) and the other doesn't, they shouldn't be joined.\n        signatureUsesTypeParameter(a, isTypeParameter) ===\n            signatureUsesTypeParameter(b, isTypeParameter));\n}\n/** Detect `a(x: number, y: number, z: number)` and `a(x: number, y: string, z: number)`. */\nfunction signaturesDifferBySingleParameter(types1, types2) {\n    var index = getIndexOfFirstDifference(types1, types2, parametersAreEqual);\n    if (index === undefined) {\n        return undefined;\n    }\n    // If remaining arrays are equal, the signatures differ by just one parameter type\n    if (!utils_1.arraysAreEqual(types1.slice(index + 1), types2.slice(index + 1), parametersAreEqual)) {\n        return undefined;\n    }\n    var a = types1[index];\n    var b = types2[index];\n    // Can unify `a?: string` and `b?: number`. Can't unify `...args: string[]` and `...args: number[]`.\n    // See https://github.com/Microsoft/TypeScript/issues/5077\n    return parametersHaveEqualSigils(a, b) && a.dotDotDotToken === undefined\n        ? { kind: \"single-parameter-difference\", p0: a, p1: b }\n        : undefined;\n}\n/**\n * Detect `a(): void` and `a(x: number): void`.\n * Returns the parameter declaration (`x: number` in this example) that should be optional/rest, and overload it's a part of.\n */\nfunction signaturesDifferByOptionalOrRestParameter(sig1, sig2) {\n    var minLength = Math.min(sig1.length, sig2.length);\n    var longer = sig1.length < sig2.length ? sig2 : sig1;\n    var shorter = sig1.length < sig2.length ? sig1 : sig2;\n    // If one is has 2+ parameters more than the other, they must all be optional/rest.\n    // Differ by optional parameters: f() and f(x), f() and f(x, ?y, ...z)\n    // Not allowed: f() and f(x, y)\n    for (var i = minLength + 1; i < longer.length; i++) {\n        if (!parameterMayBeMissing(longer[i])) {\n            return undefined;\n        }\n    }\n    for (var i = 0; i < minLength; i++) {\n        if (!typesAreEqual(sig1[i].type, sig2[i].type)) {\n            return undefined;\n        }\n    }\n    if (minLength > 0 && shorter[minLength - 1].dotDotDotToken !== undefined) {\n        return undefined;\n    }\n    return {\n        extraParameter: longer[longer.length - 1],\n        kind: \"extra-parameter\",\n        otherSignature: shorter,\n    };\n}\n/** Given type parameters, returns a function to test whether a type is one of those parameters. */\nfunction getIsTypeParameter(typeParameters) {\n    if (typeParameters === undefined) {\n        return function () { return false; };\n    }\n    var set = new Set();\n    for (var _i = 0, typeParameters_1 = typeParameters; _i < typeParameters_1.length; _i++) {\n        var t = typeParameters_1[_i];\n        set.add(t.getText());\n    }\n    return function (typeName) { return set.has(typeName); };\n}\n/** True if any of the outer type parameters are used in a signature. */\nfunction signatureUsesTypeParameter(sig, isTypeParameter) {\n    return sig.parameters.some(function (p) { return p.type !== undefined && typeContainsTypeParameter(p.type) === true; });\n    function typeContainsTypeParameter(type) {\n        if (utils.isTypeReferenceNode(type)) {\n            var typeName = type.typeName;\n            if (typeName.kind === ts.SyntaxKind.Identifier && isTypeParameter(typeName.text)) {\n                return true;\n            }\n        }\n        return ts.forEachChild(type, typeContainsTypeParameter);\n    }\n}\n/**\n * Given all signatures, collects an array of arrays of signatures which are all overloads.\n * Does not rely on overloads being adjacent. This is similar to code in adjacentOverloadSignaturesRule.ts, but not the same.\n */\nfunction collectOverloads(nodes, getOverload) {\n    var map = new Map();\n    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n        var sig = nodes_1[_i];\n        var overload = getOverload(sig);\n        if (overload === undefined) {\n            continue;\n        }\n        var signature = overload.signature, key = overload.key;\n        var overloads = map.get(key);\n        if (overloads !== undefined) {\n            overloads.push(signature);\n        }\n        else {\n            map.set(key, [signature]);\n        }\n    }\n    return Array.from(map.values());\n}\nfunction parametersAreEqual(a, b) {\n    return parametersHaveEqualSigils(a, b) && typesAreEqual(a.type, b.type);\n}\n/** True for optional/rest parameters. */\nfunction parameterMayBeMissing(p) {\n    return p.dotDotDotToken !== undefined || p.questionToken !== undefined;\n}\n/** False if one is optional and the other isn't, or one is a rest parameter and the other isn't. */\nfunction parametersHaveEqualSigils(a, b) {\n    return ((a.dotDotDotToken !== undefined) === (b.dotDotDotToken !== undefined) &&\n        (a.questionToken !== undefined) === (b.questionToken !== undefined));\n}\nfunction typeParametersAreEqual(a, b) {\n    return a.name.text === b.name.text && typesAreEqual(a.constraint, b.constraint);\n}\nfunction typesAreEqual(a, b) {\n    // TODO: Could traverse AST so that formatting differences don't affect this.\n    return a === b || (a !== undefined && b !== undefined && a.getText() === b.getText());\n}\n/** Returns the first index where `a` and `b` differ. */\nfunction getIndexOfFirstDifference(a, b, equal) {\n    for (var i = 0; i < a.length && i < b.length; i++) {\n        if (!equal(a[i], b[i])) {\n            return i;\n        }\n    }\n    return undefined;\n}\n/** Calls `action` for every pair of values in `values`. */\nfunction forEachPair(values, action) {\n    for (var i = 0; i < values.length; i++) {\n        for (var j = i + 1; j < values.length; j++) {\n            var result = action(values[i], values[j]);\n            if (result !== undefined) {\n                return result;\n            }\n        }\n    }\n    return undefined;\n}\nfunction typeText(_a) {\n    var type = _a.type;\n    return type === undefined ? \"any\" : type.getText();\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/unifiedSignaturesRule.js\n// module id = 2152\n// module chunks = 27"],"sourceRoot":""}