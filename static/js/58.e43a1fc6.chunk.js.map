{"version":3,"sources":["../node_modules/tslint/lib/rules/orderedImportsRule.js"],"names":["Object","defineProperty","exports","value","tslib_1","__webpack_require__","tsutils_1","ts","Lint","Rule","_super","apply","this","arguments","__extends","prototype","sourceFile","applyWithWalker","Walker","ruleName","ruleArguments","optionSet","_b","_a","undefined","isGrouped","_c","sources","_d","named","_e","path","groupedImports","importSourcesOrderTransform","TRANSFORMS","get","moduleSourcePath","namedImportsOrderTransform","metadata","description","descriptionDetails","Utils","dedent","templateObject_1","__makeTemplateObject","hasFix","optionsDescription","templateObject_2","options","type","properties","grouped-imports","import-sources-order","enum","named-imports-order","module-source-path","additionalProperties","optionExamples","typescriptOnly","IMPORT_SOURCES_NOT_GROUPED","IMPORT_SOURCES_UNORDERED","NAMED_IMPORTS_UNORDERED","IMPORT_SOURCES_OF_SAME_TYPE_NOT_IN_ONE_GROUP","Rules","AbstractRule","ImportType","Map","x","toLowerCase","str","Array","from","map","char","toUpperCase","join","isExternalModuleNameRelative","splitIndex","lastIndexOf","substr","_this","importsBlocks","ImportsBlock","nextType","LIBRARY_IMPORT","length","enumerable","configurable","walk","_i","statements","statement","checkStatement","endBlock","checkBlocksGrouping","isImportDeclaration","isImportEqualsDeclaration","test","text","slice","getFullStart","getStart","checkImportDeclaration","checkImportEqualsDeclaration","isModuleDeclaration","body","node","kind","SyntaxKind","ModuleDeclaration","ModuleBlock","moduleDeclarationBody","subStatement","isStringLiteral","moduleSpecifier","source","removeQuotes","checkSource","importClause","namedBindings","isNamedImports","checkNamedImports","moduleReference","isExternalModuleReference","expression","originalSource","sourcePath","charAt","PARENT_DIRECTORY_IMPORT","CURRENT_DIRECTORY_IMPORT","currentSource","previousSource","currentImportsBlock","getLastImportSource","addImportDeclaration","compare","lastFix","addFailureAtNode","replacement","getReplacement","push","imports","elements","pair","xs","transform","i","getText","findUnsortedPair","a","b","sortedDeclarations","sortByKey","start","replaceNamedImports","addFailure","getEnd","checkBlocksUniqueness","some","checkBlockGroups","typesEncountered","filter","block","getImportDeclarations","forEach","firstInBlock","set","importsBlock","oddImportDeclaration","getOddImportDeclaration","getReplacements","importDeclarations","find","importDeclaration","importDeclarationsList","allImportDeclarations","concat","replacements","getReplacementsForExistingImports","startOffset","nodeStartOffset","Replacement","appendText","getGroupedImports","items","index","prevItems","last","nodeEndOffset","deleteFromTo","getSortedImportDeclarationsAsText","getEolChar","newLine","lineEnd","getLineEndOfPosition","sys","AbstractWalker","getStartOffset","end","getEndOffset","substring","fileOffset","getLastImportDeclaration","Error","initialText","fixedText","indexOf","isLow","getSortKey","sort"],"mappings":"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","file":"static/js/58.e43a1fc6.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2018 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new Walker(sourceFile, this.ruleName, parseOptions(this.ruleArguments)));\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"ordered-imports\",\n        description: \"Requires that import statements be alphabetized and grouped.\",\n        descriptionDetails: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            Enforce a consistent ordering for ES6 imports:\\n            - Named imports must be alphabetized (i.e. \\\"import {A, B, C} from \\\"foo\\\";\\\")\\n                - The exact ordering can be controlled by the named-imports-order option.\\n                - \\\"longName as name\\\" imports are ordered by \\\"longName\\\".\\n            - Import sources must be alphabetized within groups, i.e.:\\n                    import * as foo from \\\"a\\\";\\n                    import * as bar from \\\"b\\\";\\n            - Groups of imports are delineated by blank lines. You can use these to group imports\\n                however you like, e.g. by first- vs. third-party or thematically or can you can\\n                enforce a grouping of third-party, parent directories and the current directory.\"], [\"\\n            Enforce a consistent ordering for ES6 imports:\\n            - Named imports must be alphabetized (i.e. \\\"import {A, B, C} from \\\"foo\\\";\\\")\\n                - The exact ordering can be controlled by the named-imports-order option.\\n                - \\\"longName as name\\\" imports are ordered by \\\"longName\\\".\\n            - Import sources must be alphabetized within groups, i.e.:\\n                    import * as foo from \\\"a\\\";\\n                    import * as bar from \\\"b\\\";\\n            - Groups of imports are delineated by blank lines. You can use these to group imports\\n                however you like, e.g. by first- vs. third-party or thematically or can you can\\n                enforce a grouping of third-party, parent directories and the current directory.\"]))),\n        hasFix: true,\n        optionsDescription: Lint.Utils.dedent(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject([\"\\n            You may set the `\\\"import-sources-order\\\"` option to control the ordering of source\\n            imports (the `\\\"foo\\\"` in `import {A, B, C} from \\\"foo\\\"`).\\n\\n            Possible values for `\\\"import-sources-order\\\"` are:\\n\\n            * `\\\"case-insensitive'`: Correct order is `\\\"Bar\\\"`, `\\\"baz\\\"`, `\\\"Foo\\\"`. (This is the default.)\\n            * `\\\"lowercase-first\\\"`: Correct order is `\\\"baz\\\"`, `\\\"Bar\\\"`, `\\\"Foo\\\"`.\\n            * `\\\"lowercase-last\\\"`: Correct order is `\\\"Bar\\\"`, `\\\"Foo\\\"`, `\\\"baz\\\"`.\\n            * `\\\"any\\\"`: Allow any order.\\n\\n            You may set the `\\\"grouped-imports\\\"` option to control the grouping of source\\n            imports (the `\\\"foo\\\"` in `import {A, B, C} from \\\"foo\\\"`).\\n\\n            Possible values for `\\\"grouped-imports\\\"` are:\\n\\n            * `false`: Do not enforce grouping. (This is the default.)\\n            * `true`: Group source imports by `\\\"bar\\\"`, `\\\"../baz\\\"`, `\\\"./foo\\\"`.\\n\\n            You may set the `\\\"named-imports-order\\\"` option to control the ordering of named\\n            imports (the `{A, B, C}` in `import {A, B, C} from \\\"foo\\\"`).\\n\\n            Possible values for `\\\"named-imports-order\\\"` are:\\n\\n            * `\\\"case-insensitive'`: Correct order is `{A, b, C}`. (This is the default.)\\n            * `\\\"lowercase-first\\\"`: Correct order is `{b, A, C}`.\\n            * `\\\"lowercase-last\\\"`: Correct order is `{A, C, b}`.\\n            * `\\\"any\\\"`: Allow any order.\\n\\n            You may set the `\\\"module-source-path\\\"` option to control the ordering of imports based full path\\n            or just the module name\\n\\n            Possible values for `\\\"module-source-path\\\"` are:\\n\\n            * `\\\"full'`: Correct order is  `\\\"./a/Foo\\\"`, `\\\"./b/baz\\\"`, `\\\"./c/Bar\\\"`. (This is the default.)\\n            * `\\\"basename\\\"`: Correct order is `\\\"./c/Bar\\\"`, `\\\"./b/baz\\\"`, `\\\"./a/Foo\\\"`.\\n\\n        \"], [\"\\n            You may set the \\\\`\\\"import-sources-order\\\"\\\\` option to control the ordering of source\\n            imports (the \\\\`\\\"foo\\\"\\\\` in \\\\`import {A, B, C} from \\\"foo\\\"\\\\`).\\n\\n            Possible values for \\\\`\\\"import-sources-order\\\"\\\\` are:\\n\\n            * \\\\`\\\"case-insensitive'\\\\`: Correct order is \\\\`\\\"Bar\\\"\\\\`, \\\\`\\\"baz\\\"\\\\`, \\\\`\\\"Foo\\\"\\\\`. (This is the default.)\\n            * \\\\`\\\"lowercase-first\\\"\\\\`: Correct order is \\\\`\\\"baz\\\"\\\\`, \\\\`\\\"Bar\\\"\\\\`, \\\\`\\\"Foo\\\"\\\\`.\\n            * \\\\`\\\"lowercase-last\\\"\\\\`: Correct order is \\\\`\\\"Bar\\\"\\\\`, \\\\`\\\"Foo\\\"\\\\`, \\\\`\\\"baz\\\"\\\\`.\\n            * \\\\`\\\"any\\\"\\\\`: Allow any order.\\n\\n            You may set the \\\\`\\\"grouped-imports\\\"\\\\` option to control the grouping of source\\n            imports (the \\\\`\\\"foo\\\"\\\\` in \\\\`import {A, B, C} from \\\"foo\\\"\\\\`).\\n\\n            Possible values for \\\\`\\\"grouped-imports\\\"\\\\` are:\\n\\n            * \\\\`false\\\\`: Do not enforce grouping. (This is the default.)\\n            * \\\\`true\\\\`: Group source imports by \\\\`\\\"bar\\\"\\\\`, \\\\`\\\"../baz\\\"\\\\`, \\\\`\\\"./foo\\\"\\\\`.\\n\\n            You may set the \\\\`\\\"named-imports-order\\\"\\\\` option to control the ordering of named\\n            imports (the \\\\`{A, B, C}\\\\` in \\\\`import {A, B, C} from \\\"foo\\\"\\\\`).\\n\\n            Possible values for \\\\`\\\"named-imports-order\\\"\\\\` are:\\n\\n            * \\\\`\\\"case-insensitive'\\\\`: Correct order is \\\\`{A, b, C}\\\\`. (This is the default.)\\n            * \\\\`\\\"lowercase-first\\\"\\\\`: Correct order is \\\\`{b, A, C}\\\\`.\\n            * \\\\`\\\"lowercase-last\\\"\\\\`: Correct order is \\\\`{A, C, b}\\\\`.\\n            * \\\\`\\\"any\\\"\\\\`: Allow any order.\\n\\n            You may set the \\\\`\\\"module-source-path\\\"\\\\` option to control the ordering of imports based full path\\n            or just the module name\\n\\n            Possible values for \\\\`\\\"module-source-path\\\"\\\\` are:\\n\\n            * \\\\`\\\"full'\\\\`: Correct order is  \\\\`\\\"./a/Foo\\\"\\\\`, \\\\`\\\"./b/baz\\\"\\\\`, \\\\`\\\"./c/Bar\\\"\\\\`. (This is the default.)\\n            * \\\\`\\\"basename\\\"\\\\`: Correct order is \\\\`\\\"./c/Bar\\\"\\\\`, \\\\`\\\"./b/baz\\\"\\\\`, \\\\`\\\"./a/Foo\\\"\\\\`.\\n\\n        \"]))),\n        options: {\n            type: \"object\",\n            properties: {\n                \"grouped-imports\": {\n                    type: \"boolean\",\n                },\n                \"import-sources-order\": {\n                    type: \"string\",\n                    enum: [\"case-insensitive\", \"lowercase-first\", \"lowercase-last\", \"any\"],\n                },\n                \"named-imports-order\": {\n                    type: \"string\",\n                    enum: [\"case-insensitive\", \"lowercase-first\", \"lowercase-last\", \"any\"],\n                },\n                \"module-source-path\": {\n                    type: \"string\",\n                    enum: [\"full\", \"basename\"],\n                },\n            },\n            additionalProperties: false,\n        },\n        optionExamples: [\n            true,\n            [\n                true,\n                {\n                    \"import-sources-order\": \"lowercase-last\",\n                    \"named-imports-order\": \"lowercase-first\",\n                },\n            ],\n        ],\n        type: \"style\",\n        typescriptOnly: false,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.IMPORT_SOURCES_NOT_GROUPED = \"Import sources of different groups must be sorted by: libraries, parent directories, current directory.\";\n    Rule.IMPORT_SOURCES_UNORDERED = \"Import sources within a group must be alphabetized.\";\n    Rule.NAMED_IMPORTS_UNORDERED = \"Named imports must be alphabetized.\";\n    Rule.IMPORT_SOURCES_OF_SAME_TYPE_NOT_IN_ONE_GROUP = \"Import sources of the same type (package, same folder, different folder) must be grouped together.\";\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nvar TRANSFORMS = new Map([\n    [\"any\", function () { return \"\"; }],\n    [\"case-insensitive\", function (x) { return x.toLowerCase(); }],\n    [\"lowercase-first\", flipCase],\n    [\"lowercase-last\", function (x) { return x; }],\n    [\"full\", function (x) { return x; }],\n    [\n        \"basename\",\n        function (x) {\n            if (!ts.isExternalModuleNameRelative(x)) {\n                return x;\n            }\n            var splitIndex = x.lastIndexOf(\"/\");\n            if (splitIndex === -1) {\n                return x;\n            }\n            return x.substr(splitIndex + 1);\n        },\n    ],\n]);\nvar ImportType;\n(function (ImportType) {\n    ImportType[ImportType[\"LIBRARY_IMPORT\"] = 1] = \"LIBRARY_IMPORT\";\n    ImportType[ImportType[\"PARENT_DIRECTORY_IMPORT\"] = 2] = \"PARENT_DIRECTORY_IMPORT\";\n    ImportType[ImportType[\"CURRENT_DIRECTORY_IMPORT\"] = 3] = \"CURRENT_DIRECTORY_IMPORT\";\n})(ImportType || (ImportType = {}));\nfunction parseOptions(ruleArguments) {\n    var optionSet = ruleArguments[0];\n    var _a = optionSet === undefined ? {} : optionSet, _b = _a[\"grouped-imports\"], isGrouped = _b === void 0 ? false : _b, _c = _a[\"import-sources-order\"], sources = _c === void 0 ? \"case-insensitive\" : _c, _d = _a[\"named-imports-order\"], named = _d === void 0 ? \"case-insensitive\" : _d, _e = _a[\"module-source-path\"], path = _e === void 0 ? \"full\" : _e;\n    return {\n        groupedImports: isGrouped,\n        importSourcesOrderTransform: TRANSFORMS.get(sources),\n        moduleSourcePath: TRANSFORMS.get(path),\n        namedImportsOrderTransform: TRANSFORMS.get(named),\n    };\n}\nvar Walker = /** @class */ (function (_super) {\n    tslib_1.__extends(Walker, _super);\n    function Walker() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.importsBlocks = [new ImportsBlock()];\n        _this.nextType = ImportType.LIBRARY_IMPORT;\n        return _this;\n    }\n    Object.defineProperty(Walker.prototype, \"currentImportsBlock\", {\n        get: function () {\n            return this.importsBlocks[this.importsBlocks.length - 1];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Walker.prototype.walk = function (sourceFile) {\n        for (var _i = 0, _a = sourceFile.statements; _i < _a.length; _i++) {\n            var statement = _a[_i];\n            this.checkStatement(statement);\n        }\n        this.endBlock();\n        if (this.options.groupedImports) {\n            this.checkBlocksGrouping();\n        }\n    };\n    Walker.prototype.checkStatement = function (statement) {\n        if (!(tsutils_1.isImportDeclaration(statement) || tsutils_1.isImportEqualsDeclaration(statement)) ||\n            /\\r?\\n\\r?\\n/.test(this.sourceFile.text.slice(statement.getFullStart(), statement.getStart(this.sourceFile)))) {\n            this.endBlock();\n        }\n        if (tsutils_1.isImportDeclaration(statement)) {\n            this.checkImportDeclaration(statement);\n        }\n        else if (tsutils_1.isImportEqualsDeclaration(statement)) {\n            this.checkImportEqualsDeclaration(statement);\n        }\n        else if (tsutils_1.isModuleDeclaration(statement)) {\n            var body = moduleDeclarationBody(statement);\n            if (body !== undefined) {\n                for (var _i = 0, _a = body.statements; _i < _a.length; _i++) {\n                    var subStatement = _a[_i];\n                    this.checkStatement(subStatement);\n                }\n                this.endBlock();\n            }\n        }\n    };\n    Walker.prototype.checkImportDeclaration = function (node) {\n        if (!tsutils_1.isStringLiteral(node.moduleSpecifier)) {\n            // Ignore grammar error\n            return;\n        }\n        var source = removeQuotes(node.moduleSpecifier.text);\n        this.checkSource(source, node);\n        var importClause = node.importClause;\n        if (importClause !== undefined &&\n            importClause.namedBindings !== undefined &&\n            tsutils_1.isNamedImports(importClause.namedBindings)) {\n            this.checkNamedImports(importClause.namedBindings);\n        }\n    };\n    Walker.prototype.checkImportEqualsDeclaration = function (node) {\n        // only allowed `import x = require('y');`\n        var moduleReference = node.moduleReference;\n        if (!tsutils_1.isExternalModuleReference(moduleReference)) {\n            return;\n        }\n        var expression = moduleReference.expression;\n        if (expression === undefined || !tsutils_1.isStringLiteral(expression)) {\n            return;\n        }\n        var source = removeQuotes(expression.text);\n        this.checkSource(source, node);\n    };\n    Walker.prototype.checkSource = function (originalSource, node) {\n        var type = getImportType(originalSource);\n        var source = this.options.importSourcesOrderTransform(originalSource);\n        var currentSource = this.options.moduleSourcePath(source);\n        var previousSource = this.currentImportsBlock.getLastImportSource();\n        this.currentImportsBlock.addImportDeclaration(this.sourceFile, node, currentSource, type);\n        if (previousSource !== null && compare(currentSource, previousSource) === -1) {\n            this.lastFix = [];\n            this.addFailureAtNode(node, Rule.IMPORT_SOURCES_UNORDERED, this.lastFix);\n        }\n    };\n    Walker.prototype.endBlock = function () {\n        if (this.lastFix !== undefined) {\n            var replacement = this.currentImportsBlock.getReplacement();\n            if (replacement !== undefined) {\n                this.lastFix.push(replacement);\n            }\n            this.lastFix = undefined;\n        }\n        this.importsBlocks.push(new ImportsBlock());\n    };\n    Walker.prototype.checkNamedImports = function (node) {\n        var _this = this;\n        var imports = node.elements;\n        var pair = findUnsortedPair(imports, this.options.namedImportsOrderTransform);\n        if (pair !== undefined) {\n            var a = pair[0], b = pair[1];\n            var sortedDeclarations = sortByKey(imports, function (x) {\n                return _this.options.namedImportsOrderTransform(x.getText());\n            }).map(function (x) { return x.getText(); });\n            // replace in reverse order to preserve earlier offsets\n            for (var i = imports.length - 1; i >= 0; i--) {\n                var start = imports[i].getStart();\n                var length = imports[i].getText().length;\n                // replace the named imports one at a time to preserve whitespace\n                this.currentImportsBlock.replaceNamedImports(start, length, sortedDeclarations[i]);\n            }\n            this.lastFix = [];\n            this.addFailure(a.getStart(), b.getEnd(), Rule.NAMED_IMPORTS_UNORDERED, this.lastFix);\n        }\n    };\n    Walker.prototype.checkBlocksGrouping = function () {\n        this.checkBlocksUniqueness();\n        this.importsBlocks.some(this.checkBlockGroups, this);\n    };\n    Walker.prototype.checkBlocksUniqueness = function () {\n        var _this = this;\n        var typesEncountered = new Map([\n            [ImportType.LIBRARY_IMPORT, false],\n            [ImportType.PARENT_DIRECTORY_IMPORT, false],\n            [ImportType.CURRENT_DIRECTORY_IMPORT, false],\n        ]);\n        var nonEmptyBlocks = this.importsBlocks.filter(function (block) { return block.getImportDeclarations().length > 0; });\n        nonEmptyBlocks.forEach(function (block) {\n            // assume the whole block is of the same type, hence use the first one as the representing one\n            var firstInBlock = block.getImportDeclarations()[0];\n            if (typesEncountered.get(firstInBlock.type)) {\n                _this.addFailureAtNode(firstInBlock.node, Rule.IMPORT_SOURCES_OF_SAME_TYPE_NOT_IN_ONE_GROUP);\n            }\n            else {\n                typesEncountered.set(firstInBlock.type, true);\n            }\n        });\n    };\n    Walker.prototype.checkBlockGroups = function (importsBlock) {\n        var oddImportDeclaration = this.getOddImportDeclaration(importsBlock);\n        if (oddImportDeclaration !== undefined) {\n            this.addFailureAtNode(oddImportDeclaration.node, Rule.IMPORT_SOURCES_NOT_GROUPED, this.getReplacements());\n            return true;\n        }\n        return false;\n    };\n    Walker.prototype.getOddImportDeclaration = function (importsBlock) {\n        var importDeclarations = importsBlock.getImportDeclarations();\n        if (importDeclarations.length === 0) {\n            return undefined;\n        }\n        var type = importDeclarations[0].type;\n        if (type < this.nextType) {\n            return importDeclarations[0];\n        }\n        else {\n            this.nextType = type;\n            return importDeclarations.find(function (importDeclaration) { return importDeclaration.type !== type; });\n        }\n    };\n    Walker.prototype.getReplacements = function () {\n        var _a;\n        var importDeclarationsList = this.importsBlocks\n            .map(function (block) { return block.getImportDeclarations(); })\n            .filter(function (imports) { return imports.length > 0; });\n        var allImportDeclarations = (_a = []).concat.apply(_a, importDeclarationsList);\n        var replacements = this.getReplacementsForExistingImports(importDeclarationsList);\n        var startOffset = allImportDeclarations.length === 0 ? 0 : allImportDeclarations[0].nodeStartOffset;\n        replacements.push(Lint.Replacement.appendText(startOffset, this.getGroupedImports(allImportDeclarations)));\n        return replacements;\n    };\n    Walker.prototype.getReplacementsForExistingImports = function (importDeclarationsList) {\n        var _this = this;\n        return importDeclarationsList.map(function (items, index) {\n            var start = items[0].nodeStartOffset;\n            if (index > 0) {\n                var prevItems = importDeclarationsList[index - 1];\n                var last = prevItems[prevItems.length - 1];\n                if (/[\\r\\n]+/.test(_this.sourceFile.text.slice(last.nodeEndOffset, start))) {\n                    // remove whitespace between blocks\n                    start = last.nodeEndOffset;\n                }\n            }\n            return Lint.Replacement.deleteFromTo(start, items[items.length - 1].nodeEndOffset);\n        });\n    };\n    Walker.prototype.getGroupedImports = function (importDeclarations) {\n        return [\n            ImportType.LIBRARY_IMPORT,\n            ImportType.PARENT_DIRECTORY_IMPORT,\n            ImportType.CURRENT_DIRECTORY_IMPORT,\n        ]\n            .map(function (type) {\n            var imports = importDeclarations.filter(function (importDeclaration) { return importDeclaration.type === type; });\n            return getSortedImportDeclarationsAsText(imports);\n        })\n            .filter(function (text) { return text.length > 0; })\n            .join(this.getEolChar());\n    };\n    Walker.prototype.getEolChar = function () {\n        var lineEnd = this.sourceFile.getLineEndOfPosition(0);\n        var newLine;\n        if (lineEnd > 0) {\n            if (lineEnd > 1 && this.sourceFile.text[lineEnd - 1] === \"\\r\") {\n                newLine = \"\\r\\n\";\n            }\n            else if (this.sourceFile.text[lineEnd] === \"\\n\") {\n                newLine = \"\\n\";\n            }\n        }\n        return newLine === undefined ? ts.sys.newLine : newLine;\n    };\n    return Walker;\n}(Lint.AbstractWalker));\nvar ImportsBlock = /** @class */ (function () {\n    function ImportsBlock() {\n        this.importDeclarations = [];\n    }\n    ImportsBlock.prototype.addImportDeclaration = function (sourceFile, node, sourcePath, type) {\n        var start = this.getStartOffset(node);\n        var end = this.getEndOffset(sourceFile, node);\n        var text = sourceFile.text.substring(start, end);\n        if (start > node.getStart() || end === 0) {\n            // skip block if any statements don't end with a newline to simplify implementation\n            this.importDeclarations = [];\n            return;\n        }\n        this.importDeclarations.push({\n            node: node,\n            nodeEndOffset: end,\n            nodeStartOffset: start,\n            sourcePath: sourcePath,\n            text: text,\n            type: type,\n        });\n    };\n    ImportsBlock.prototype.getImportDeclarations = function () {\n        return this.importDeclarations;\n    };\n    // replaces the named imports on the most recent import declaration\n    ImportsBlock.prototype.replaceNamedImports = function (fileOffset, length, replacement) {\n        var importDeclaration = this.getLastImportDeclaration();\n        if (importDeclaration === undefined) {\n            // nothing to replace. This can happen if the block is skipped\n            return;\n        }\n        var start = fileOffset - importDeclaration.nodeStartOffset;\n        if (start < 0 || start + length > importDeclaration.node.getEnd()) {\n            throw new Error(\"Unexpected named import position\");\n        }\n        var initialText = importDeclaration.text;\n        importDeclaration.text =\n            initialText.substring(0, start) + replacement + initialText.substring(start + length);\n    };\n    ImportsBlock.prototype.getLastImportSource = function () {\n        if (this.importDeclarations.length === 0) {\n            return null;\n        }\n        return this.getLastImportDeclaration().sourcePath;\n    };\n    // creates a Lint.Replacement object with ordering fixes for the entire block\n    ImportsBlock.prototype.getReplacement = function () {\n        if (this.importDeclarations.length === 0) {\n            return undefined;\n        }\n        var fixedText = getSortedImportDeclarationsAsText(this.importDeclarations);\n        var start = this.importDeclarations[0].nodeStartOffset;\n        var end = this.getLastImportDeclaration().nodeEndOffset;\n        return new Lint.Replacement(start, end - start, fixedText);\n    };\n    // gets the offset immediately after the end of the previous declaration to include comment above\n    ImportsBlock.prototype.getStartOffset = function (node) {\n        if (this.importDeclarations.length === 0) {\n            return node.getStart();\n        }\n        return this.getLastImportDeclaration().nodeEndOffset;\n    };\n    // gets the offset of the end of the import's line, including newline, to include comment to the right\n    ImportsBlock.prototype.getEndOffset = function (sourceFile, node) {\n        return sourceFile.text.indexOf(\"\\n\", node.end) + 1;\n    };\n    ImportsBlock.prototype.getLastImportDeclaration = function () {\n        return this.importDeclarations[this.importDeclarations.length - 1];\n    };\n    return ImportsBlock;\n}());\nfunction getImportType(sourcePath) {\n    if (sourcePath.charAt(0) === \".\") {\n        if (sourcePath.charAt(1) === \".\") {\n            return ImportType.PARENT_DIRECTORY_IMPORT;\n        }\n        else {\n            return ImportType.CURRENT_DIRECTORY_IMPORT;\n        }\n    }\n    else {\n        return ImportType.LIBRARY_IMPORT;\n    }\n}\n// Convert aBcD --> AbCd\nfunction flipCase(str) {\n    return Array.from(str)\n        .map(function (char) {\n        if (char >= \"a\" && char <= \"z\") {\n            return char.toUpperCase();\n        }\n        else if (char >= \"A\" && char <= \"Z\") {\n            return char.toLowerCase();\n        }\n        return char;\n    })\n        .join(\"\");\n}\n// After applying a transformation, are the nodes sorted according to the text they contain?\n// If not, return the pair of nodes which are out of order.\nfunction findUnsortedPair(xs, transform) {\n    for (var i = 1; i < xs.length; i++) {\n        if (transform(xs[i].getText()) < transform(xs[i - 1].getText())) {\n            return [xs[i - 1], xs[i]];\n        }\n    }\n    return undefined;\n}\nfunction compare(a, b) {\n    function isLow(value) {\n        return value[0] === \".\" || value[0] === \"/\";\n    }\n    if (isLow(a) && !isLow(b)) {\n        return 1;\n    }\n    else if (!isLow(a) && isLow(b)) {\n        return -1;\n    }\n    else if (a > b) {\n        return 1;\n    }\n    else if (a < b) {\n        return -1;\n    }\n    return 0;\n}\nfunction removeQuotes(value) {\n    // strip out quotes\n    if (value.length > 1 && (value[0] === \"'\" || value[0] === '\"')) {\n        value = value.substr(1, value.length - 2);\n    }\n    return value;\n}\nfunction getSortedImportDeclarationsAsText(importDeclarations) {\n    var sortedDeclarations = sortByKey(importDeclarations.slice(), function (x) { return x.sourcePath; });\n    return sortedDeclarations.map(function (x) { return x.text; }).join(\"\");\n}\nfunction sortByKey(xs, getSortKey) {\n    return xs.slice().sort(function (a, b) { return compare(getSortKey(a), getSortKey(b)); });\n}\nfunction moduleDeclarationBody(node) {\n    var body = node.body;\n    while (body !== undefined && body.kind === ts.SyntaxKind.ModuleDeclaration) {\n        body = body.body;\n    }\n    return body !== undefined && body.kind === ts.SyntaxKind.ModuleBlock ? body : undefined;\n}\nvar templateObject_1, templateObject_2;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/orderedImportsRule.js\n// module id = 2123\n// module chunks = 58"],"sourceRoot":""}