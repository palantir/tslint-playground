{"version":3,"sources":["../node_modules/tslint/lib/rules/typeLiteralDelimiterRule.js"],"names":["Object","defineProperty","exports","value","_a","templateObject_1","tslib_1","__webpack_require__","tsutils_1","ts","Lint","Rule","_super","apply","this","arguments","__extends","prototype","sourceFile","applyWithFunction","walk","getRuleOptions","undefined","ruleArguments","metadata","ruleName","description","Utils","dedent","__makeTemplateObject","optionsDescription","options","type","properties","enum","hasFix","optionExamples","typescriptOnly","FAILURE_STRING_MISSING","FAILURE_STRING_COMMA","FAILURE_STRING_TRAILING","Rules","AbstractRule","ctx","forEachChild","cb","node","isTypeLiteralNode","members","forEach","member","idx","end","shouldOmit","singleLine","length","isSameLine","getStart","getEnd","delimiter","text","addFailureAt","Replacement","replaceFromTo","check"],"mappings":"qDAiBAA,OAAAC,eAAAC,EAAA,cAA8CC,OAAA,IAC9C,IACAC,EAiFAC,EAlFAC,EAAAC,EAAA,GAEAC,EAAAD,EAAA,KACAE,EAAAF,EAAA,IACAG,EAAAH,EAAA,MAEAI,EAAA,SAAAC,GAEA,SAAAD,IACA,cAAAC,KAAAC,MAAAC,KAAAC,YAAAD,KAoCA,OAtCAR,EAAAU,UAAAL,EAAAC,GAIAD,EAAAM,UAAAJ,MAAA,SAAAK,GACA,OAAAJ,KAAAK,kBAAAD,EAAAE,EAAAN,KAAAO,mBAEAV,EAAAM,UAAAI,eAAA,WACA,YAAAC,IAAAR,KAAAS,cAAA,MAIAT,KAAAS,cAAA,IAIAZ,EAAAa,UACAC,SAAA,yBACAC,YAAAhB,EAAAiB,MAAAC,OAAAvB,MAAAC,EAAAuB,sBAAA,kTACAC,mBAAA,6DACAC,SACAC,KAAA,SACAC,YAAA7B,KACAA,EAAA,YACA4B,KAAA,SACAE,MAAA,mBAEA9B,IAEA+B,QAAA,EACAC,iBAAA,GACAJ,KAAA,QACAK,gBAAA,GAGA1B,EAAA2B,uBAAA,wDACA3B,EAAA4B,qBAAA,mDACA5B,EAAA6B,wBAAA,kEACA7B,EAvCA,CAwCCD,EAAA+B,MAAAC,cAED,SAAAtB,EAAAuB,GACA,IAAAzB,EAAAyB,EAAAzB,WAAAa,EAAAY,EAAAZ,QACAtB,EAAAmC,aAAA1B,EAAA,SAAA2B,EAAAC,GACAtC,EAAAuC,kBAAAD,IAKA,SAAAA,GACAA,EAAAE,QAAAC,QAAA,SAAAC,EAAAC,GACA,IAAAC,EAAAF,EAAAE,IAAA,EAEAC,EAAA,WAAAtB,EAAAuB,aAEAH,IAAAL,EAAAE,QAAAO,OAAA,GACA/C,EAAAgD,WAAAtC,EAAA4B,EAAAW,SAAAvC,GAAA4B,EAAAY,WACAC,EAAAzC,EAAA0C,KAAAR,GACA,OAAAO,GACA,QACAN,GACAV,EAAAkB,aAAAT,EAAA,EAAAzC,EAAA6B,wBAAA9B,EAAAoD,YAAAC,cAAAX,IAAA,OAEA,MACA,QACAT,EAAAkB,aAAAT,EAAA,EAAAzC,EAAA4B,qBAAA7B,EAAAoD,YAAAC,cAAAX,IAAA,QACA,MACA,QACAC,GACAV,EAAAkB,aAAAT,EAAA,EAAAzC,EAAA2B,uBAAA5B,EAAAoD,YAAAC,cAAAX,EAAA,EAAAA,EAAA,WAxBAY,CAAAlB,GAEArC,EAAAmC,aAAAE,EAAAD,KAPA3C,EAAAS","file":"static/js/38.242cdcf2.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar _a;\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar singeLineConfigOptionName = \"singleLine\";\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk, this.getRuleOptions());\n    };\n    Rule.prototype.getRuleOptions = function () {\n        if (this.ruleArguments[0] === undefined) {\n            return {};\n        }\n        else {\n            return this.ruleArguments[0];\n        }\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"type-literal-delimiter\",\n        description: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            Checks that type literal members are separated by semicolons.\\n            Enforces a trailing semicolon for multiline type literals.\"], [\"\\n            Checks that type literal members are separated by semicolons.\\n            Enforces a trailing semicolon for multiline type literals.\"]))),\n        optionsDescription: \"`{\" + singeLineConfigOptionName + \": \\\"always\\\"}` enforces semicolon for one liners\",\n        options: {\n            type: \"object\",\n            properties: (_a = {},\n                _a[singeLineConfigOptionName] = {\n                    type: \"string\",\n                    enum: [\"always\", \"never\"],\n                },\n                _a),\n        },\n        hasFix: true,\n        optionExamples: [true],\n        type: \"style\",\n        typescriptOnly: true,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING_MISSING = \"Expected type literal to use ';' to separate members.\";\n    Rule.FAILURE_STRING_COMMA = \"Expected type literal to use ';' instead of ','.\";\n    Rule.FAILURE_STRING_TRAILING = \"Did not expect single-line type literal to have a trailing ';'.\";\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var sourceFile = ctx.sourceFile, options = ctx.options;\n    ts.forEachChild(sourceFile, function cb(node) {\n        if (tsutils_1.isTypeLiteralNode(node)) {\n            check(node);\n        }\n        ts.forEachChild(node, cb);\n    });\n    function check(node) {\n        node.members.forEach(function (member, idx) {\n            var end = member.end - 1;\n            // Check if delimiter should be ommitted for a single-line type literal.\n            var shouldOmit = options.singleLine === \"always\"\n                ? false\n                : idx === node.members.length - 1 &&\n                    tsutils_1.isSameLine(sourceFile, node.getStart(sourceFile), node.getEnd());\n            var delimiter = sourceFile.text[end];\n            switch (delimiter) {\n                case \";\":\n                    if (shouldOmit) {\n                        ctx.addFailureAt(end, 1, Rule.FAILURE_STRING_TRAILING, Lint.Replacement.replaceFromTo(end, end + 1, \"\"));\n                    }\n                    break;\n                case \",\":\n                    ctx.addFailureAt(end, 1, Rule.FAILURE_STRING_COMMA, Lint.Replacement.replaceFromTo(end, end + 1, \";\"));\n                    break;\n                default:\n                    if (!shouldOmit) {\n                        ctx.addFailureAt(end, 1, Rule.FAILURE_STRING_MISSING, Lint.Replacement.replaceFromTo(end + 1, end + 1, \";\"));\n                    }\n            }\n        });\n    }\n}\nvar templateObject_1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/typeLiteralDelimiterRule.js\n// module id = 2148\n// module chunks = 38"],"sourceRoot":""}