{"version":3,"sources":["../node_modules/tslint/lib/rules/noInferredEmptyObjectTypeRule.js"],"names":["Object","defineProperty","exports","value","tslib_1","__webpack_require__","tsutils_1","ts","Lint","Rule","_super","apply","this","arguments","__extends","prototype","applyWithProgram","sourceFile","program","applyWithWalker","NoInferredEmptyObjectTypeRule","ruleName","getTypeChecker","metadata","description","optionsDescription","options","optionExamples","rationale","Utils","dedent","templateObject_1","__makeTemplateObject","type","typescriptOnly","requiresTypeInfo","EMPTY_INTERFACE_INSTANCE","EMPTY_INTERFACE_FUNCTION","Rules","TypedRule","checker","_this","call","undefined","walk","cb","node","kind","SyntaxKind","CallExpression","checkCallExpression","NewExpression","checkNewExpression","forEachChild","typeArguments","getTypeAtLocation","isTypeReference","some","a","isObjectType","isEmptyObjectInterface","addFailureAtNode","callSig","getResolvedSignature","retType","getReturnTypeOfSignature","objType","isObjectFlagSet","ObjectFlags","Anonymous","getProperties","length","getNumberIndexType","getStringIndexType","getCallSignatures","every","signature","AbstractWalker"],"mappings":"qDAiBAA,OAAAC,eAAAC,EAAA,cAA8CC,OAAA,IAC9C,IAAAC,EAAAC,EAAA,GACAC,EAAAD,EAAA,KACAE,EAAAF,EAAA,IACAG,EAAAH,EAAA,MACAI,EAAA,SAAAC,GAEA,SAAAD,IACA,cAAAC,KAAAC,MAAAC,KAAAC,YAAAD,KAoBA,OAtBAR,EAAAU,UAAAL,EAAAC,GAIAD,EAAAM,UAAAC,iBAAA,SAAAC,EAAAC,GACA,OAAAN,KAAAO,gBAAA,IAAAC,EAAAH,EAAAL,KAAAS,SAAAH,EAAAI,oBAGAb,EAAAc,UACAF,SAAA,gCACAG,YAAA,2FACAC,mBAAA,oBACAC,QAAA,KACAC,iBAAA,GACAC,UAAApB,EAAAqB,MAAAC,OAAAC,MAAA3B,EAAA4B,sBAAA,wQAAwQ,8QACxQC,KAAA,gBACAC,gBAAA,EACAC,kBAAA,GAGA1B,EAAA2B,yBAAA,kEACA3B,EAAA4B,yBAAA,oEACA5B,EAvBA,CAwBCD,EAAA8B,MAAAC,WACDrC,EAAAO,OACA,IAwDAsB,EAxDAX,EAAA,SAAAV,GAEA,SAAAU,EAAAH,EAAAI,EAAAmB,GACA,IAAAC,EAAA/B,EAAAgC,KAAA9B,KAAAK,EAAAI,OAAAsB,IAAA/B,KAEA,OADA6B,EAAAD,UACAC,EAiDA,OArDArC,EAAAU,UAAAM,EAAAV,GAMAU,EAAAL,UAAA6B,KAAA,SAAA3B,GACA,IAAAwB,EAAA7B,KACAiC,EAAA,SAAAC,GAOA,OANAA,EAAAC,OAAAxC,EAAAyC,WAAAC,eACAR,EAAAS,oBAAAJ,GAEAA,EAAAC,OAAAxC,EAAAyC,WAAAG,eACAV,EAAAW,mBAAAN,GAEAvC,EAAA8C,aAAAP,EAAAD,IAEA,OAAAtC,EAAA8C,aAAApC,EAAA4B,IAEAzB,EAAAL,UAAAqC,mBAAA,SAAAN,GACA,IAAAL,EAAA7B,KACA,QAAA+B,IAAAG,EAAAQ,cAAA,CACA,IAAArB,EAAArB,KAAA4B,QAAAe,kBAAAT,GACAxC,EAAAkD,gBAAAvB,SAAAU,IAAAV,EAAAqB,eACArB,EAAAqB,cAAAG,KAAA,SAAAC,GAAsD,OAAApD,EAAAqD,aAAAD,IAAAjB,EAAAmB,uBAAAF,MACtD9C,KAAAiD,iBAAAf,EAAArC,EAAA2B,4BAIAhB,EAAAL,UAAAmC,oBAAA,SAAAJ,GACA,QAAAH,IAAAG,EAAAQ,cAAA,CAGA,IAAAQ,EAAAlD,KAAA4B,QAAAuB,qBAAAjB,GACA,QAAAH,IAAAmB,EAAA,CAGA,IAAAE,EAAApD,KAAA4B,QAAAyB,yBAAAH,GACAxD,EAAAqD,aAAAK,IAAApD,KAAAgD,uBAAAI,IACApD,KAAAiD,iBAAAf,EAAArC,EAAA4B,6BAGAjB,EAAAL,UAAA6C,uBAAA,SAAAM,GACA,IAAAzB,EAAA7B,KACA,OAAAN,EAAA6D,gBAAAD,EAAA3D,EAAA6D,YAAAC,YACA,IAAAH,EAAAI,gBAAAC,aACA5B,IAAAuB,EAAAM,2BACA7B,IAAAuB,EAAAO,sBACAP,EAAAQ,oBAAAC,MAAA,SAAAC,GACA,IAAA3C,EAAAQ,EAAAD,QAAAyB,yBAAAW,GACA,OAAAtE,EAAAqD,aAAA1B,IAAAQ,EAAAmB,uBAAA3B,MAGAb,EAtDA,CAuDCZ,EAAAqE","file":"static/js/90.22046e2b.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2016 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        return this.applyWithWalker(new NoInferredEmptyObjectTypeRule(sourceFile, this.ruleName, program.getTypeChecker()));\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"no-inferred-empty-object-type\",\n        description: \"Disallow type inference of {} (empty object type) at function and constructor call sites\",\n        optionsDescription: \"Not configurable.\",\n        options: null,\n        optionExamples: [true],\n        rationale: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            When function or constructor may be called with a type parameter but one isn't supplied or inferrable,\\n            TypeScript defaults to `{}`.\\n            This is often undesirable as the call is meant to be of a more specific type.\\n        \"], [\"\\n            When function or constructor may be called with a type parameter but one isn't supplied or inferrable,\\n            TypeScript defaults to \\\\`{}\\\\`.\\n            This is often undesirable as the call is meant to be of a more specific type.\\n        \"]))),\n        type: \"functionality\",\n        typescriptOnly: true,\n        requiresTypeInfo: true,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.EMPTY_INTERFACE_INSTANCE = \"Explicit type parameter needs to be provided to the constructor\";\n    Rule.EMPTY_INTERFACE_FUNCTION = \"Explicit type parameter needs to be provided to the function call\";\n    return Rule;\n}(Lint.Rules.TypedRule));\nexports.Rule = Rule;\nvar NoInferredEmptyObjectTypeRule = /** @class */ (function (_super) {\n    tslib_1.__extends(NoInferredEmptyObjectTypeRule, _super);\n    function NoInferredEmptyObjectTypeRule(sourceFile, ruleName, checker) {\n        var _this = _super.call(this, sourceFile, ruleName, undefined) || this;\n        _this.checker = checker;\n        return _this;\n    }\n    NoInferredEmptyObjectTypeRule.prototype.walk = function (sourceFile) {\n        var _this = this;\n        var cb = function (node) {\n            if (node.kind === ts.SyntaxKind.CallExpression) {\n                _this.checkCallExpression(node);\n            }\n            else if (node.kind === ts.SyntaxKind.NewExpression) {\n                _this.checkNewExpression(node);\n            }\n            return ts.forEachChild(node, cb);\n        };\n        return ts.forEachChild(sourceFile, cb);\n    };\n    NoInferredEmptyObjectTypeRule.prototype.checkNewExpression = function (node) {\n        var _this = this;\n        if (node.typeArguments === undefined) {\n            var type = this.checker.getTypeAtLocation(node);\n            if (tsutils_1.isTypeReference(type) && type.typeArguments !== undefined &&\n                type.typeArguments.some(function (a) { return tsutils_1.isObjectType(a) && _this.isEmptyObjectInterface(a); })) {\n                this.addFailureAtNode(node, Rule.EMPTY_INTERFACE_INSTANCE);\n            }\n        }\n    };\n    NoInferredEmptyObjectTypeRule.prototype.checkCallExpression = function (node) {\n        if (node.typeArguments !== undefined) {\n            return;\n        }\n        var callSig = this.checker.getResolvedSignature(node);\n        if (callSig === undefined) {\n            return;\n        }\n        var retType = this.checker.getReturnTypeOfSignature(callSig);\n        if (tsutils_1.isObjectType(retType) && this.isEmptyObjectInterface(retType)) {\n            this.addFailureAtNode(node, Rule.EMPTY_INTERFACE_FUNCTION);\n        }\n    };\n    NoInferredEmptyObjectTypeRule.prototype.isEmptyObjectInterface = function (objType) {\n        var _this = this;\n        return tsutils_1.isObjectFlagSet(objType, ts.ObjectFlags.Anonymous) &&\n            objType.getProperties().length === 0 &&\n            objType.getNumberIndexType() === undefined &&\n            objType.getStringIndexType() === undefined &&\n            objType.getCallSignatures().every(function (signature) {\n                var type = _this.checker.getReturnTypeOfSignature(signature);\n                return tsutils_1.isObjectType(type) && _this.isEmptyObjectInterface(type);\n            });\n    };\n    return NoInferredEmptyObjectTypeRule;\n}(Lint.AbstractWalker));\nvar templateObject_1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/noInferredEmptyObjectTypeRule.js\n// module id = 2069\n// module chunks = 90"],"sourceRoot":""}