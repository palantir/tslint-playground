{"version":3,"sources":["../node_modules/tslint/lib/rules/importBlacklistRule.js"],"names":["Object","defineProperty","exports","value","templateObject_1","templateObject_2","tslib_1","__webpack_require__","tsutils_1","Lint","Rule","_super","apply","this","arguments","__extends","MAKE_NAMED_IMPORT_FAILURE_STRING","importName","prototype","isEnabled","call","ruleArguments","length","sourceFile","applyWithFunction","walk","metadata","ruleName","description","Utils","dedent","__makeTemplateObject","rationale","optionsDescription","options","type","items","oneOf","minLength","additionalProperties","minItems","optionExamples","lodash","typescriptOnly","WHOLE_MODULE_FAILURE_STRING","IMPLICIT_NAMED_IMPORT_FAILURE_STRING","Rules","AbstractRule","ctx","bannedImports","reduce","acc","it","keys","forEach","moduleName","Set","bannedImport","add","create","_i","_a","findImports","name","bansForModule","text","undefined","addFailure","getStart","end","parentNode","parent","importClause","isImportDeclaration","importsDefaultExport","Boolean","importsSpecificNamedExports","namedBindings","isNamedImports","reExportsSpecificNamedExports","isExportDeclaration","exportClause","toExportName","propertyName","_b","namedImportsOrReExports_1","concat","elements","map","has","addFailureAtNode"],"mappings":"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","file":"static/js/138.792d436c.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2018 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils_1 = require(\"tsutils\");\nvar Lint = require(\"../index\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.MAKE_NAMED_IMPORT_FAILURE_STRING = function (importName) {\n        return importName === \"default\"\n            ? \"Importing (or re-exporting) the default export is blacklisted.\"\n            : \"The export \\\"\" + importName + \"\\\" is blacklisted.\";\n    };\n    Rule.prototype.isEnabled = function () {\n        return _super.prototype.isEnabled.call(this) && this.ruleArguments.length > 0;\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk, this.ruleArguments);\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"import-blacklist\",\n        description: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            Disallows importing the specified modules via `import` and `require`,\\n            or importing specific named exports of the specified modules.\"], [\"\\n            Disallows importing the specified modules via \\\\`import\\\\` and \\\\`require\\\\`,\\n            or importing specific named exports of the specified modules.\"]))),\n        rationale: Lint.Utils.dedent(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject([\"\\n            For some libraries, importing the library directly can cause unused\\n            submodules to be loaded, so you may want to block these imports and\\n            require that users directly import only the submodules they need.\\n            In other cases, you may simply want to ban an import because using\\n            it is undesirable or unsafe.\"], [\"\\n            For some libraries, importing the library directly can cause unused\\n            submodules to be loaded, so you may want to block these imports and\\n            require that users directly import only the submodules they need.\\n            In other cases, you may simply want to ban an import because using\\n            it is undesirable or unsafe.\"]))),\n        optionsDescription: \"A list of blacklisted modules or named imports.\",\n        options: {\n            type: \"array\",\n            items: {\n                oneOf: [\n                    {\n                        type: \"string\",\n                        minLength: 1,\n                    },\n                    {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"array\",\n                            minItems: 1,\n                            items: {\n                                type: \"string\",\n                                minLength: 1,\n                            },\n                        },\n                    },\n                ],\n            },\n        },\n        optionExamples: [\n            true,\n            [true, \"rxjs\", \"lodash\"],\n            [true, \"lodash\", { lodash: [\"pull\", \"pullAll\"] }],\n        ],\n        type: \"functionality\",\n        typescriptOnly: false,\n    };\n    Rule.WHOLE_MODULE_FAILURE_STRING = \"Importing this module is blacklisted. Try importing a submodule instead.\";\n    Rule.IMPLICIT_NAMED_IMPORT_FAILURE_STRING = \"Some named exports from this module are blacklisted for importing \" +\n        \"(or re-exporting). Import/re-export only the specific values you want, \" +\n        \"instead of the whole module.\";\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nfunction walk(ctx) {\n    // Merge/normalize options.\n    // E.g., [\"a\", { \"b\": [\"c\"], \"d\": [\"e\", \"e\"] }, \"f\", { \"f\": [\"g\"] }]\n    // becomes { \"a\": true, \"b\": Set([\"c\"]), \"d\": Set([\"e\"]), \"f\": true }.\n    var bannedImports = ctx.options.reduce(function (acc, it) {\n        if (typeof it === \"string\") {\n            acc[it] = true;\n        }\n        else {\n            Object.keys(it).forEach(function (moduleName) {\n                if (acc[moduleName] instanceof Set) {\n                    it[moduleName].forEach(function (bannedImport) {\n                        acc[moduleName].add(bannedImport);\n                    });\n                }\n                else if (acc[moduleName] !== true) {\n                    acc[moduleName] = new Set(it[moduleName]);\n                }\n            });\n        }\n        return acc;\n    }, Object.create(null));\n    for (var _i = 0, _a = tsutils_1.findImports(ctx.sourceFile, 63 /* All */); _i < _a.length; _i++) {\n        var name = _a[_i];\n        // TODO #3963: Resolve/normalize relative file imports to a canonical path?\n        var importedModule = name.text;\n        var bansForModule = bannedImports[importedModule];\n        // Check if at least some imports from this module are banned.\n        if (bansForModule !== undefined) {\n            // If importing this module is totally banned, we can error now,\n            // without determining whether the user is importing the whole\n            // module or named exports.\n            if (bansForModule === true) {\n                ctx.addFailure(name.getStart(ctx.sourceFile) + 1, name.end - 1, Rule.WHOLE_MODULE_FAILURE_STRING);\n                continue;\n            }\n            // Otherwise, find the named imports, if any, and fail if the\n            // user tried to import any of them. We don't have named imports\n            // when the user is importing the whole module, which includes:\n            //\n            // - ImportKind.Require (i.e., `require('module-specifier')`),\n            // - ImportKind.DynamicImport (i.e., `import(\"module-specifier\")`),\n            // - ImportKind.ImportEquals (i.e., `import x = require()`),\n            // - and ImportKind.ImportDeclaration, where there's a full namespace\n            //   import (i.e. `import * as x from \"module-specifier\"`)\n            //\n            // However, namedImports will be an array when we have one of the\n            // various permutations of `import x, { a, b as c } from \"y\"`.\n            //\n            // We treat re-exports from other modules the same as attempting to\n            // import the re-exported binding(s), as the re-export is essentially\n            // an import followed by an export, and not treating these as an\n            // import would allow backdoor imports of the banned bindings. So,\n            // our last case is `ImportKind.ExportFrom`, and for that:\n            //\n            // - `export nameForDefault from \"module\"` isn't part of the ESM\n            // syntax (yet), so we only have to handle two cases below:\n            // `export { x } from \"y\"` and `export * from \"specifier\"`.\n            var parentNode = name.parent;\n            // Disable strict-boolean-expressions for the next few lines so our &&\n            // checks can help type inference figure out if when don't have undefined.\n            // tslint:disable strict-boolean-expressions\n            var importClause = parentNode && tsutils_1.isImportDeclaration(parentNode) ? parentNode.importClause : undefined;\n            var importsDefaultExport = importClause && Boolean(importClause.name);\n            // Below, check isNamedImports to rule out the\n            // `import * as ns from \"...\"` case.\n            var importsSpecificNamedExports = importClause &&\n                importClause.namedBindings &&\n                tsutils_1.isNamedImports(importClause.namedBindings);\n            // If parentNode is an ExportDeclaration, it must represent an\n            // `export from`, as findImports verifies that. Then, if exportClause\n            // is undefined, we're dealing with `export * from ...`.\n            var reExportsSpecificNamedExports = parentNode && tsutils_1.isExportDeclaration(parentNode) && Boolean(parentNode.exportClause);\n            // tslint:enable strict-boolean-expressions\n            if (importsDefaultExport ||\n                importsSpecificNamedExports ||\n                reExportsSpecificNamedExports) {\n                // Add an import for the default import and any named bindings.\n                // For the named bindings, we use the name of the export from the\n                // module (i.e., .propertyName) over its alias in the import when\n                // the two diverge.\n                var toExportName = function (it) {\n                    return (it.propertyName || it.name).text;\n                }; // tslint:disable-line strict-boolean-expressions\n                var exportClause = reExportsSpecificNamedExports\n                    ? parentNode.exportClause\n                    : undefined;\n                var namedImportsOrReExports = (importsDefaultExport ? [\"default\"] : []).concat((importsSpecificNamedExports\n                    ? importClause.namedBindings.elements.map(toExportName)\n                    : []), (exportClause !== undefined ? exportClause.elements.map(toExportName) : []));\n                for (var _b = 0, namedImportsOrReExports_1 = namedImportsOrReExports; _b < namedImportsOrReExports_1.length; _b++) {\n                    var importName = namedImportsOrReExports_1[_b];\n                    if (bansForModule.has(importName)) {\n                        ctx.addFailureAtNode(exportClause !== undefined ? exportClause : importClause, Rule.MAKE_NAMED_IMPORT_FAILURE_STRING(importName));\n                    }\n                }\n            }\n            else {\n                // If we're here, the user tried to import/re-export the whole module\n                ctx.addFailure(name.getStart(ctx.sourceFile) + 1, name.end - 1, Rule.IMPLICIT_NAMED_IMPORT_FAILURE_STRING);\n            }\n        }\n    }\n}\nvar templateObject_1, templateObject_2;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/importBlacklistRule.js\n// module id = 2033\n// module chunks = 138"],"sourceRoot":""}