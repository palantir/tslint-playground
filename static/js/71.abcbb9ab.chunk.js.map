{"version":3,"sources":["../node_modules/tslint/lib/rules/noUnnecessaryQualifierRule.js"],"names":["Object","defineProperty","exports","value","tslib_1","__webpack_require__","utils","ts","Lint","Rule","_super","apply","this","arguments","__extends","FAILURE_STRING","name","prototype","applyWithProgram","sourceFile","program","applyWithFunction","walk","undefined","getTypeChecker","metadata","ruleName","description","hasFix","optionsDescription","options","optionExamples","type","typescriptOnly","requiresTypeInfo","Rules","TypedRule","ctx","checker","namespacesInScope","cb","node","kind","SyntaxKind","ModuleDeclaration","EnumDeclaration","push","forEachChild","pop","QualifiedName","_a","visitNamespaceAccess","left","right","PropertyAccessExpression","_b","expression","isEntityNameExpression","qualifier","namespaceSymbol","getSymbolAtLocation","symbolIsNamespaceInScope","symbol","symbolDeclarations","getDeclarations","some","decl","ns","alias","isSymbolFlagSet","SymbolFlags","Alias","getAliasedSymbol","tryGetAliasedSymbol","accessedSymbol","fromScope","flags","getSymbolsInScope","find","scopeSymbol","getSymbolInScope","text","accessed","inScope","getExportSymbolOfSymbol","Utils","arraysAreEqual","declarations","a","b","symbolsAreEqual","qualifierIsUnnecessary","fix","Replacement","deleteFromTo","getStart","addFailureAtNode","getText"],"mappings":"qDAiBAA,OAAAC,eAAAC,EAAA,cAA8CC,OAAA,IAC9C,IAAAC,EAAAC,EAAA,GACAC,EAAAD,EAAA,KACAE,EAAAF,EAAA,IACAG,EAAAH,EAAA,MACAI,EAAA,SAAAC,GAEA,SAAAD,IACA,cAAAC,KAAAC,MAAAC,KAAAC,YAAAD,KAqBA,OAvBAR,EAAAU,UAAAL,EAAAC,GAKAD,EAAAM,eAAA,SAAAC,GACA,yCAAAA,EAAA,kBAEAP,EAAAQ,UAAAC,iBAAA,SAAAC,EAAAC,GACA,OAAAR,KAAAS,kBAAAF,EAAAG,OAAAC,EAAAH,EAAAI,mBAGAf,EAAAgB,UACAC,SAAA,2BACAC,YAAA,2DACAC,QAAA,EACAC,mBAAA,oBACAC,QAAA,KACAC,iBAAA,GACAC,KAAA,QACAC,gBAAA,EACAC,kBAAA,GAEAzB,EAxBA,CAyBCD,EAAA2B,MAAAC,WAED,SAAAd,EAAAe,EAAAC,GACA,IAAAC,KAEA,SAAAC,EAAAC,GACA,OAAAA,EAAAC,MACA,KAAAnC,EAAAoC,WAAAC,kBACA,KAAArC,EAAAoC,WAAAE,gBACAN,EAAAO,KAAAL,GACAlC,EAAAwC,aAAAN,EAAAD,GACAD,EAAAS,MACA,MACA,KAAAzC,EAAAoC,WAAAM,cACA,IAAAC,EAAAT,EACAU,EAAAV,EADAS,EAAAE,KAAAF,EAAAG,OAEA,MACA,KAAA9C,EAAAoC,WAAAW,yBACA,IAAAC,EAAAd,EAAAe,EAAAD,EAAAC,WAAAxC,EAAAuC,EAAAvC,KACA,GAAAV,EAAAmD,uBAAAD,GAAA,CACAL,EAAAV,EAAAe,EAAAxC,GACA,MAGA,QACAT,EAAAwC,aAAAN,EAAAD,IAGA,SAAAW,EAAAV,EAAAiB,EAAA1C,GACA,GASA,SAAA0C,EAAA1C,GACA,IAAA2C,EAAArB,EAAAsB,oBAAAF,GACA,QAAAnC,IAAAoC,IAgBA,SAAAE,EAAAC,GACA,IAAAC,EAAAD,EAAAE,kBACA,QAAAzC,IAAAwC,EACA,SAEA,GAAAA,EAAAE,KAAA,SAAAC,GAA0D,OAAA3B,EAAA0B,KAAA,SAAAE,GAA8C,OAAAA,IAAAD,MACxG,SAEA,IAAAE,EAaA,SAAAN,EAAAxB,GACA,OAAAhC,EAAA+D,gBAAAP,EAAAvD,EAAA+D,YAAAC,OACAjC,EAAAkC,iBAAAV,QACAvC,EAhBAkD,CAAAX,EAAAxB,GACA,YAAAf,IAAA6C,GAAAP,EAAAO,GAzBAP,CAAAF,GACA,SAEA,IAAAe,EAAApC,EAAAsB,oBAAA5C,GACA,QAAAO,IAAAmD,EACA,SAGA,IAAAC,EAGA,SAAAlC,EAAAmC,EAAA5D,GAGA,OADAsB,EAAAuC,kBAAApC,EAAAmC,GACAE,KAAA,SAAAC,GAAkD,OAAAA,EAAA/D,WANlDgE,CAAAtB,EAAAgB,EAAAE,MAAA5D,EAAAiE,MACA,YAAA1D,IAAAoD,GAkBA,SAAAO,EAAAC,GACA,QAAA5D,IAAAe,EAAA8C,wBAEA,OADAD,EAAA7C,EAAA8C,wBAAAD,GACAD,IAAAC,EAEA,OAAAD,IAAAC,GAEA3E,EAAA6E,MAAAC,eAAAJ,EAAAK,aAAAJ,EAAAI,aAAA,SAAAC,EAAAC,GAAoG,OAAAD,IAAAC,IAzBpGC,CAAAhB,EAAAC,GApBAgB,CAAAjC,EAAA1C,GAAA,CACA,IAAA4E,EAAApF,EAAAqF,YAAAC,aAAApC,EAAAqC,WAAA/E,EAAA+E,YACA1D,EAAA2D,iBAAAtC,EAAAjD,EAAAM,eAAA2C,EAAAuC,WAAAL,QAIArF,EAAAwC,aAAAN,EAAAD,GA/BAjC,EAAAwC,aAAAV,EAAAlB,WAAAqB,GAHAtC,EAAAO","file":"static/js/71.abcbb9ab.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = function (name) {\n        return \"Qualifier is unnecessary since '\" + name + \"' is in scope.\";\n    };\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        return this.applyWithFunction(sourceFile, walk, undefined, program.getTypeChecker());\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"no-unnecessary-qualifier\",\n        description: \"Warns when a namespace qualifier (`A.x`) is unnecessary.\",\n        hasFix: true,\n        optionsDescription: \"Not configurable.\",\n        options: null,\n        optionExamples: [true],\n        type: \"style\",\n        typescriptOnly: true,\n        requiresTypeInfo: true,\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\nexports.Rule = Rule;\nfunction walk(ctx, checker) {\n    var namespacesInScope = [];\n    ts.forEachChild(ctx.sourceFile, cb);\n    function cb(node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.ModuleDeclaration:\n            case ts.SyntaxKind.EnumDeclaration:\n                namespacesInScope.push(node);\n                ts.forEachChild(node, cb);\n                namespacesInScope.pop();\n                break;\n            case ts.SyntaxKind.QualifiedName:\n                var _a = node, left = _a.left, right = _a.right;\n                visitNamespaceAccess(node, left, right);\n                break;\n            case ts.SyntaxKind.PropertyAccessExpression:\n                var _b = node, expression = _b.expression, name = _b.name;\n                if (utils.isEntityNameExpression(expression)) {\n                    visitNamespaceAccess(node, expression, name);\n                    break;\n                }\n            // falls through\n            default:\n                ts.forEachChild(node, cb);\n        }\n    }\n    function visitNamespaceAccess(node, qualifier, name) {\n        if (qualifierIsUnnecessary(qualifier, name)) {\n            var fix = Lint.Replacement.deleteFromTo(qualifier.getStart(), name.getStart());\n            ctx.addFailureAtNode(qualifier, Rule.FAILURE_STRING(qualifier.getText()), fix);\n        }\n        else {\n            // Only look for nested qualifier errors if we didn't already fail on the outer qualifier.\n            ts.forEachChild(node, cb);\n        }\n    }\n    function qualifierIsUnnecessary(qualifier, name) {\n        var namespaceSymbol = checker.getSymbolAtLocation(qualifier);\n        if (namespaceSymbol === undefined || !symbolIsNamespaceInScope(namespaceSymbol)) {\n            return false;\n        }\n        var accessedSymbol = checker.getSymbolAtLocation(name);\n        if (accessedSymbol === undefined) {\n            return false;\n        }\n        // If the symbol in scope is different, the qualifier is necessary.\n        var fromScope = getSymbolInScope(qualifier, accessedSymbol.flags, name.text);\n        return fromScope === undefined || symbolsAreEqual(accessedSymbol, fromScope);\n    }\n    function getSymbolInScope(node, flags, name) {\n        // TODO:PERF `getSymbolsInScope` gets a long list. Is there a better way?\n        var scope = checker.getSymbolsInScope(node, flags);\n        return scope.find(function (scopeSymbol) { return scopeSymbol.name === name; });\n    }\n    function symbolIsNamespaceInScope(symbol) {\n        var symbolDeclarations = symbol.getDeclarations();\n        if (symbolDeclarations === undefined) {\n            return false;\n        }\n        else if (symbolDeclarations.some(function (decl) { return namespacesInScope.some(function (ns) { return ns === decl; }); })) {\n            return true;\n        }\n        var alias = tryGetAliasedSymbol(symbol, checker);\n        return alias !== undefined && symbolIsNamespaceInScope(alias);\n    }\n    function symbolsAreEqual(accessed, inScope) {\n        if (checker.getExportSymbolOfSymbol !== undefined) {\n            inScope = checker.getExportSymbolOfSymbol(inScope);\n            return accessed === inScope;\n        }\n        return (accessed === inScope ||\n            // For compatibility with typescript@2.5: compare declarations because the symbols don't have the same reference\n            Lint.Utils.arraysAreEqual(accessed.declarations, inScope.declarations, function (a, b) { return a === b; }));\n    }\n}\nfunction tryGetAliasedSymbol(symbol, checker) {\n    return utils.isSymbolFlagSet(symbol, ts.SymbolFlags.Alias)\n        ? checker.getAliasedSymbol(symbol)\n        : undefined;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/noUnnecessaryQualifierRule.js\n// module id = 2106\n// module chunks = 71"],"sourceRoot":""}