{"version":3,"sources":["../node_modules/tslint/lib/rules/callableTypesRule.js"],"names":["Object","defineProperty","exports","value","tslib_1","__webpack_require__","tsutils_1","ts","Lint","Rule","_super","apply","this","arguments","__extends","FAILURE_STRING_FACTORY","type","sigSuggestion","prototype","sourceFile","applyWithFunction","walk","metadata","ruleName","description","rationale","optionsDescription","options","typescriptOnly","hasFix","Rules","AbstractRule","ctx","forEachChild","cb","node","isInterfaceDeclaration","undefined","heritageClauses","length","expr","types","expression","isIdentifier","text","noSupertype","isTypeLiteralNode","members","member","isConstructSignatureDeclaration","isCallSignatureDeclaration","suggestion","call","parent","start","getStart","colonPos","pos","substring","end","substr","kind","SyntaxKind","UnionType","IntersectionType","ArrayType","shouldWrapSuggestion","InterfaceDeclaration","typeParameters","name","endsWith","slice","renderSuggestion","fixStart","TypeLiteral","getChildOfKind","InterfaceKeyword","addFailureAtNode","Replacement","replaceFromTo"],"mappings":"sDAiBAA,OAAAC,eAAAC,EAAA,cAA8CC,OAAA,IAC9C,IAAAC,EAAAC,EAAA,GACAC,EAAAD,EAAA,KACAE,EAAAF,EAAA,IACAG,EAAAH,EAAA,MACAI,EAAA,SAAAC,GAEA,SAAAD,IACA,cAAAC,KAAAC,MAAAC,KAAAC,YAAAD,KAoBA,OAtBAR,EAAAU,UAAAL,EAAAC,GAKAD,EAAAM,uBAAA,SAAAC,EAAAC,GACA,OAAAD,EAAA,0CAAAC,EAAA,cAEAR,EAAAS,UAAAP,MAAA,SAAAQ,GACA,OAAAP,KAAAQ,kBAAAD,EAAAE,IAGAZ,EAAAa,UACAC,SAAA,iBACAC,YAAA,6FACAC,UAAA,QACAC,mBAAA,oBACAC,QAAA,KACAX,KAAA,QACAY,gBAAA,EACAC,QAAA,GAEApB,EAvBA,CAwBCD,EAAAsB,MAAAC,cAED,SAAAV,EAAAW,GACA,OAAAzB,EAAA0B,aAAAD,EAAAb,WAAA,SAAAe,EAAAC,GACA,IAAA7B,EAAA8B,uBAAAD,IAiBA,SAAAA,GACA,QAAAE,IAAAF,EAAAG,gBACA,SAEA,OAAAH,EAAAG,gBAAAC,OACA,SAEA,IAAAC,EAAAL,EAAAG,gBAAA,GAAAG,MAAA,GAAAC,WACA,OAAApC,EAAAqC,aAAAH,IAAA,aAAAA,EAAAI,KAzBAC,CAAAV,IAAA7B,EAAAwC,kBAAAX,KACA,IAAAA,EAAAY,QAAAR,OAAA,CACA,IAAAS,EAAAb,EAAAY,QAAA,GACA,IAAAzC,EAAA2C,gCAAAD,IAAA1C,EAAA4C,2BAAAF,UAEAX,IAAAW,EAAAhC,KAAA,CACA,IAAAmC,EAqBA,SAAAC,EAAAC,EAAAlC,GACA,IAAAmC,EAAAF,EAAAG,SAAApC,GACAqC,EAAAJ,EAAApC,KAAAyC,IAAA,EAAAH,EACAV,EAAAzB,EAAAyB,KAAAc,UAAAJ,EAAAF,EAAAO,KACAR,EAAAP,EAAAgB,OAAA,EAAAJ,GAAA,MAAAZ,EAAAgB,OAAAJ,EAAA,IAcA,SAAAH,GACA,OAAAA,EAAAQ,MACA,KAAAtD,EAAAuD,WAAAC,UACA,KAAAxD,EAAAuD,WAAAE,iBACA,KAAAzD,EAAAuD,WAAAG,UACA,SACA,QACA,WApBAC,CAAAb,YACAF,EAAA,IAAAA,EAAA,KAEA,GAAAE,EAAAQ,OAAAtD,EAAAuD,WAAAK,qBACA,YAAA9B,IAAAgB,EAAAe,eACA,OAAAjD,EAAAyB,KAAAc,UAAAL,EAAAgB,KAAAZ,IAAAJ,EAAAe,eAAAT,IAAA,SAAAR,EAGA,QAAAE,EAAAgB,KAAAzB,KAAA,MAAAO,EAGA,OAAAA,EAAAmB,SAAA,KAAiCnB,EAAAoB,MAAA,MAAApB,EArCjCqB,CAAAxB,EAAAb,EAAAH,EAAAb,YACAsD,EAAAtC,EAAA0B,OAAAtD,EAAAuD,WAAAY,YACAvC,EAAAoB,SAAAvB,EAAAb,YACAb,EAAAqE,eAAAxC,EAAA5B,EAAAuD,WAAAc,kBAAArB,SAAAvB,EAAAb,YACAa,EAAA6C,iBAAA7B,EAAAvC,EAAAM,uBAAAoB,EAAA0B,OAAAtD,EAAAuD,WAAAY,YAAA,2BAAAvB,GAAA3C,EAAAsE,YAAAC,cAAAN,EAAAtC,EAAAwB,IAAAR,KAGA,OAAA5C,EAAA0B,aAAAE,EAAAD,KAhBAhC,EAAAO","file":"static/js/148.1466ab84.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING_FACTORY = function (type, sigSuggestion) {\n        return type + \" has only a call signature \\u2014 use `\" + sigSuggestion + \"` instead.\";\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"callable-types\",\n        description: \"An interface or literal type with just a call signature can be written as a function type.\",\n        rationale: \"style\",\n        optionsDescription: \"Not configurable.\",\n        options: null,\n        type: \"style\",\n        typescriptOnly: true,\n        hasFix: true,\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (((tsutils_1.isInterfaceDeclaration(node) && noSupertype(node)) || tsutils_1.isTypeLiteralNode(node)) &&\n            node.members.length === 1) {\n            var member = node.members[0];\n            if ((tsutils_1.isConstructSignatureDeclaration(member) || tsutils_1.isCallSignatureDeclaration(member)) &&\n                // avoid bad parse\n                member.type !== undefined) {\n                var suggestion = renderSuggestion(member, node, ctx.sourceFile);\n                var fixStart = node.kind === ts.SyntaxKind.TypeLiteral\n                    ? node.getStart(ctx.sourceFile)\n                    : tsutils_1.getChildOfKind(node, ts.SyntaxKind.InterfaceKeyword).getStart(ctx.sourceFile);\n                ctx.addFailureAtNode(member, Rule.FAILURE_STRING_FACTORY(node.kind === ts.SyntaxKind.TypeLiteral ? \"Type literal\" : \"Interface\", suggestion), Lint.Replacement.replaceFromTo(fixStart, node.end, suggestion));\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n}\n/** True if there is no supertype or if the supertype is `Function`. */\nfunction noSupertype(node) {\n    if (node.heritageClauses === undefined) {\n        return true;\n    }\n    if (node.heritageClauses.length !== 1) {\n        return false;\n    }\n    var expr = node.heritageClauses[0].types[0].expression;\n    return tsutils_1.isIdentifier(expr) && expr.text === \"Function\";\n}\nfunction renderSuggestion(call, parent, sourceFile) {\n    var start = call.getStart(sourceFile);\n    var colonPos = call.type.pos - 1 - start;\n    var text = sourceFile.text.substring(start, call.end);\n    var suggestion = text.substr(0, colonPos) + \" =>\" + text.substr(colonPos + 1);\n    if (shouldWrapSuggestion(parent.parent)) {\n        suggestion = \"(\" + suggestion + \")\";\n    }\n    if (parent.kind === ts.SyntaxKind.InterfaceDeclaration) {\n        if (parent.typeParameters !== undefined) {\n            return \"type\" + sourceFile.text.substring(parent.name.pos, parent.typeParameters.end + 1) + \" = \" + suggestion;\n        }\n        else {\n            return \"type \" + parent.name.text + \" = \" + suggestion;\n        }\n    }\n    return suggestion.endsWith(\";\") ? suggestion.slice(0, -1) : suggestion;\n}\nfunction shouldWrapSuggestion(parent) {\n    switch (parent.kind) {\n        case ts.SyntaxKind.UnionType:\n        case ts.SyntaxKind.IntersectionType:\n        case ts.SyntaxKind.ArrayType:\n            return true;\n        default:\n            return false;\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/callableTypesRule.js\n// module id = 2020\n// module chunks = 148"],"sourceRoot":""}