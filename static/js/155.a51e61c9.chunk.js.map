{"version":3,"sources":["../node_modules/tslint/lib/rules/arrayTypeRule.js"],"names":["Object","defineProperty","exports","value","templateObject_1","tslib_1","__webpack_require__","ts","Lint","Rule","_super","apply","this","arguments","__extends","prototype","sourceFile","applyWithFunction","walk","ruleArguments","metadata","ruleName","description","hasFix","optionsDescription","Utils","dedent","__makeTemplateObject","options","type","enum","optionExamples","typescriptOnly","FAILURE_STRING_ARRAY","FAILURE_STRING_GENERIC","FAILURE_STRING_ARRAY_SIMPLE","FAILURE_STRING_GENERIC_SIMPLE","Rules","AbstractRule","ctx","option","forEachChild","cb","node","kind","SyntaxKind","ArrayType","elementType","parent","isSimpleType","failureString","parens","ParenthesizedType","space","AsExpression","getStart","getFullStart","fix","Replacement","replaceFromTo","getEnd","addFailureAtNode","checkArrayType","TypeReference","typeName","typeArguments","name","Identifier","text","undefined","length","UnionType","FunctionType","IntersectionType","TypeOperator","typeNeedsParentheses","checkTypeReference","nodeType","AnyKeyword","BooleanKeyword","NullKeyword","ObjectKeyword","UndefinedKeyword","NumberKeyword","StringKeyword","SymbolKeyword","VoidKeyword","NeverKeyword","ThisType","_a"],"mappings":"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","file":"static/js/155.a51e61c9.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2018 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_ARRAY = \"array\";\nvar OPTION_GENERIC = \"generic\";\nvar OPTION_ARRAY_SIMPLE = \"array-simple\";\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk, this.ruleArguments[0]);\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"array-type\",\n        description: \"Requires using either 'T[]' or 'Array<T>' for arrays.\",\n        hasFix: true,\n        optionsDescription: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            One of the following arguments must be provided:\\n\\n            * `\\\"\", \"\\\"` enforces use of `T[]` for all types T.\\n            * `\\\"\", \"\\\"` enforces use of `Array<T>` for all types T.\\n            * `\\\"\", \"\\\"` enforces use of `T[]` if `T` is a simple type (primitive or type reference).\"], [\"\\n            One of the following arguments must be provided:\\n\\n            * \\\\`\\\"\", \"\\\"\\\\` enforces use of \\\\`T[]\\\\` for all types T.\\n            * \\\\`\\\"\", \"\\\"\\\\` enforces use of \\\\`Array<T>\\\\` for all types T.\\n            * \\\\`\\\"\", \"\\\"\\\\` enforces use of \\\\`T[]\\\\` if \\\\`T\\\\` is a simple type (primitive or type reference).\"])), OPTION_ARRAY, OPTION_GENERIC, OPTION_ARRAY_SIMPLE),\n        options: {\n            type: \"string\",\n            enum: [OPTION_ARRAY, OPTION_GENERIC, OPTION_ARRAY_SIMPLE],\n        },\n        optionExamples: [[true, OPTION_ARRAY], [true, OPTION_GENERIC], [true, OPTION_ARRAY_SIMPLE]],\n        type: \"style\",\n        typescriptOnly: true,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING_ARRAY = \"Array type using 'Array<T>' is forbidden. Use 'T[]' instead.\";\n    Rule.FAILURE_STRING_GENERIC = \"Array type using 'T[]' is forbidden. Use 'Array<T>' instead.\";\n    Rule.FAILURE_STRING_ARRAY_SIMPLE = \"Array type using 'Array<T>' is forbidden for simple types. Use 'T[]' instead.\";\n    Rule.FAILURE_STRING_GENERIC_SIMPLE = \"Array type using 'T[]' is forbidden for non-simple types. Use 'Array<T>' instead.\";\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var sourceFile = ctx.sourceFile, option = ctx.options;\n    return ts.forEachChild(sourceFile, function cb(node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.ArrayType:\n                checkArrayType(node);\n                break;\n            case ts.SyntaxKind.TypeReference:\n                checkTypeReference(node);\n        }\n        return ts.forEachChild(node, cb);\n    });\n    function checkArrayType(node) {\n        var elementType = node.elementType, parent = node.parent;\n        if (option === \"array\" || (option === \"array-simple\" && isSimpleType(elementType))) {\n            return;\n        }\n        var failureString = option === \"generic\" ? Rule.FAILURE_STRING_GENERIC : Rule.FAILURE_STRING_GENERIC_SIMPLE;\n        var parens = elementType.kind === ts.SyntaxKind.ParenthesizedType ? 1 : 0;\n        // Add a space if the type is preceded by 'as' and the node has no leading whitespace\n        var space = parens === 0 &&\n            parent.kind === ts.SyntaxKind.AsExpression &&\n            node.getStart() === node.getFullStart();\n        var fix = [\n            new Lint.Replacement(elementType.getStart(), parens, (space ? \" \" : \"\") + \"Array<\"),\n            // Delete the square brackets and replace with an angle bracket\n            Lint.Replacement.replaceFromTo(elementType.getEnd() - parens, node.getEnd(), \">\"),\n        ];\n        ctx.addFailureAtNode(node, failureString, fix);\n    }\n    function checkTypeReference(node) {\n        var typeName = node.typeName, typeArguments = node.typeArguments;\n        if (option === \"generic\" || !isArrayIdentifier(typeName)) {\n            return;\n        }\n        var failureString = option === \"array\" ? Rule.FAILURE_STRING_ARRAY : Rule.FAILURE_STRING_ARRAY_SIMPLE;\n        if (typeArguments === undefined || typeArguments.length === 0) {\n            // Create an 'any' array\n            ctx.addFailureAtNode(node, failureString, Lint.Replacement.replaceFromTo(node.getStart(), node.getEnd(), \"any[]\"));\n            return;\n        }\n        if (typeArguments.length !== 1 ||\n            (option === \"array-simple\" && !isSimpleType(typeArguments[0]))) {\n            return;\n        }\n        var type = typeArguments[0];\n        var parens = typeNeedsParentheses(type);\n        ctx.addFailureAtNode(node, failureString, [\n            // Delete 'Array<'\n            Lint.Replacement.replaceFromTo(node.getStart(), type.getStart(), parens ? \"(\" : \"\"),\n            // Delete '>' and replace with '[]\n            Lint.Replacement.replaceFromTo(type.getEnd(), node.getEnd(), parens ? \")[]\" : \"[]\"),\n        ]);\n    }\n}\nfunction typeNeedsParentheses(type) {\n    switch (type.kind) {\n        case ts.SyntaxKind.UnionType:\n        case ts.SyntaxKind.FunctionType:\n        case ts.SyntaxKind.IntersectionType:\n        case ts.SyntaxKind.TypeOperator:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isArrayIdentifier(name) {\n    return name.kind === ts.SyntaxKind.Identifier && name.text === \"Array\";\n}\nfunction isSimpleType(nodeType) {\n    switch (nodeType.kind) {\n        case ts.SyntaxKind.AnyKeyword:\n        case ts.SyntaxKind.ArrayType:\n        case ts.SyntaxKind.BooleanKeyword:\n        case ts.SyntaxKind.NullKeyword:\n        case ts.SyntaxKind.ObjectKeyword:\n        case ts.SyntaxKind.UndefinedKeyword:\n        case ts.SyntaxKind.NumberKeyword:\n        case ts.SyntaxKind.StringKeyword:\n        case ts.SyntaxKind.SymbolKeyword:\n        case ts.SyntaxKind.VoidKeyword:\n        case ts.SyntaxKind.NeverKeyword:\n        case ts.SyntaxKind.ThisType:\n            return true;\n        case ts.SyntaxKind.TypeReference:\n            // TypeReferences must be non-generic or be another Array with a simple type\n            var _a = nodeType, typeName = _a.typeName, typeArguments = _a.typeArguments;\n            if (typeArguments === undefined) {\n                return true;\n            }\n            switch (typeArguments.length) {\n                case 0:\n                    return true;\n                case 1:\n                    return (typeName.kind === ts.SyntaxKind.Identifier &&\n                        typeName.text === \"Array\" &&\n                        isSimpleType(typeArguments[0]));\n                default:\n                    return false;\n            }\n        default:\n            return false;\n    }\n}\nvar templateObject_1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/arrayTypeRule.js\n// module id = 2011\n// module chunks = 155"],"sourceRoot":""}