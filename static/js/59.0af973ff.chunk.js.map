{"version":3,"sources":["../node_modules/tslint/lib/rules/noUnsafeAnyRule.js"],"names":["Object","defineProperty","exports","value","tslib_1","__webpack_require__","tsutils_1","ts","Lint","utils_1","Rule","_super","apply","this","arguments","__extends","prototype","applyWithProgram","sourceFile","program","applyWithWalker","NoUnsafeAnyWalker","ruleName","getTypeChecker","metadata","description","Utils","dedent","templateObject_1","__makeTemplateObject","optionsDescription","options","optionExamples","rationale","templateObject_2","type","typescriptOnly","requiresTypeInfo","FAILURE_STRING","Rules","TypedRule","checker","_this","call","undefined","visitNodeCallback","node","visitNode","walk","isDeclarationFile","statements","forEach","anyOk","kind","SyntaxKind","ParenthesizedExpression","expression","LabeledStatement","statement","BreakStatement","ContinueStatement","InterfaceDeclaration","TypeAliasDeclaration","TypeParameter","IndexSignature","ImportEqualsDeclaration","ImportDeclaration","ExportDeclaration","ExportAssignment","ThisKeyword","Identifier","check","DeleteExpression","ExpressionStatement","TypeAssertionExpression","AsExpression","TemplateSpan","ThrowStatement","TypeOfExpression","VoidExpression","PropertyAssignment","_a","name","initializer","isReassignmentTarget","parent","checkContextualType","ShorthandPropertyAssignment","_b","objectAssignmentInitializer","PropertyDeclaration","_c","isNodeAny","ComputedPropertyName","_i","getBaseTypes","getTypeAtLocation","length","base","prop","getProperty","text","declarations","isAny","getTypeOfSymbolAtLocation","isPropertyAny","SpreadAssignment","TaggedTemplateExpression","_d","tag","template","TemplateExpression","_e","templateSpans","CallExpression","NewExpression","_f","args","_g","args_1","arg","PropertyAccessExpression","ElementAccessExpression","_h","argumentExpression","ReturnStatement","SwitchStatement","_j","clauses","caseBlock","_k","clauses_1","clause","CaseClause","_l","_m","ModuleDeclaration","body","IfStatement","_o","thenStatement","elseStatement","PrefixUnaryExpression","_p","operator","operand","ExclamationToken","ForStatement","_q","condition","incrementor","DoStatement","WhileStatement","ConditionalExpression","_r","whenTrue","whenFalse","left","VariableDeclaration","Parameter","checkVariableOrParameterDeclaration","BinaryExpression","checkBinaryExpression","AwaitExpression","YieldExpression","checkYieldExpression","ClassExpression","ClassDeclaration","checkClassLikeDeclaration","ArrayLiteralExpression","_s","_t","elements","element","JsxExpression","isTypeNodeKind","isTokenKind","forEachChild","addFailureAtNode","allowIfNoContextualType","getContextualType","checkBindingName","AnyKeyword","allowAnyLeft","allowAnyRight","operatorToken","ExclamationEqualsEqualsToken","ExclamationEqualsToken","EqualsEqualsEqualsToken","EqualsEqualsToken","CommaToken","BarBarToken","AmpersandAmpersandToken","InstanceOfKeyword","EqualsToken","PlusToken","PlusEqualsToken","isStringLike","right","decorators","heritageClauses","members","OmittedExpression","propertyName","AbstractWalker","symbol","getSymbolAtLocation","isSymbolFlagSet","SymbolFlags","Alias","getAliasedSymbol","NamespaceModule","Type","getDeclaredTypeOfSymbol","isIdentifier","jsxElementTypes","has","isLowerCase","isJsxNativeElement","Set","JsxClosingElement","JsxOpeningElement","JsxSelfClosingElement","expr","isTypeFlagSet","TypeFlags","StringLike","Any"],"mappings":"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","file":"static/js/59.0af973ff.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar utils_1 = require(\"../utils\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        return this.applyWithWalker(new NoUnsafeAnyWalker(sourceFile, this.ruleName, program.getTypeChecker()));\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"no-unsafe-any\",\n        description: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            Warns when using an expression of type 'any' in a dynamic way.\\n            Uses are only allowed if they would work for `{} | null | undefined`.\\n            Type casts and tests are allowed.\\n            Expressions that work on all values (such as `\\\"\\\" + x`) are allowed.\"], [\"\\n            Warns when using an expression of type 'any' in a dynamic way.\\n            Uses are only allowed if they would work for \\\\`{} | null | undefined\\\\`.\\n            Type casts and tests are allowed.\\n            Expressions that work on all values (such as \\\\`\\\"\\\" + x\\\\`) are allowed.\"]))),\n        optionsDescription: \"Not configurable.\",\n        options: null,\n        optionExamples: [true],\n        rationale: Lint.Utils.dedent(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject([\"\\n            If you're dealing with data of unknown or \\\"any\\\" types, you shouldn't be accessing members of it.\\n            Either add type annotations for properties that may exist or change the data type to the empty object type `{}`.\\n\\n            Alternately, if you're creating storage or handling for consistent but unknown types, such as in data structures\\n            or serialization, use `<T>` template types for generic type handling.\\n\\n            Also see the `no-any` rule.\\n        \"], [\"\\n            If you're dealing with data of unknown or \\\"any\\\" types, you shouldn't be accessing members of it.\\n            Either add type annotations for properties that may exist or change the data type to the empty object type \\\\`{}\\\\`.\\n\\n            Alternately, if you're creating storage or handling for consistent but unknown types, such as in data structures\\n            or serialization, use \\\\`<T>\\\\` template types for generic type handling.\\n\\n            Also see the \\\\`no-any\\\\` rule.\\n        \"]))),\n        type: \"functionality\",\n        typescriptOnly: true,\n        requiresTypeInfo: true,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = \"Unsafe use of expression of type 'any'.\";\n    return Rule;\n}(Lint.Rules.TypedRule));\nexports.Rule = Rule;\nvar NoUnsafeAnyWalker = /** @class */ (function (_super) {\n    tslib_1.__extends(NoUnsafeAnyWalker, _super);\n    function NoUnsafeAnyWalker(sourceFile, ruleName, checker) {\n        var _this = _super.call(this, sourceFile, ruleName, undefined) || this;\n        _this.checker = checker;\n        /** Wraps `visitNode` with the correct `this` binding and discards the return value to prevent `forEachChild` from returning early */\n        _this.visitNodeCallback = function (node) { return void _this.visitNode(node); };\n        return _this;\n    }\n    NoUnsafeAnyWalker.prototype.walk = function (sourceFile) {\n        if (sourceFile.isDeclarationFile) {\n            return; // Not possible in a declaration file.\n        }\n        sourceFile.statements.forEach(this.visitNodeCallback);\n    };\n    NoUnsafeAnyWalker.prototype.visitNode = function (node, anyOk) {\n        switch (node.kind) {\n            case ts.SyntaxKind.ParenthesizedExpression:\n                // Don't warn on a parenthesized expression, warn on its contents.\n                return this.visitNode(node.expression, anyOk);\n            case ts.SyntaxKind.LabeledStatement:\n                // Ignore label\n                return this.visitNode(node.statement);\n            // ignore labels\n            case ts.SyntaxKind.BreakStatement:\n            case ts.SyntaxKind.ContinueStatement:\n            // Ignore types\n            case ts.SyntaxKind.InterfaceDeclaration:\n            case ts.SyntaxKind.TypeAliasDeclaration:\n            case ts.SyntaxKind.TypeParameter:\n            case ts.SyntaxKind.IndexSignature:\n            // Ignore imports\n            case ts.SyntaxKind.ImportEqualsDeclaration:\n            case ts.SyntaxKind.ImportDeclaration:\n            case ts.SyntaxKind.ExportDeclaration:\n            case ts.SyntaxKind.ExportAssignment:\n                return false;\n            case ts.SyntaxKind.ThisKeyword:\n            case ts.SyntaxKind.Identifier:\n                return anyOk ? false : this.check(node);\n            // Recurse through these, but ignore the immediate child because it is allowed to be 'any'.\n            case ts.SyntaxKind.DeleteExpression:\n            case ts.SyntaxKind.ExpressionStatement:\n            case ts.SyntaxKind.TypeAssertionExpression:\n            case ts.SyntaxKind.AsExpression:\n            case ts.SyntaxKind.TemplateSpan: // Allow stringification (works on all values). Note: tagged templates handled differently.\n            case ts.SyntaxKind.ThrowStatement:\n            case ts.SyntaxKind.TypeOfExpression:\n            case ts.SyntaxKind.VoidExpression:\n                return this.visitNode(node.expression, true);\n            case ts.SyntaxKind.PropertyAssignment: {\n                var _a = node, name = _a.name, initializer = _a.initializer;\n                this.visitNode(name, /*anyOk*/ true);\n                if (tsutils_1.isReassignmentTarget(node.parent)) {\n                    return this.visitNode(initializer, true);\n                }\n                return this.checkContextualType(initializer, true);\n            }\n            case ts.SyntaxKind.ShorthandPropertyAssignment: {\n                var _b = node, name = _b.name, objectAssignmentInitializer = _b.objectAssignmentInitializer;\n                if (objectAssignmentInitializer !== undefined) {\n                    return this.checkContextualType(objectAssignmentInitializer);\n                }\n                return this.checkContextualType(name, true);\n            }\n            case ts.SyntaxKind.PropertyDeclaration: {\n                var _c = node, name = _c.name, initializer = _c.initializer;\n                this.visitNode(name, true);\n                return initializer !== undefined &&\n                    this.visitNode(initializer, isPropertyAny(node, this.checker));\n            }\n            case ts.SyntaxKind.SpreadAssignment:\n                return this.visitNode(node.expression, \n                // allow any in object spread, but not in object rest\n                !tsutils_1.isReassignmentTarget(node.parent));\n            case ts.SyntaxKind.ComputedPropertyName:\n                return this.visitNode(node.expression, true);\n            case ts.SyntaxKind.TaggedTemplateExpression: {\n                var _d = node, tag = _d.tag, template = _d.template;\n                if (template.kind === ts.SyntaxKind.TemplateExpression) {\n                    for (var _i = 0, _e = template.templateSpans; _i < _e.length; _i++) {\n                        var expression = _e[_i].expression;\n                        this.checkContextualType(expression);\n                    }\n                }\n                // Also check the template expression itself\n                if (this.visitNode(tag)) {\n                    return true;\n                }\n                return anyOk ? false : this.check(node);\n            }\n            case ts.SyntaxKind.CallExpression:\n            case ts.SyntaxKind.NewExpression: {\n                var _f = node, expression = _f.expression, args = _f.arguments;\n                if (args !== undefined) {\n                    for (var _g = 0, args_1 = args; _g < args_1.length; _g++) {\n                        var arg = args_1[_g];\n                        this.checkContextualType(arg);\n                    }\n                }\n                if (this.visitNode(expression)) {\n                    return true;\n                }\n                // Also check the call expression itself\n                return anyOk ? false : this.check(node);\n            }\n            case ts.SyntaxKind.PropertyAccessExpression:\n                // Don't warn for right hand side; this is redundant if we warn for the access itself.\n                if (this.visitNode(node.expression)) {\n                    return true;\n                }\n                return anyOk ? false : this.check(node);\n            case ts.SyntaxKind.ElementAccessExpression: {\n                var _h = node, expression = _h.expression, argumentExpression = _h.argumentExpression;\n                if (argumentExpression !== undefined) {\n                    this.visitNode(argumentExpression, true);\n                }\n                if (this.visitNode(expression)) {\n                    return true;\n                }\n                return anyOk ? false : this.check(node);\n            }\n            case ts.SyntaxKind.ReturnStatement: {\n                var expression = node.expression;\n                return expression !== undefined && this.checkContextualType(expression, true);\n            }\n            case ts.SyntaxKind.SwitchStatement: {\n                var _j = node, expression = _j.expression, clauses = _j.caseBlock.clauses;\n                // Allow `switch (x) {}` where `x` is any\n                this.visitNode(expression, /*anyOk*/ true);\n                for (var _k = 0, clauses_1 = clauses; _k < clauses_1.length; _k++) {\n                    var clause = clauses_1[_k];\n                    if (clause.kind === ts.SyntaxKind.CaseClause) {\n                        // Allow `case x:` where `x` is any\n                        this.visitNode(clause.expression, /*anyOk*/ true);\n                    }\n                    for (var _l = 0, _m = clause.statements; _l < _m.length; _l++) {\n                        var statement = _m[_l];\n                        this.visitNode(statement);\n                    }\n                }\n                return false;\n            }\n            case ts.SyntaxKind.ModuleDeclaration: {\n                // In `declare global { ... }`, don't mark `global` as unsafe any.\n                var body = node.body;\n                return body !== undefined && this.visitNode(body);\n            }\n            case ts.SyntaxKind.IfStatement: {\n                var _o = node, expression = _o.expression, thenStatement = _o.thenStatement, elseStatement = _o.elseStatement;\n                this.visitNode(expression, true); // allow truthyness check\n                this.visitNode(thenStatement);\n                return elseStatement !== undefined && this.visitNode(elseStatement);\n            }\n            case ts.SyntaxKind.PrefixUnaryExpression: {\n                var _p = node, operator = _p.operator, operand = _p.operand;\n                this.visitNode(operand, operator === ts.SyntaxKind.ExclamationToken); // allow falsyness check\n                return false;\n            }\n            case ts.SyntaxKind.ForStatement: {\n                var _q = node, initializer = _q.initializer, condition = _q.condition, incrementor = _q.incrementor, statement = _q.statement;\n                if (initializer !== undefined) {\n                    this.visitNode(initializer, true);\n                }\n                if (condition !== undefined) {\n                    this.visitNode(condition, true);\n                } // allow truthyness check\n                if (incrementor !== undefined) {\n                    this.visitNode(incrementor, true);\n                }\n                return this.visitNode(statement);\n            }\n            case ts.SyntaxKind.DoStatement:\n            case ts.SyntaxKind.WhileStatement:\n                this.visitNode(node.expression, true);\n                return this.visitNode(node.statement);\n            case ts.SyntaxKind.ConditionalExpression: {\n                var _r = node, condition = _r.condition, whenTrue = _r.whenTrue, whenFalse = _r.whenFalse;\n                this.visitNode(condition, true);\n                var left = this.visitNode(whenTrue, anyOk);\n                return this.visitNode(whenFalse, anyOk) || left;\n            }\n            case ts.SyntaxKind.VariableDeclaration:\n            case ts.SyntaxKind.Parameter:\n                return this.checkVariableOrParameterDeclaration(node);\n            case ts.SyntaxKind.BinaryExpression:\n                return this.checkBinaryExpression(node, anyOk);\n            case ts.SyntaxKind.AwaitExpression:\n                this.visitNode(node.expression);\n                return anyOk ? false : this.check(node);\n            case ts.SyntaxKind.YieldExpression:\n                return this.checkYieldExpression(node, anyOk);\n            case ts.SyntaxKind.ClassExpression:\n            case ts.SyntaxKind.ClassDeclaration:\n                this.checkClassLikeDeclaration(node);\n                return false;\n            case ts.SyntaxKind.ArrayLiteralExpression: {\n                for (var _s = 0, _t = node.elements; _s < _t.length; _s++) {\n                    var element = _t[_s];\n                    this.checkContextualType(element, true);\n                }\n                return false;\n            }\n            case ts.SyntaxKind.JsxExpression:\n                return node.expression !== undefined &&\n                    this.checkContextualType(node.expression);\n        }\n        if (tsutils_1.isTypeNodeKind(node.kind) || tsutils_1.isTokenKind(node.kind)) {\n            return false;\n        }\n        return ts.forEachChild(node, this.visitNodeCallback);\n    };\n    NoUnsafeAnyWalker.prototype.check = function (node) {\n        if (!isNodeAny(node, this.checker)) {\n            return false;\n        }\n        this.addFailureAtNode(node, Rule.FAILURE_STRING);\n        return true;\n    };\n    NoUnsafeAnyWalker.prototype.checkContextualType = function (node, allowIfNoContextualType) {\n        var type = this.checker.getContextualType(node);\n        return this.visitNode(node, type === undefined && allowIfNoContextualType || isAny(type));\n    };\n    // Allow `const x = foo;` and `const x: any = foo`, but not `const x: Foo = foo;`.\n    NoUnsafeAnyWalker.prototype.checkVariableOrParameterDeclaration = function (_a) {\n        var name = _a.name, type = _a.type, initializer = _a.initializer;\n        this.checkBindingName(name);\n        // Always allow the LHS to be `any`. Just don't allow RHS to be `any` when LHS isn't.\n        return initializer !== undefined &&\n            this.visitNode(initializer, \n            /*anyOk*/\n            name.kind === ts.SyntaxKind.Identifier && (type === undefined || type.kind === ts.SyntaxKind.AnyKeyword) ||\n                type !== undefined && type.kind === ts.SyntaxKind.AnyKeyword);\n    };\n    NoUnsafeAnyWalker.prototype.checkBinaryExpression = function (node, anyOk) {\n        var allowAnyLeft = false;\n        var allowAnyRight = false;\n        switch (node.operatorToken.kind) {\n            case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n            case ts.SyntaxKind.ExclamationEqualsToken:\n            case ts.SyntaxKind.EqualsEqualsEqualsToken:\n            case ts.SyntaxKind.EqualsEqualsToken:\n            case ts.SyntaxKind.CommaToken: // Allow `any, any`\n            case ts.SyntaxKind.BarBarToken: // Allow `any || any`\n            case ts.SyntaxKind.AmpersandAmpersandToken: // Allow `any && any`\n                allowAnyLeft = allowAnyRight = true;\n                break;\n            case ts.SyntaxKind.InstanceOfKeyword: // Allow test\n                allowAnyLeft = true;\n                break;\n            case ts.SyntaxKind.EqualsToken:\n                // Allow assignment if the lhs is also *any*.\n                allowAnyLeft = true;\n                allowAnyRight = isNodeAny(node.left, this.checker);\n                break;\n            case ts.SyntaxKind.PlusToken: // Allow implicit stringification\n            case ts.SyntaxKind.PlusEqualsToken:\n                allowAnyLeft = allowAnyRight = isStringLike(node.left, this.checker)\n                    || (isStringLike(node.right, this.checker) && node.operatorToken.kind === ts.SyntaxKind.PlusToken);\n        }\n        this.visitNode(node.left, allowAnyLeft);\n        this.visitNode(node.right, allowAnyRight);\n        return anyOk ? false : this.check(node);\n    };\n    NoUnsafeAnyWalker.prototype.checkYieldExpression = function (node, anyOk) {\n        if (node.expression !== undefined) {\n            this.checkContextualType(node.expression, true);\n        }\n        if (anyOk) {\n            return false;\n        }\n        this.addFailureAtNode(node, Rule.FAILURE_STRING);\n        return true;\n    };\n    NoUnsafeAnyWalker.prototype.checkClassLikeDeclaration = function (node) {\n        if (node.decorators !== undefined) {\n            node.decorators.forEach(this.visitNodeCallback);\n        }\n        if (node.heritageClauses !== undefined) {\n            node.heritageClauses.forEach(this.visitNodeCallback);\n        }\n        return node.members.forEach(this.visitNodeCallback);\n    };\n    NoUnsafeAnyWalker.prototype.checkBindingName = function (node) {\n        if (node.kind !== ts.SyntaxKind.Identifier) {\n            if (isNodeAny(node, this.checker)) {\n                this.addFailureAtNode(node, Rule.FAILURE_STRING);\n            }\n            for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {\n                var element = _a[_i];\n                if (element.kind !== ts.SyntaxKind.OmittedExpression) {\n                    if (element.propertyName !== undefined && element.propertyName.kind === ts.SyntaxKind.ComputedPropertyName) {\n                        this.visitNode(element.propertyName.expression);\n                    }\n                    this.checkBindingName(element.name);\n                    if (element.initializer !== undefined) {\n                        this.checkContextualType(element.initializer);\n                    }\n                }\n            }\n        }\n    };\n    return NoUnsafeAnyWalker;\n}(Lint.AbstractWalker));\n/** Check if property has no type annotation in this class and the base class */\nfunction isPropertyAny(node, checker) {\n    if (!isNodeAny(node.name, checker) || node.name.kind === ts.SyntaxKind.ComputedPropertyName) {\n        return false;\n    }\n    for (var _i = 0, _a = checker.getBaseTypes(checker.getTypeAtLocation(node.parent)); _i < _a.length; _i++) {\n        var base = _a[_i];\n        var prop = base.getProperty(node.name.text);\n        if (prop !== undefined && prop.declarations !== undefined) {\n            return isAny(checker.getTypeOfSymbolAtLocation(prop, prop.declarations[0]));\n        }\n    }\n    return true;\n}\nfunction isNodeAny(node, checker) {\n    var symbol = checker.getSymbolAtLocation(node);\n    if (symbol !== undefined && tsutils_1.isSymbolFlagSet(symbol, ts.SymbolFlags.Alias)) {\n        symbol = checker.getAliasedSymbol(symbol);\n    }\n    if (symbol !== undefined) {\n        // NamespaceModule is a type-only namespace without runtime value, its type is 'any' when used as 'ns.Type' -> avoid error\n        if (tsutils_1.isSymbolFlagSet(symbol, ts.SymbolFlags.NamespaceModule)) {\n            return false;\n        }\n        if (tsutils_1.isSymbolFlagSet(symbol, ts.SymbolFlags.Type)) {\n            return isAny(checker.getDeclaredTypeOfSymbol(symbol));\n        }\n    }\n    // Lowercase JSX elements are assumed to be allowed by design\n    if (isJsxNativeElement(node)) {\n        return false;\n    }\n    return isAny(checker.getTypeAtLocation(node));\n}\nvar jsxElementTypes = new Set([\n    ts.SyntaxKind.JsxClosingElement,\n    ts.SyntaxKind.JsxOpeningElement,\n    ts.SyntaxKind.JsxSelfClosingElement,\n]);\nfunction isJsxNativeElement(node) {\n    if (!tsutils_1.isIdentifier(node) || node.parent === undefined) {\n        return false;\n    }\n    // TypeScript <=2.1 incorrectly parses JSX fragments\n    if (node.text === \"\") {\n        return true;\n    }\n    return jsxElementTypes.has(node.parent.kind) && utils_1.isLowerCase(node.text[0]);\n}\nfunction isStringLike(expr, checker) {\n    return tsutils_1.isTypeFlagSet(checker.getTypeAtLocation(expr), ts.TypeFlags.StringLike);\n}\nfunction isAny(type) {\n    return type !== undefined && tsutils_1.isTypeFlagSet(type, ts.TypeFlags.Any);\n}\nvar templateObject_1, templateObject_2;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/noUnsafeAnyRule.js\n// module id = 2103\n// module chunks = 59"],"sourceRoot":""}