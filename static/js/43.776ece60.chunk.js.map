{"version":3,"sources":["../node_modules/tslint/lib/rules/strictBooleanExpressionsRule.js"],"names":["Object","defineProperty","exports","value","templateObject_1","templateObject_2","tslib_1","__webpack_require__","tsutils_1","ts","Lint","OPTION_ALLOW_NULL_UNION","OPTION_ALLOW_UNDEFINED_UNION","OPTION_ALLOW_STRING","OPTION_ALLOW_ENUM","OPTION_ALLOW_NUMBER","OPTION_ALLOW_MIX","OPTION_ALLOW_BOOLEAN_OR_UNDEFINED","Rule","_super","apply","this","arguments","__extends","prototype","applyWithProgram","sourceFile","program","options","ruleArguments","strictNullChecks","allowNullUnion","has","allowUndefinedUnion","allowString","allowEnum","allowNumber","allowMix","allowBooleanOrUndefined","name","indexOf","parseOptions","isStrictNullChecksEnabled","getCompilerOptions","applyWithFunction","walk","getTypeChecker","metadata","ruleName","description","Utils","dedent","__makeTemplateObject","optionsDescription","type","items","enum","minLength","maxLength","optionExamples","typescriptOnly","requiresTypeInfo","Rules","TypedRule","ctx","checker","checkExpression","node","location","getTypeAtLocation","failure","isUnionType","isTruthy","_i","_a","types","length","ty","isTypeFlagSet","TypeFlags","Boolean","BooleanLiteral","intrinsicName","Void","Undefined","isBooleanUndefined","anyTruthy","seenFalsy","kind","getKind","failureForKind","undefined","triState","handleUnion","Any","getTypeFailure","addFailureAtNode","unionType","expectedTypes","parts","push","showExpectedTypes","expected","res","i","stringOr","tyFail","is","showTypeFailure","n","SyntaxKind","PrefixUnaryExpression","ConditionalExpression","ForStatement","IfStatement","WhileStatement","DoStatement","BinaryExpression","binaryBooleanExpressionKind","showLocation","showFailure","forEachChild","cb","b_1","left","right","checkHalf","expr","isBooleanBinaryExpression","operator","operand","ExclamationToken","c","expression","condition","isInUnion","String","Number","Null","EnumLike","NumberLiteral","text","numberLiteralIsZero","StringLiteral","stringLiteralIsEmpty","flags","operatorToken","AmpersandAmpersandToken","BarBarToken","Union","Enum"],"mappings":"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","file":"static/js/43.776ece60.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2018 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_ALLOW_NULL_UNION = \"allow-null-union\";\nvar OPTION_ALLOW_UNDEFINED_UNION = \"allow-undefined-union\";\nvar OPTION_ALLOW_STRING = \"allow-string\";\nvar OPTION_ALLOW_ENUM = \"allow-enum\";\nvar OPTION_ALLOW_NUMBER = \"allow-number\";\nvar OPTION_ALLOW_MIX = \"allow-mix\";\nvar OPTION_ALLOW_BOOLEAN_OR_UNDEFINED = \"allow-boolean-or-undefined\";\n// tslint:disable object-literal-sort-keys\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        var options = parseOptions(this.ruleArguments, Lint.isStrictNullChecksEnabled(program.getCompilerOptions()));\n        return this.applyWithFunction(sourceFile, walk, options, program.getTypeChecker());\n    };\n    Rule.metadata = {\n        ruleName: \"strict-boolean-expressions\",\n        description: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            Restricts the types allowed in boolean expressions. By default only booleans are allowed.\\n\\n            The following nodes are checked:\\n\\n            * Arguments to the `!`, `&&`, and `||` operators\\n            * The condition in a conditional expression (`cond ? x : y`)\\n            * Conditions for `if`, `for`, `while`, and `do-while` statements.\"], [\"\\n            Restricts the types allowed in boolean expressions. By default only booleans are allowed.\\n\\n            The following nodes are checked:\\n\\n            * Arguments to the \\\\`!\\\\`, \\\\`&&\\\\`, and \\\\`||\\\\` operators\\n            * The condition in a conditional expression (\\\\`cond ? x : y\\\\`)\\n            * Conditions for \\\\`if\\\\`, \\\\`for\\\\`, \\\\`while\\\\`, and \\\\`do-while\\\\` statements.\"]))),\n        optionsDescription: Lint.Utils.dedent(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject([\"\\n            These options may be provided:\\n\\n            * `\", \"` allows union types containing `null`.\\n              - It does *not* allow `null` itself.\\n              - Without the '--strictNullChecks' compiler option, this will allow anything other than a string, number, or enum.\\n            * `\", \"` allows union types containing `undefined`.\\n              - It does *not* allow `undefined` itself.\\n              - Without the '--strictNullChecks' compiler option, this will allow anything other than a string, number, or enum.\\n            * `\", \"` allows strings.\\n              - It does *not* allow unions containing `string`.\\n              - It does *not* allow string literal types.\\n            * `\", \"` allows enums.\\n              - It does *not* allow unions containing `enum`.\\n            * `\", \"` allows numbers.\\n              - It does *not* allow unions containing `number`.\\n              - It does *not* allow enums or number literal types.\\n            * `\", \"` allows multiple of the above to appear together.\\n              - For example, `string | number` or `RegExp | null | undefined` would normally not be allowed.\\n              - A type like `\\\"foo\\\" | \\\"bar\\\" | undefined` is always allowed, because it has only one way to be false.\\n            * `\", \"` allows `boolean | undefined`.\\n              - Also allows `true | false | undefined`.\\n              - Does not allow `false | undefined`.\\n              - This option is a subset of `\", \"`, so you don't need to enable both options at the same time.\\n        \"], [\"\\n            These options may be provided:\\n\\n            * \\\\`\", \"\\\\` allows union types containing \\\\`null\\\\`.\\n              - It does *not* allow \\\\`null\\\\` itself.\\n              - Without the '--strictNullChecks' compiler option, this will allow anything other than a string, number, or enum.\\n            * \\\\`\", \"\\\\` allows union types containing \\\\`undefined\\\\`.\\n              - It does *not* allow \\\\`undefined\\\\` itself.\\n              - Without the '--strictNullChecks' compiler option, this will allow anything other than a string, number, or enum.\\n            * \\\\`\", \"\\\\` allows strings.\\n              - It does *not* allow unions containing \\\\`string\\\\`.\\n              - It does *not* allow string literal types.\\n            * \\\\`\", \"\\\\` allows enums.\\n              - It does *not* allow unions containing \\\\`enum\\\\`.\\n            * \\\\`\", \"\\\\` allows numbers.\\n              - It does *not* allow unions containing \\\\`number\\\\`.\\n              - It does *not* allow enums or number literal types.\\n            * \\\\`\", \"\\\\` allows multiple of the above to appear together.\\n              - For example, \\\\`string | number\\\\` or \\\\`RegExp | null | undefined\\\\` would normally not be allowed.\\n              - A type like \\\\`\\\"foo\\\" | \\\"bar\\\" | undefined\\\\` is always allowed, because it has only one way to be false.\\n            * \\\\`\", \"\\\\` allows \\\\`boolean | undefined\\\\`.\\n              - Also allows \\\\`true | false | undefined\\\\`.\\n              - Does not allow \\\\`false | undefined\\\\`.\\n              - This option is a subset of \\\\`\", \"\\\\`, so you don't need to enable both options at the same time.\\n        \"])), OPTION_ALLOW_NULL_UNION, OPTION_ALLOW_UNDEFINED_UNION, OPTION_ALLOW_STRING, OPTION_ALLOW_ENUM, OPTION_ALLOW_NUMBER, OPTION_ALLOW_MIX, OPTION_ALLOW_BOOLEAN_OR_UNDEFINED, OPTION_ALLOW_UNDEFINED_UNION),\n        options: {\n            type: \"array\",\n            items: {\n                type: \"string\",\n                enum: [\n                    OPTION_ALLOW_NULL_UNION,\n                    OPTION_ALLOW_UNDEFINED_UNION,\n                    OPTION_ALLOW_STRING,\n                    OPTION_ALLOW_ENUM,\n                    OPTION_ALLOW_NUMBER,\n                    OPTION_ALLOW_BOOLEAN_OR_UNDEFINED,\n                ],\n            },\n            minLength: 0,\n            maxLength: 5,\n        },\n        optionExamples: [\n            true,\n            [\n                true,\n                OPTION_ALLOW_NULL_UNION,\n                OPTION_ALLOW_UNDEFINED_UNION,\n                OPTION_ALLOW_STRING,\n                OPTION_ALLOW_ENUM,\n                OPTION_ALLOW_NUMBER,\n            ],\n            [true, OPTION_ALLOW_BOOLEAN_OR_UNDEFINED],\n        ],\n        type: \"functionality\",\n        typescriptOnly: true,\n        requiresTypeInfo: true,\n    };\n    return Rule;\n}(Lint.Rules.TypedRule));\nexports.Rule = Rule;\nfunction parseOptions(ruleArguments, strictNullChecks) {\n    return {\n        strictNullChecks: strictNullChecks,\n        allowNullUnion: has(OPTION_ALLOW_NULL_UNION),\n        allowUndefinedUnion: has(OPTION_ALLOW_UNDEFINED_UNION),\n        allowString: has(OPTION_ALLOW_STRING),\n        allowEnum: has(OPTION_ALLOW_ENUM),\n        allowNumber: has(OPTION_ALLOW_NUMBER),\n        allowMix: has(OPTION_ALLOW_MIX),\n        allowBooleanOrUndefined: has(OPTION_ALLOW_BOOLEAN_OR_UNDEFINED),\n    };\n    function has(name) {\n        return ruleArguments.indexOf(name) !== -1;\n    }\n}\nfunction walk(ctx, checker) {\n    var sourceFile = ctx.sourceFile, options = ctx.options;\n    ts.forEachChild(sourceFile, function cb(node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.BinaryExpression: {\n                var b_1 = node;\n                if (binaryBooleanExpressionKind(b_1) !== undefined) {\n                    var left = b_1.left, right = b_1.right;\n                    var checkHalf = function (expr) {\n                        // If it's another boolean binary expression, we'll check it when recursing.\n                        if (!isBooleanBinaryExpression(expr)) {\n                            checkExpression(expr, b_1);\n                        }\n                    };\n                    checkHalf(left);\n                    checkHalf(right);\n                }\n                break;\n            }\n            case ts.SyntaxKind.PrefixUnaryExpression: {\n                var _a = node, operator = _a.operator, operand = _a.operand;\n                if (operator === ts.SyntaxKind.ExclamationToken) {\n                    checkExpression(operand, node);\n                }\n                break;\n            }\n            case ts.SyntaxKind.IfStatement:\n            case ts.SyntaxKind.WhileStatement:\n            case ts.SyntaxKind.DoStatement: {\n                var c = node;\n                // If it's a boolean binary expression, we'll check it when recursing.\n                if (!isBooleanBinaryExpression(c.expression)) {\n                    checkExpression(c.expression, c);\n                }\n                break;\n            }\n            case ts.SyntaxKind.ConditionalExpression:\n                checkExpression(node.condition, node);\n                break;\n            case ts.SyntaxKind.ForStatement: {\n                var condition = node.condition;\n                if (condition !== undefined) {\n                    checkExpression(condition, node);\n                }\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n    function checkExpression(node, location) {\n        var type = checker.getTypeAtLocation(node);\n        var failure = getTypeFailure(type, options);\n        if (failure !== undefined) {\n            if (failure === 0 /* AlwaysTruthy */ &&\n                !options.strictNullChecks &&\n                (options.allowNullUnion || options.allowUndefinedUnion)) {\n                // OK; It might be null/undefined.\n                return;\n            }\n            ctx.addFailureAtNode(node, showFailure(location, failure, isUnionType(type), options));\n        }\n    }\n}\nfunction getTypeFailure(type, options) {\n    if (isUnionType(type)) {\n        return handleUnion(type, options);\n    }\n    var kind = getKind(type);\n    var failure = failureForKind(kind, /*isInUnion*/ false, options);\n    if (failure !== undefined) {\n        return failure;\n    }\n    switch (triState(kind)) {\n        case true:\n            // Allow 'any'. Allow 'true' itself, but not any other always-truthy type.\n            // tslint:disable-next-line no-bitwise\n            return tsutils_1.isTypeFlagSet(type, ts.TypeFlags.Any | ts.TypeFlags.BooleanLiteral)\n                ? undefined\n                : 0 /* AlwaysTruthy */;\n        case false:\n            // Allow 'false' itself, but not any other always-falsy type\n            return tsutils_1.isTypeFlagSet(type, ts.TypeFlags.BooleanLiteral)\n                ? undefined\n                : 1 /* AlwaysFalsy */;\n        case undefined:\n            return undefined;\n    }\n}\nfunction isBooleanUndefined(type) {\n    var isTruthy = false;\n    for (var _i = 0, _a = type.types; _i < _a.length; _i++) {\n        var ty = _a[_i];\n        if (tsutils_1.isTypeFlagSet(ty, ts.TypeFlags.Boolean)) {\n            isTruthy = true;\n        }\n        else if (tsutils_1.isTypeFlagSet(ty, ts.TypeFlags.BooleanLiteral)) {\n            isTruthy = isTruthy || ty.intrinsicName === \"true\";\n            // tslint:disable-next-line:no-bitwise\n        }\n        else if (!tsutils_1.isTypeFlagSet(ty, ts.TypeFlags.Void | ts.TypeFlags.Undefined)) {\n            return undefined;\n        }\n    }\n    return isTruthy;\n}\nfunction handleUnion(type, options) {\n    if (options.allowBooleanOrUndefined) {\n        switch (isBooleanUndefined(type)) {\n            case true:\n                return undefined;\n            case false:\n                return 1 /* AlwaysFalsy */;\n        }\n    }\n    // Tracks whether it's possibly truthy.\n    var anyTruthy = false;\n    // Counts falsy kinds to see if there's a mix. Also tracks whether it's possibly falsy.\n    var seenFalsy = 0;\n    for (var _i = 0, _a = type.types; _i < _a.length; _i++) {\n        var ty = _a[_i];\n        var kind = getKind(ty);\n        var failure = failureForKind(kind, /*isInUnion*/ true, options);\n        if (failure !== undefined) {\n            return failure;\n        }\n        switch (triState(kind)) {\n            case true:\n                anyTruthy = true;\n                break;\n            case false:\n                seenFalsy++;\n                break;\n            default:\n                anyTruthy = true;\n                seenFalsy++;\n        }\n    }\n    return seenFalsy === 0\n        ? 0 /* AlwaysTruthy */\n        : !anyTruthy\n            ? 1 /* AlwaysFalsy */\n            : !options.allowMix && seenFalsy > 1\n                ? 7 /* Mixes */\n                : undefined;\n}\n/** Fails if a kind of falsiness is not allowed. */\nfunction failureForKind(kind, isInUnion, options) {\n    switch (kind) {\n        case 0 /* String */:\n        case 1 /* FalseStringLiteral */:\n            return options.allowString ? undefined : 2 /* String */;\n        case 2 /* Number */:\n        case 3 /* FalseNumberLiteral */:\n            return options.allowNumber ? undefined : 3 /* Number */;\n        case 8 /* Enum */:\n            return options.allowEnum ? undefined : 6 /* Enum */;\n        case 6 /* Null */:\n            return isInUnion && !options.allowNullUnion ? 4 /* Null */ : undefined;\n        case 7 /* Undefined */:\n            return isInUnion && !options.allowUndefinedUnion ? 5 /* Undefined */ : undefined;\n        default:\n            return undefined;\n    }\n}\n/** Divides a type into always true, always false, or unknown. */\nfunction triState(kind) {\n    switch (kind) {\n        case 0 /* String */:\n        case 2 /* Number */:\n        case 4 /* Boolean */:\n        case 8 /* Enum */:\n            return undefined;\n        case 6 /* Null */:\n        case 7 /* Undefined */:\n        case 3 /* FalseNumberLiteral */:\n        case 1 /* FalseStringLiteral */:\n        case 5 /* FalseBooleanLiteral */:\n            return false;\n        case 9 /* AlwaysTruthy */:\n            return true;\n    }\n}\nfunction getKind(type) {\n    return is(ts.TypeFlags.String)\n        ? 0 /* String */\n        : is(ts.TypeFlags.Number)\n            ? 2 /* Number */\n            : is(ts.TypeFlags.Boolean)\n                ? 4 /* Boolean */\n                : is(ts.TypeFlags.Null)\n                    ? 6 /* Null */\n                    : // tslint:disable-next-line:no-bitwise\n                        is(ts.TypeFlags.Undefined | ts.TypeFlags.Void)\n                            ? 7 /* Undefined */\n                            : is(ts.TypeFlags.EnumLike)\n                                ? 8 /* Enum */\n                                : is(ts.TypeFlags.NumberLiteral)\n                                    ? numberLiteralIsZero(type)\n                                        ? 3 /* FalseNumberLiteral */\n                                        : 9 /* AlwaysTruthy */\n                                    : is(ts.TypeFlags.StringLiteral)\n                                        ? stringLiteralIsEmpty(type)\n                                            ? 1 /* FalseStringLiteral */\n                                            : 9 /* AlwaysTruthy */\n                                        : is(ts.TypeFlags.BooleanLiteral)\n                                            ? type.intrinsicName === \"true\"\n                                                ? 9 /* AlwaysTruthy */\n                                                : 5 /* FalseBooleanLiteral */\n                                            : 9 /* AlwaysTruthy */;\n    function is(flags) {\n        return tsutils_1.isTypeFlagSet(type, flags);\n    }\n}\nfunction numberLiteralIsZero(type) {\n    // for compatibility with typescript@<2.4.0\n    return type.value !== undefined ? type.value === 0 : type.text === \"0\";\n}\nfunction stringLiteralIsEmpty(type) {\n    // for compatibility with typescript@<2.4.0\n    return (type.value !== undefined ? type.value : type.text) === \"\";\n}\n/** Matches `&&` and `||` operators. */\nfunction isBooleanBinaryExpression(node) {\n    return (node.kind === ts.SyntaxKind.BinaryExpression &&\n        binaryBooleanExpressionKind(node) !== undefined);\n}\nfunction binaryBooleanExpressionKind(node) {\n    switch (node.operatorToken.kind) {\n        case ts.SyntaxKind.AmpersandAmpersandToken:\n            return \"&&\";\n        case ts.SyntaxKind.BarBarToken:\n            return \"||\";\n        default:\n            return undefined;\n    }\n}\nfunction stringOr(parts) {\n    switch (parts.length) {\n        case 1:\n            return parts[0];\n        case 2:\n            return parts[0] + \" or \" + parts[1];\n        default:\n            var res = \"\";\n            for (var i = 0; i < parts.length - 1; i++) {\n                res += parts[i] + \", \";\n            }\n            return res + \"or \" + parts[parts.length - 1];\n    }\n}\nfunction isUnionType(type) {\n    return tsutils_1.isTypeFlagSet(type, ts.TypeFlags.Union) && !tsutils_1.isTypeFlagSet(type, ts.TypeFlags.Enum);\n}\nfunction showLocation(n) {\n    switch (n.kind) {\n        case ts.SyntaxKind.PrefixUnaryExpression:\n            return \"operand for the '!' operator\";\n        case ts.SyntaxKind.ConditionalExpression:\n            return \"condition\";\n        case ts.SyntaxKind.ForStatement:\n            return \"'for' condition\";\n        case ts.SyntaxKind.IfStatement:\n            return \"'if' condition\";\n        case ts.SyntaxKind.WhileStatement:\n            return \"'while' condition\";\n        case ts.SyntaxKind.DoStatement:\n            return \"'do-while' condition\";\n        case ts.SyntaxKind.BinaryExpression:\n            return \"operand for the '\" + binaryBooleanExpressionKind(n) + \"' operator\";\n    }\n}\nfunction showFailure(location, ty, unionType, options) {\n    var expectedTypes = showExpectedTypes(options);\n    var expected = expectedTypes.length === 1\n        ? \"Only \" + expectedTypes[0] + \"s are allowed\"\n        : \"Allowed types are \" + stringOr(expectedTypes);\n    var tyFail = showTypeFailure(ty, unionType, options.strictNullChecks);\n    return \"This type is not allowed in the \" + showLocation(location) + \" because it \" + tyFail + \". \" + expected + \".\";\n}\nfunction showExpectedTypes(options) {\n    var parts = [\"boolean\"];\n    if (options.allowNullUnion) {\n        parts.push(\"null-union\");\n    }\n    if (options.allowUndefinedUnion) {\n        parts.push(\"undefined-union\");\n    }\n    if (options.allowString) {\n        parts.push(\"string\");\n    }\n    if (options.allowEnum) {\n        parts.push(\"enum\");\n    }\n    if (options.allowNumber) {\n        parts.push(\"number\");\n    }\n    if (options.allowBooleanOrUndefined) {\n        parts.push(\"boolean-or-undefined\");\n    }\n    return parts;\n}\nfunction showTypeFailure(ty, unionType, strictNullChecks) {\n    var is = unionType ? \"could be\" : \"is\";\n    switch (ty) {\n        case 0 /* AlwaysTruthy */:\n            return strictNullChecks\n                ? \"is always truthy\"\n                : \"is always truthy. It may be null/undefined, but neither \" +\n                    (\"'\" + OPTION_ALLOW_NULL_UNION + \"' nor '\" + OPTION_ALLOW_UNDEFINED_UNION + \"' is set\");\n        case 1 /* AlwaysFalsy */:\n            return \"is always falsy\";\n        case 2 /* String */:\n            return is + \" a string\";\n        case 3 /* Number */:\n            return is + \" a number\";\n        case 4 /* Null */:\n            return is + \" null\";\n        case 5 /* Undefined */:\n            return is + \" undefined\";\n        case 6 /* Enum */:\n            return is + \" an enum\";\n        case 7 /* Mixes */:\n            return \"unions more than one truthy/falsy type\";\n    }\n}\nvar templateObject_1, templateObject_2;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/strictBooleanExpressionsRule.js\n// module id = 2142\n// module chunks = 43"],"sourceRoot":""}