{"version":3,"sources":["../node_modules/tslint/lib/rules/whitespaceRule.js"],"names":["Object","defineProperty","exports","value","templateObject_1","tslib_1","__webpack_require__","utils","ts","Lint","OPTION_BRANCH","OPTION_DECL","OPTION_OPERATOR","OPTION_MODULE","OPTION_SEPARATOR","OPTION_REST_SPREAD","OPTION_TYPE","OPTION_TYPECAST","OPTION_TYPE_OPERATOR","OPTION_PREBLOCK","OPTION_POSTBRACE","Rule","_super","apply","this","arguments","__extends","prototype","sourceFile","applyWithFunction","walk","ruleArguments","branch","has","decl","operator","module","separator","restSpread","type","typecast","typeOperator","preblock","postbrace","option","indexOf","parseOptions","metadata","ruleName","description","rationale","optionsDescription","Utils","dedent","__makeTemplateObject","options","items","enum","minLength","maxLength","optionExamples","typescriptOnly","hasFix","FAILURE_STRING_MISSING","FAILURE_STRING_INVALID","Rules","AbstractRule","ctx","forEachChild","cb","node","kind","SyntaxKind","ArrowFunction","checkEqualsGreaterThanTokenInNode","BinaryExpression","_a","left","operatorToken","right","CommaToken","checkForTrailingWhitespace","getEnd","getFullStart","Block","ConditionalExpression","_b","condition","whenTrue","ConstructorType","ExportAssignment","position","getChildAt","FunctionType","ImportDeclaration","importClause","undefined","namedBindings_1","namedBindings","NamespaceImport","elements","forEach","element","idx","arr","name","length","getLastToken","startPos","getStart","ImportEqualsDeclaration","TypeAssertionExpression","expression","VariableDeclaration","PropertyDeclaration","_c","initializer","BindingElement","Parameter","dotDotDotToken","checkForExcessiveWhitespace","end","SpreadAssignment","SpreadElement","UnionType","IntersectionType","types_1","types","typeNode","index","prevTokenShouldBeFollowedByWhitespace","equalsGreaterThanToken","getChildOfKind","EqualsGreaterThanToken","whiteSpacePos","isWhiteSpace","text","charCodeAt","addMissingWhitespaceErrorAt","failures","some","f","getStartPosition","getPosition","fix","Replacement","appendText","addFailureAt","deleteText","addInvalidWhitespaceErrorAt","forEachTokenWithTrivia","_text","tokenKind","range","parent","WhitespaceTrivia","NewLineTrivia","EndOfFileToken","pos","CatchKeyword","ForKeyword","IfKeyword","SwitchKeyword","WhileKeyword","WithKeyword","SemicolonToken","nextPosition","ForStatement","EqualsToken","JsxAttribute","ColonToken","OpenBraceToken","nextPos","ImportKeyword","isCallExpression","isImportTypeNode","ExportKeyword","FromKeyword"],"mappings":"qDAiBAA,OAAAC,eAAAC,EAAA,cAA8CC,OAAA,IAC9C,IAgUAC,EAhUAC,EAAAC,EAAA,GAEAC,EAAAD,EAAA,KACAE,EAAAF,EAAA,IACAG,EAAAH,EAAA,MACAI,EAAA,eACAC,EAAA,aACAC,EAAA,iBACAC,EAAA,eACAC,EAAA,kBACAC,EAAA,oBACAC,EAAA,aACAC,EAAA,iBACAC,EAAA,sBACAC,EAAA,iBACAC,EAAA,kBACAC,EAAA,SAAAC,GAEA,SAAAD,IACA,cAAAC,KAAAC,MAAAC,KAAAC,YAAAD,KAsCA,OAxCAnB,EAAAqB,UAAAL,EAAAC,GAIAD,EAAAM,UAAAJ,MAAA,SAAAK,GACA,OAAAJ,KAAAK,kBAAAD,EAAAE,EAsCA,SAAAC,GACA,OACAC,OAAAC,EAAAvB,GACAwB,KAAAD,EAAAtB,GACAwB,SAAAF,EAAArB,GACAwB,OAAAH,EAAApB,GACAwB,UAAAJ,EAAAnB,GACAwB,WAAAL,EAAAlB,GACAwB,KAAAN,EAAAjB,GACAwB,SAAAP,EAAAhB,GACAwB,aAAAR,EAAAf,GACAwB,SAAAT,EAAAd,GACAwB,UAAAV,EAAAb,IAEA,SAAAa,EAAAW,GACA,WAAAb,EAAAc,QAAAD,IArDAE,CAAAtB,KAAAO,iBAEAV,EAAA0B,UACAC,SAAA,aACAC,YAAA,yCACAC,UAAA,gEACAC,mBAAA1C,EAAA2C,MAAAC,OAAAjD,MAAAC,EAAAiD,sBAAA,0kCAAipB,4pCACjpBC,SACAhB,KAAA,QACAiB,OACAjB,KAAA,SACAkB,MACA,eACA,aACA,iBACA,eACA,kBACA,oBACA,aACA,iBACA,sBACA,iBACA,oBAGAC,UAAA,EACAC,UAAA,IAEAC,kBAAA,qDACArB,KAAA,QACAsB,gBAAA,EACAC,QAAA,GAEAzC,EAAA0C,uBAAA,qBACA1C,EAAA2C,uBAAA,qBACA3C,EAzCA,CA0CCZ,EAAAwD,MAAAC,cAoBD,SAAApC,EAAAqC,GACA,IAAAvC,EAAAuC,EAAAvC,WAAA2B,EAAAY,EAAAZ,QACA/C,EAAA4D,aAAAxC,EAAA,SAAAyC,EAAAC,GACA,OAAAA,EAAAC,MACA,KAAA/D,EAAAgE,WAAAC,cACAC,EAAAJ,GACA,MAEA,KAAA9D,EAAAgE,WAAAG,iBACA,IAAAC,EAAAN,EAAAO,EAAAD,EAAAC,KAAAC,EAAAF,EAAAE,cAAAC,EAAAH,EAAAG,MACAxB,EAAApB,UAAA2C,EAAAP,OAAA/D,EAAAgE,WAAAQ,aACAC,EAAAJ,EAAAK,UACAD,EAAAF,EAAAI,iBAEA,MAEA,KAAA3E,EAAAgE,WAAAY,MACA7B,EAAAb,UACAuC,EAAAX,EAAAa,gBAEA,MAEA,KAAA3E,EAAAgE,WAAAa,sBACA,GAAA9B,EAAApB,SAAA,CACA,IAAAmD,EAAAhB,EAAAiB,EAAAD,EAAAC,UAAAC,EAAAF,EAAAE,SACAP,EAAAM,EAAAL,UACAD,EAAAO,EAAAL,gBACAF,EAAAO,EAAAN,UAEA,MACA,KAAA1E,EAAAgE,WAAAiB,gBACAf,EAAAJ,GACA,MACA,KAAA9D,EAAAgE,WAAAkB,iBACA,GAAAnC,EAAAnB,OAGA6C,EADAU,EADArB,EAAAsB,WAAA,GACAV,UAGA,MACA,KAAA1E,EAAAgE,WAAAqB,aACAnB,EAAAJ,GACA,MACA,KAAA9D,EAAAgE,WAAAsB,kBACA,IAAAC,EAAAzB,EAAAyB,aACA,GAAAxC,EAAAnB,aAAA4D,IAAAD,EAAA,CAGA,IAAAJ,OAAA,EACAM,EAAAF,EAAAG,mBACAF,IAAAC,GACAA,EAAA1B,OAAA/D,EAAAgE,WAAA2B,iBACAF,EAAAG,SAAAC,QAAA,SAAAC,EAAAC,EAAAC,GAEA,QAAAR,IADAM,EAAAG,KACA,CACA,GAAAF,IAAAC,EAAAE,OAAA,EAEAzB,EADAgB,EAAAU,eACAxB,gBAEA,OAAAoB,EAAA,CACA,IAAAK,EAAAN,EAAAO,WAAA,EACA5B,EAAA2B,IAAA,OAKAjB,EAAAM,EAAAf,eAEAc,IAAAD,EAAAU,OACAd,EAAAI,EAAAU,KAAAvB,eAEAc,IAAAL,GACAV,EAAAU,GAGA,MAEA,KAAAnF,EAAAgE,WAAAsC,wBACA,GAAAvD,EAAAnB,OAEA6C,EADAU,EAAArB,EAAAmC,KAAAvB,UAGA,MACA,KAAA1E,EAAAgE,WAAAuC,wBACA,GAAAxD,EAAAf,SAEAyC,EADAU,EAAArB,EAAA0C,WAAA7B,gBAGA,MACA,KAAA3E,EAAAgE,WAAAyC,oBACA,KAAAzG,EAAAgE,WAAA0C,oBACA,IAAAC,EAAA7C,EAAAmC,EAAAU,EAAAV,KAAAlE,EAAA4E,EAAA5E,KAAA6E,EAAAD,EAAAC,YACA7D,EAAArB,WAAA8D,IAAAoB,GACAnC,QAAAe,IAAAzD,IAAAkE,GAAAvB,UAEA,MACA,KAAA1E,EAAAgE,WAAA6C,eACA,KAAA7G,EAAAgE,WAAA8C,UACA,IAAAC,EAAAjD,EAAAiD,eACAhE,EAAAjB,iBAAA0D,IAAAuB,GACAC,EAAAD,EAAAE,KAEA,MACA,KAAAjH,EAAAgE,WAAAkD,iBACA,KAAAlH,EAAAgE,WAAAmD,cACA,GAAApE,EAAAjB,WAEAkF,EADA7B,EAAArB,EAAA0C,WAAA7B,gBAGA,MACA,KAAA3E,EAAAgE,WAAAoD,UACA,KAAApH,EAAAgE,WAAAqD,iBACA,GAAAtE,EAAAd,aAAA,CACA,IAAAqF,EAAAxD,EAAAyD,MACAD,EAAAzB,QAAA,SAAA2B,EAAAC,GACAA,EAAA,GACAhD,EAAA+C,EAAA7C,gBAEA8C,EAAAH,EAAApB,OAAA,GACAzB,EAAA+C,EAAA9C,aAKA1E,EAAA4D,aAAAE,EAAAD,KAEA,IAAA6D,GAAA,EA8EA,SAAAxD,EAAAJ,GACA,GAAAf,EAAApB,SAAA,CAGA,IAAAgG,EAAA5H,EAAA6H,eAAA9D,EAAA9D,EAAAgE,WAAA6D,uBAAAzG,QAEAoE,IAAAmC,IAGAlD,EAAAkD,EAAAhD,gBACAF,EAAAkD,EAAAjD,YAEA,SAAAD,EAAAU,EAAA2C,QACA,IAAAA,IAAuCA,EAAA3C,GACvCA,IAAA/D,EAAA6F,KACAhH,EAAA8H,aAAA3G,EAAA4G,KAAAC,WAAA9C,KACA+C,EAAAJ,GAGA,SAAAI,EAAA/C,GAEA,IAAAxB,EAAAwE,SAAAC,KAAA,SAAAC,GAA4C,OAAAA,EAAAC,mBAAAC,gBAAApD,IAA5C,CAGA,IAAAqD,EAAAvI,EAAAwI,YAAAC,WAAAvD,EAAA,KACAxB,EAAAgF,aAAAxD,EAAA,EAAAtE,EAAA0C,uBAAAiF,IAEA,SAAAxB,EAAA7B,GACAA,IAAA/D,EAAA6F,KACAhH,EAAA8H,aAAA3G,EAAA4G,KAAAC,WAAA9C,KAIA,SAAAA,GACA,IAAAqD,EAAAvI,EAAAwI,YAAAG,WAAAzD,EAAA,GACAxB,EAAAgF,aAAAxD,EAAA,EAAAtE,EAAA2C,uBAAAgF,GALAK,CAAA1D,GA3GApF,EAAA+I,uBAAA1H,EAAA,SAAA2H,EAAAC,EAAAC,EAAAC,GACA,GAAAF,IAAAhJ,EAAAgE,WAAAmF,kBACAH,IAAAhJ,EAAAgE,WAAAoF,eACAJ,IAAAhJ,EAAAgE,WAAAqF,eASA,OALA3B,IACAQ,EAAAe,EAAAK,KACA5B,GAAA,GAGAsB,GACA,KAAAhJ,EAAAgE,WAAAuF,aACA,KAAAvJ,EAAAgE,WAAAwF,WACA,KAAAxJ,EAAAgE,WAAAyF,UACA,KAAAzJ,EAAAgE,WAAA0F,cACA,KAAA1J,EAAAgE,WAAA2F,aACA,KAAA3J,EAAAgE,WAAA4F,YACA7G,EAAAvB,SACAkG,GAAA,GAEA,MACA,KAAA1H,EAAAgE,WAAAQ,WACAzB,EAAAlB,YACA6F,GAAA,GAEA,MACA,KAAA1H,EAAAgE,WAAA6F,eACA,IAAA9G,EAAAlB,UACA,MAEA,IAAAiI,EAAAb,EAAAK,IAAA,EACAJ,EAAAnF,OAAA/D,EAAAgE,WAAA+F,cACAD,IAAA1I,EAAA6F,MACA,MAAA7F,EAAA4G,KAAA8B,IACA,MAAA1I,EAAA4G,KAAA8B,MAEApC,GAAA,GAEA,MACA,KAAA1H,EAAAgE,WAAAgG,YACAjH,EAAArB,MAAAwH,EAAAnF,OAAA/D,EAAAgE,WAAAiG,eACAvC,GAAA,GAEA,MACA,KAAA1H,EAAAgE,WAAAkG,WACAnH,EAAAhB,OACA2F,GAAA,GAEA,MACA,KAAA1H,EAAAgE,WAAAmG,eACA,IAAAC,EAAAnB,EAAAK,IAAA,EACAvG,EAAAZ,WACA,MAAAf,EAAA4G,KAAAoC,IACA,OAAAhJ,EAAA4G,KAAAoC,IACA,OAAAhJ,EAAA4G,KAAAoC,IACA,OAAAhJ,EAAA4G,KAAAoC,IACAlC,EAAAkC,GAEA,MACA,KAAApK,EAAAgE,WAAAqG,cACA,GAAAtK,EAAAuK,iBAAApB,IACAA,EAAA1C,WAAAzC,OAAA/D,EAAAgE,WAAAqG,cACA,OAEA,GAAAtK,EAAAwK,iBAAArB,GACA,OAGA,KAAAlJ,EAAAgE,WAAAwG,cACA,KAAAxK,EAAAgE,WAAAyG,YACA1H,EAAAf,WACA0F,GAAA,QArEAA,GAAA,IAtJAhI,EAAAmB","file":"static/js/31.f695ff68.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\n// tslint:disable object-literal-sort-keys\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_BRANCH = \"check-branch\";\nvar OPTION_DECL = \"check-decl\";\nvar OPTION_OPERATOR = \"check-operator\";\nvar OPTION_MODULE = \"check-module\";\nvar OPTION_SEPARATOR = \"check-separator\";\nvar OPTION_REST_SPREAD = \"check-rest-spread\";\nvar OPTION_TYPE = \"check-type\";\nvar OPTION_TYPECAST = \"check-typecast\";\nvar OPTION_TYPE_OPERATOR = \"check-type-operator\";\nvar OPTION_PREBLOCK = \"check-preblock\";\nvar OPTION_POSTBRACE = \"check-postbrace\";\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk, parseOptions(this.ruleArguments));\n    };\n    Rule.metadata = {\n        ruleName: \"whitespace\",\n        description: \"Enforces whitespace style conventions.\",\n        rationale: \"Helps maintain a readable, consistent style in your codebase.\",\n        optionsDescription: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            Ten arguments may be optionally provided:\\n\\n            * `\\\"check-branch\\\"` checks branching statements (`if`/`else`/`for`/`while`) are followed by whitespace.\\n            * `\\\"check-decl\\\"`checks that variable declarations have whitespace around the equals token.\\n            * `\\\"check-operator\\\"` checks for whitespace around operator tokens.\\n            * `\\\"check-module\\\"` checks for whitespace in import & export statements.\\n            * `\\\"check-separator\\\"` checks for whitespace after separator tokens (`,`/`;`).\\n            * `\\\"check-rest-spread\\\"` checks that there is no whitespace after rest/spread operator (`...`).\\n            * `\\\"check-type\\\"` checks for whitespace before a variable type specification.\\n            * `\\\"check-typecast\\\"` checks for whitespace between a typecast and its target.\\n            * `\\\"check-type-operator\\\"` checks for whitespace between type operators `|` and `&`.\\n            * `\\\"check-preblock\\\"` checks for whitespace before the opening brace of a block.\\n            * `\\\"check-postbrace\\\"` checks for whitespace after an opening brace.\"], [\"\\n            Ten arguments may be optionally provided:\\n\\n            * \\\\`\\\"check-branch\\\"\\\\` checks branching statements (\\\\`if\\\\`/\\\\`else\\\\`/\\\\`for\\\\`/\\\\`while\\\\`) are followed by whitespace.\\n            * \\\\`\\\"check-decl\\\"\\\\`checks that variable declarations have whitespace around the equals token.\\n            * \\\\`\\\"check-operator\\\"\\\\` checks for whitespace around operator tokens.\\n            * \\\\`\\\"check-module\\\"\\\\` checks for whitespace in import & export statements.\\n            * \\\\`\\\"check-separator\\\"\\\\` checks for whitespace after separator tokens (\\\\`,\\\\`/\\\\`;\\\\`).\\n            * \\\\`\\\"check-rest-spread\\\"\\\\` checks that there is no whitespace after rest/spread operator (\\\\`...\\\\`).\\n            * \\\\`\\\"check-type\\\"\\\\` checks for whitespace before a variable type specification.\\n            * \\\\`\\\"check-typecast\\\"\\\\` checks for whitespace between a typecast and its target.\\n            * \\\\`\\\"check-type-operator\\\"\\\\` checks for whitespace between type operators \\\\`|\\\\` and \\\\`&\\\\`.\\n            * \\\\`\\\"check-preblock\\\"\\\\` checks for whitespace before the opening brace of a block.\\n            * \\\\`\\\"check-postbrace\\\"\\\\` checks for whitespace after an opening brace.\"]))),\n        options: {\n            type: \"array\",\n            items: {\n                type: \"string\",\n                enum: [\n                    \"check-branch\",\n                    \"check-decl\",\n                    \"check-operator\",\n                    \"check-module\",\n                    \"check-separator\",\n                    \"check-rest-spread\",\n                    \"check-type\",\n                    \"check-typecast\",\n                    \"check-type-operator\",\n                    \"check-preblock\",\n                    \"check-postbrace\",\n                ],\n            },\n            minLength: 0,\n            maxLength: 11,\n        },\n        optionExamples: [[true, \"check-branch\", \"check-operator\", \"check-typecast\"]],\n        type: \"style\",\n        typescriptOnly: false,\n        hasFix: true,\n    };\n    Rule.FAILURE_STRING_MISSING = \"missing whitespace\";\n    Rule.FAILURE_STRING_INVALID = \"invalid whitespace\";\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nfunction parseOptions(ruleArguments) {\n    return {\n        branch: has(OPTION_BRANCH),\n        decl: has(OPTION_DECL),\n        operator: has(OPTION_OPERATOR),\n        module: has(OPTION_MODULE),\n        separator: has(OPTION_SEPARATOR),\n        restSpread: has(OPTION_REST_SPREAD),\n        type: has(OPTION_TYPE),\n        typecast: has(OPTION_TYPECAST),\n        typeOperator: has(OPTION_TYPE_OPERATOR),\n        preblock: has(OPTION_PREBLOCK),\n        postbrace: has(OPTION_POSTBRACE),\n    };\n    function has(option) {\n        return ruleArguments.indexOf(option) !== -1;\n    }\n}\nfunction walk(ctx) {\n    var sourceFile = ctx.sourceFile, options = ctx.options;\n    ts.forEachChild(sourceFile, function cb(node) {\n        switch (node.kind) {\n            case ts.SyntaxKind.ArrowFunction:\n                checkEqualsGreaterThanTokenInNode(node);\n                break;\n            // check for spaces between the operator symbol (except in the case of comma statements)\n            case ts.SyntaxKind.BinaryExpression: {\n                var _a = node, left = _a.left, operatorToken = _a.operatorToken, right = _a.right;\n                if (options.operator && operatorToken.kind !== ts.SyntaxKind.CommaToken) {\n                    checkForTrailingWhitespace(left.getEnd());\n                    checkForTrailingWhitespace(right.getFullStart());\n                }\n                break;\n            }\n            case ts.SyntaxKind.Block:\n                if (options.preblock) {\n                    checkForTrailingWhitespace(node.getFullStart());\n                }\n                break;\n            // check for spaces between ternary operator symbols\n            case ts.SyntaxKind.ConditionalExpression:\n                if (options.operator) {\n                    var _b = node, condition = _b.condition, whenTrue = _b.whenTrue;\n                    checkForTrailingWhitespace(condition.getEnd());\n                    checkForTrailingWhitespace(whenTrue.getFullStart());\n                    checkForTrailingWhitespace(whenTrue.getEnd());\n                }\n                break;\n            case ts.SyntaxKind.ConstructorType:\n                checkEqualsGreaterThanTokenInNode(node);\n                break;\n            case ts.SyntaxKind.ExportAssignment:\n                if (options.module) {\n                    var exportKeyword = node.getChildAt(0);\n                    var position = exportKeyword.getEnd();\n                    checkForTrailingWhitespace(position);\n                }\n                break;\n            case ts.SyntaxKind.FunctionType:\n                checkEqualsGreaterThanTokenInNode(node);\n                break;\n            case ts.SyntaxKind.ImportDeclaration: {\n                var importClause = node.importClause;\n                if (options.module && importClause !== undefined) {\n                    // an import clause can have _both_ named bindings and a name (the latter for the default import)\n                    // but the named bindings always come last, so we only need to check that for whitespace\n                    var position = void 0;\n                    var namedBindings_1 = importClause.namedBindings;\n                    if (namedBindings_1 !== undefined) {\n                        if (namedBindings_1.kind !== ts.SyntaxKind.NamespaceImport) {\n                            namedBindings_1.elements.forEach(function (element, idx, arr) {\n                                var internalName = element.name;\n                                if (internalName !== undefined) {\n                                    if (idx === arr.length - 1) {\n                                        var token = namedBindings_1.getLastToken();\n                                        checkForTrailingWhitespace(token.getFullStart());\n                                    }\n                                    if (idx === 0) {\n                                        var startPos = element.getStart() - 1;\n                                        checkForTrailingWhitespace(startPos, startPos + 1);\n                                    }\n                                }\n                            });\n                        }\n                        position = namedBindings_1.getEnd();\n                    }\n                    else if (importClause.name !== undefined) {\n                        position = importClause.name.getEnd();\n                    }\n                    if (position !== undefined) {\n                        checkForTrailingWhitespace(position);\n                    }\n                }\n                break;\n            }\n            case ts.SyntaxKind.ImportEqualsDeclaration:\n                if (options.module) {\n                    var position = node.name.getEnd();\n                    checkForTrailingWhitespace(position);\n                }\n                break;\n            case ts.SyntaxKind.TypeAssertionExpression:\n                if (options.typecast) {\n                    var position = node.expression.getFullStart();\n                    checkForTrailingWhitespace(position);\n                }\n                break;\n            case ts.SyntaxKind.VariableDeclaration:\n            case ts.SyntaxKind.PropertyDeclaration:\n                var _c = node, name = _c.name, type = _c.type, initializer = _c.initializer;\n                if (options.decl && initializer !== undefined) {\n                    checkForTrailingWhitespace((type !== undefined ? type : name).getEnd());\n                }\n                break;\n            case ts.SyntaxKind.BindingElement:\n            case ts.SyntaxKind.Parameter:\n                var dotDotDotToken = node.dotDotDotToken;\n                if (options.restSpread && dotDotDotToken !== undefined) {\n                    checkForExcessiveWhitespace(dotDotDotToken.end);\n                }\n                break;\n            case ts.SyntaxKind.SpreadAssignment:\n            case ts.SyntaxKind.SpreadElement:\n                if (options.restSpread) {\n                    var position = node.expression.getFullStart();\n                    checkForExcessiveWhitespace(position);\n                }\n                break;\n            case ts.SyntaxKind.UnionType:\n            case ts.SyntaxKind.IntersectionType:\n                if (options.typeOperator) {\n                    var types_1 = node.types;\n                    types_1.forEach(function (typeNode, index) {\n                        if (index > 0) {\n                            checkForTrailingWhitespace(typeNode.getFullStart());\n                        }\n                        if (index < types_1.length - 1) {\n                            checkForTrailingWhitespace(typeNode.getEnd());\n                        }\n                    });\n                }\n        }\n        ts.forEachChild(node, cb);\n    });\n    var prevTokenShouldBeFollowedByWhitespace = false;\n    utils.forEachTokenWithTrivia(sourceFile, function (_text, tokenKind, range, parent) {\n        if (tokenKind === ts.SyntaxKind.WhitespaceTrivia ||\n            tokenKind === ts.SyntaxKind.NewLineTrivia ||\n            tokenKind === ts.SyntaxKind.EndOfFileToken) {\n            prevTokenShouldBeFollowedByWhitespace = false;\n            return;\n        }\n        else if (prevTokenShouldBeFollowedByWhitespace) {\n            addMissingWhitespaceErrorAt(range.pos);\n            prevTokenShouldBeFollowedByWhitespace = false;\n        }\n        // check for trailing space after the given tokens\n        switch (tokenKind) {\n            case ts.SyntaxKind.CatchKeyword:\n            case ts.SyntaxKind.ForKeyword:\n            case ts.SyntaxKind.IfKeyword:\n            case ts.SyntaxKind.SwitchKeyword:\n            case ts.SyntaxKind.WhileKeyword:\n            case ts.SyntaxKind.WithKeyword:\n                if (options.branch) {\n                    prevTokenShouldBeFollowedByWhitespace = true;\n                }\n                break;\n            case ts.SyntaxKind.CommaToken:\n                if (options.separator) {\n                    prevTokenShouldBeFollowedByWhitespace = true;\n                }\n                break;\n            case ts.SyntaxKind.SemicolonToken:\n                if (!options.separator) {\n                    break;\n                }\n                var nextPosition = range.pos + 1;\n                var semicolonInTrivialFor = parent.kind === ts.SyntaxKind.ForStatement &&\n                    nextPosition !== sourceFile.end &&\n                    (sourceFile.text[nextPosition] === \";\" ||\n                        sourceFile.text[nextPosition] === \")\");\n                if (!semicolonInTrivialFor) {\n                    prevTokenShouldBeFollowedByWhitespace = true;\n                }\n                break;\n            case ts.SyntaxKind.EqualsToken:\n                if (options.decl && parent.kind !== ts.SyntaxKind.JsxAttribute) {\n                    prevTokenShouldBeFollowedByWhitespace = true;\n                }\n                break;\n            case ts.SyntaxKind.ColonToken:\n                if (options.type) {\n                    prevTokenShouldBeFollowedByWhitespace = true;\n                }\n                break;\n            case ts.SyntaxKind.OpenBraceToken:\n                var nextPos = range.pos + 1;\n                if (options.postbrace &&\n                    (sourceFile.text[nextPos] !== \" \" &&\n                        sourceFile.text[nextPos] !== \"\\r\" &&\n                        sourceFile.text[nextPos] !== \"\\t\" &&\n                        sourceFile.text[nextPos] !== \"\\n\")) {\n                    addMissingWhitespaceErrorAt(nextPos);\n                }\n                break;\n            case ts.SyntaxKind.ImportKeyword:\n                if (utils.isCallExpression(parent) &&\n                    parent.expression.kind === ts.SyntaxKind.ImportKeyword) {\n                    return; // Don't check ImportCall\n                }\n                if (utils.isImportTypeNode(parent)) {\n                    return; // Don't check TypeQuery\n                }\n            // falls through\n            case ts.SyntaxKind.ExportKeyword:\n            case ts.SyntaxKind.FromKeyword:\n                if (options.typecast) {\n                    prevTokenShouldBeFollowedByWhitespace = true;\n                }\n        }\n    });\n    function checkEqualsGreaterThanTokenInNode(node) {\n        if (!options.operator) {\n            return;\n        }\n        var equalsGreaterThanToken = utils.getChildOfKind(node, ts.SyntaxKind.EqualsGreaterThanToken, sourceFile);\n        // condition so we don't crash if the arrow is somehow missing\n        if (equalsGreaterThanToken === undefined) {\n            return;\n        }\n        checkForTrailingWhitespace(equalsGreaterThanToken.getFullStart());\n        checkForTrailingWhitespace(equalsGreaterThanToken.getEnd());\n    }\n    function checkForTrailingWhitespace(position, whiteSpacePos) {\n        if (whiteSpacePos === void 0) { whiteSpacePos = position; }\n        if (position !== sourceFile.end &&\n            !Lint.isWhiteSpace(sourceFile.text.charCodeAt(position))) {\n            addMissingWhitespaceErrorAt(whiteSpacePos);\n        }\n    }\n    function addMissingWhitespaceErrorAt(position) {\n        // TODO: this rule occasionally adds duplicate failures.\n        if (ctx.failures.some(function (f) { return f.getStartPosition().getPosition() === position; })) {\n            return;\n        }\n        var fix = Lint.Replacement.appendText(position, \" \");\n        ctx.addFailureAt(position, 1, Rule.FAILURE_STRING_MISSING, fix);\n    }\n    function checkForExcessiveWhitespace(position) {\n        if (position !== sourceFile.end &&\n            Lint.isWhiteSpace(sourceFile.text.charCodeAt(position))) {\n            addInvalidWhitespaceErrorAt(position);\n        }\n    }\n    function addInvalidWhitespaceErrorAt(position) {\n        var fix = Lint.Replacement.deleteText(position, 1);\n        ctx.addFailureAt(position, 1, Rule.FAILURE_STRING_INVALID, fix);\n    }\n}\nvar templateObject_1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/whitespaceRule.js\n// module id = 2158\n// module chunks = 31"],"sourceRoot":""}