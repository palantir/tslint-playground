{"version":3,"sources":["../node_modules/tslint/lib/rules/preferFunctionOverMethodRule.js"],"names":["Object","defineProperty","exports","value","tslib_1","__webpack_require__","tsutils_1","ts","Lint","Rule","_super","apply","this","arguments","__extends","prototype","sourceFile","applyWithWalker","PreferFunctionOverMethodWalker","ruleName","allowProtected","ruleArguments","indexOf","allowPublic","metadata","description","optionsDescription","Utils","dedent","templateObject_1","__makeTemplateObject","options","type","enum","optionExamples","typescriptOnly","FAILURE_STRING","Rules","AbstractRule","walk","_this","cb","node","isMethodDeclaration","isExempt","currentScope","isThisUsed","name","getPropertyName","forEachChild","addFailureAtNode","undefined","hasOwnThisReference","scope","kind","SyntaxKind","ThisKeyword","parent","PropertyAccessExpression","text","isRecursiveCall","SuperKeyword","body","ClassDeclaration","ClassExpression","hasModifier","modifiers","StaticKeyword","ProtectedKeyword","PublicKeyword","PrivateKeyword","AbstractWalker"],"mappings":"qDAiBAA,OAAAC,eAAAC,EAAA,cAA8CC,OAAA,IAC9C,IAAAC,EAAAC,EAAA,GACAC,EAAAD,EAAA,KACAE,EAAAF,EAAA,IACAG,EAAAH,EAAA,MAGAI,EAAA,SAAAC,GAEA,SAAAD,IACA,cAAAC,KAAAC,MAAAC,KAAAC,YAAAD,KAuBA,OAzBAR,EAAAU,UAAAL,EAAAC,GAIAD,EAAAM,UAAAJ,MAAA,SAAAK,GACA,OAAAJ,KAAAK,gBAAA,IAAAC,EAAAF,EAAAJ,KAAAO,UACAC,gBAAA,IAAAR,KAAAS,cAAAC,QARA,mBASAC,aAAA,IAAAX,KAAAS,cAAAC,QAVA,oBAcAb,EAAAe,UACAL,SAAA,8BACAM,YAAA,kDACAC,mBAAAlB,EAAAmB,MAAAC,OAAAC,MAAAzB,EAAA0B,sBAAA,iPAjBA,eACA,mBAiBAC,SACAC,KAAA,SACAC,MApBA,eACA,oBAqBAC,iBAAA,MAtBA,eACA,oBAsBAF,KAAA,QACAG,gBAAA,GAGA1B,EAAA2B,eAAA,4DACA3B,EA1BA,CA2BCD,EAAA6B,MAAAC,cACDpC,EAAAO,OACA,IA0DAoB,EA1DAX,EAAA,SAAAR,GAEA,SAAAQ,IACA,cAAAR,KAAAC,MAAAC,KAAAC,YAAAD,KAgDA,OAlDAR,EAAAU,UAAAI,EAAAR,GAIAQ,EAAAH,UAAAwB,KAAA,SAAAvB,GACA,IAAAwB,EAAA5B,KACA6B,EAAA,SAAAC,GACA,GAAApC,EAAAqC,oBAAAD,KAAAF,EAAAI,SAAAF,GAEAF,EAAAK,cACAC,YAAA,EACAC,KAAAzC,EAAA0C,gBAAAN,EAAAK,OAEAxC,EAAA0C,aAAAP,EAAAD,GACAD,EAAAK,aAAAC,YACAN,EAAAU,iBAAAR,EAAAK,KAAAtC,EAAA2B,gBAEAI,EAAAK,kBAAAM,OAEA,GAAA7C,EAAA8C,oBAAAV,GAAA,CACA,IAAAW,EAAAb,EAAAK,aACAL,EAAAK,kBAAAM,EACA5C,EAAA0C,aAAAP,EAAAD,GACAD,EAAAK,aAAAQ,MAEA,SAAAF,IAAAX,EAAAK,eACAH,EAAAY,OAAA/C,EAAAgD,WAAAC,aA0BA,SAAAd,EAAAK,GACA,YAAAI,IAAAJ,GACAL,EAAAe,OAAAH,OAAA/C,EAAAgD,WAAAG,0BACAhB,EAAAe,OAAAV,KAAAY,OAAAZ,EA5BAa,CAAAlB,EAAAF,EAAAK,aAAAE,QACAL,EAAAY,OAAA/C,EAAAgD,WAAAM,aAIA,OAAAtD,EAAA0C,aAAAP,EAAAD,GAHAD,EAAAK,aAAAC,YAAA,IAMA,OAAAvC,EAAA0C,aAAAjC,EAAAyB,IAEAvB,EAAAH,UAAA6B,SAAA,SAAAF,GAEA,YAAAS,IAAAT,EAAAoB,MAEApB,EAAAe,OAAAH,OAAA/C,EAAAgD,WAAAQ,kBACArB,EAAAe,OAAAH,OAAA/C,EAAAgD,WAAAS,iBACA1D,EAAA2D,YAAAvB,EAAAwB,UAAA3D,EAAAgD,WAAAY,gBACAvD,KAAAmB,QAAAX,gBACAd,EAAA2D,YAAAvB,EAAAwB,UAAA3D,EAAAgD,WAAAa,mBACAxD,KAAAmB,QAAAR,cACAjB,EAAA2D,YAAAvB,EAAAwB,UAAA3D,EAAAgD,WAAAc,iBACA/D,EAAA2D,YAAAvB,EAAAwB,UAAA3D,EAAAgD,WAAAa,iBAAA7D,EAAAgD,WAAAe,kBAEApD,EAnDA,CAoDCV,EAAA+D","file":"static/js/54.c94644a7.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_ALLOW_PUBLIC = \"allow-public\";\nvar OPTION_ALLOW_PROTECTED = \"allow-protected\";\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithWalker(new PreferFunctionOverMethodWalker(sourceFile, this.ruleName, {\n            allowProtected: this.ruleArguments.indexOf(OPTION_ALLOW_PROTECTED) !== -1,\n            allowPublic: this.ruleArguments.indexOf(OPTION_ALLOW_PUBLIC) !== -1,\n        }));\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"prefer-function-over-method\",\n        description: \"Warns for class methods that do not use 'this'.\",\n        optionsDescription: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            \\\"\", \"\\\" excludes checking of public methods.\\n            \\\"\", \"\\\" excludes checking of protected methods.\"], [\"\\n            \\\"\", \"\\\" excludes checking of public methods.\\n            \\\"\", \"\\\" excludes checking of protected methods.\"])), OPTION_ALLOW_PUBLIC, OPTION_ALLOW_PROTECTED),\n        options: {\n            type: \"string\",\n            enum: [OPTION_ALLOW_PUBLIC, OPTION_ALLOW_PROTECTED],\n        },\n        optionExamples: [true, [true, OPTION_ALLOW_PUBLIC, OPTION_ALLOW_PROTECTED]],\n        type: \"style\",\n        typescriptOnly: false,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = \"Class method does not use 'this'. Use a function instead.\";\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nvar PreferFunctionOverMethodWalker = /** @class */ (function (_super) {\n    tslib_1.__extends(PreferFunctionOverMethodWalker, _super);\n    function PreferFunctionOverMethodWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PreferFunctionOverMethodWalker.prototype.walk = function (sourceFile) {\n        var _this = this;\n        var cb = function (node) {\n            if (tsutils_1.isMethodDeclaration(node) && !_this.isExempt(node)) {\n                // currentScope is always undefined here, so we don't need to save it and just set it to undefined afterwards\n                _this.currentScope = {\n                    isThisUsed: false,\n                    name: tsutils_1.getPropertyName(node.name),\n                };\n                ts.forEachChild(node, cb);\n                if (!_this.currentScope.isThisUsed) {\n                    _this.addFailureAtNode(node.name, Rule.FAILURE_STRING);\n                }\n                _this.currentScope = undefined;\n            }\n            else if (tsutils_1.hasOwnThisReference(node)) {\n                var scope = _this.currentScope;\n                _this.currentScope = undefined;\n                ts.forEachChild(node, cb);\n                _this.currentScope = scope;\n            }\n            else if (_this.currentScope !== undefined &&\n                ((node.kind === ts.SyntaxKind.ThisKeyword &&\n                    !isRecursiveCall(node, _this.currentScope.name)) ||\n                    node.kind === ts.SyntaxKind.SuperKeyword)) {\n                _this.currentScope.isThisUsed = true;\n            }\n            else {\n                return ts.forEachChild(node, cb);\n            }\n        };\n        return ts.forEachChild(sourceFile, cb);\n    };\n    PreferFunctionOverMethodWalker.prototype.isExempt = function (node) {\n        // TODO: handle the override keyword once it lands in the language\n        return (node.body === undefined || // exclude abstract methods and overload signatures\n            // exclude object methods\n            (node.parent.kind !== ts.SyntaxKind.ClassDeclaration &&\n                node.parent.kind !== ts.SyntaxKind.ClassExpression) ||\n            tsutils_1.hasModifier(node.modifiers, ts.SyntaxKind.StaticKeyword) ||\n            (this.options.allowProtected &&\n                tsutils_1.hasModifier(node.modifiers, ts.SyntaxKind.ProtectedKeyword)) ||\n            (this.options.allowPublic &&\n                (tsutils_1.hasModifier(node.modifiers, ts.SyntaxKind.PublicKeyword) ||\n                    !tsutils_1.hasModifier(node.modifiers, ts.SyntaxKind.ProtectedKeyword, ts.SyntaxKind.PrivateKeyword))));\n    };\n    return PreferFunctionOverMethodWalker;\n}(Lint.AbstractWalker));\nfunction isRecursiveCall(node, name) {\n    return (name !== undefined &&\n        node.parent.kind === ts.SyntaxKind.PropertyAccessExpression &&\n        node.parent.name.text === name);\n}\nvar templateObject_1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/preferFunctionOverMethodRule.js\n// module id = 2127\n// module chunks = 54"],"sourceRoot":""}