{"version":3,"sources":["../node_modules/tslint/lib/rules/unnecessaryBindRule.js"],"names":["Object","defineProperty","exports","value","templateObject_1","tslib_1","__webpack_require__","tsutils","ts","Lint","Rule","_super","apply","this","arguments","__extends","prototype","sourceFile","applyWithFunction","walk","applyWithProgram","program","undefined","getTypeChecker","metadata","description","optionExamples","options","optionsDescription","rationale","Utils","dedent","__makeTemplateObject","requiresTypeInfo","ruleName","type","typescriptOnly","FAILURE_STRING_FUNCTION","FAILURE_STRING_ARROW","Rules","OptionallyTypedRule","context","typeChecker","variableUsage","collectVariableUsage","checkFunctionExpression","callExpression","valueDeclaration","length","kind","SyntaxKind","ThisKeyword","asteriskToken","decorators","name","nameInfo","get","uses","canFunctionExpressionBeFixed","addFailureAtNode","checkCallExpression","node","parent","isPropertyDeclaration","isDecoratedPropertyMember","bindExpression","expression","isPropertyAccessExpression","text","isBindPropertyAccess","boundExpression","unwrapParentheses","isFunctionExpression","symbol","getTypeAtLocation","isArrowFunction","getArrowFunctionDeclaration","checkArrowFunction","forEachChild","callback","isCallExpression"],"mappings":"qDAiBAA,OAAAC,eAAAC,EAAA,cAA8CC,OAAA,IAC9C,IA6GAC,EA7GAC,EAAAC,EAAA,GACAC,EAAAD,EAAA,KACAE,EAAAF,EAAA,IACAG,EAAAH,EAAA,MACAI,EAAA,SAAAC,GAEA,SAAAD,IACA,cAAAC,KAAAC,MAAAC,KAAAC,YAAAD,KAqBA,OAvBAR,EAAAU,UAAAL,EAAAC,GAIAD,EAAAM,UAAAJ,MAAA,SAAAK,GACA,OAAAJ,KAAAK,kBAAAD,EAAAE,IAEAT,EAAAM,UAAAI,iBAAA,SAAAH,EAAAI,GACA,OAAAR,KAAAK,kBAAAD,EAAAE,OAAAG,EAAAD,EAAAE,mBAEAb,EAAAc,UACAC,YAAA,sEACAC,iBAAA,GACAC,QAAA,KACAC,mBAAA,oBACAC,UAAApB,EAAAqB,MAAAC,OAAA3B,MAAAC,EAAA2B,sBAAA,geACAC,kBAAA,EACAC,SAAA,mBACAC,KAAA,QACAC,gBAAA,GAEA1B,EAAA2B,wBAAA,6FACA3B,EAAA4B,qBAAA,0EACA5B,EAxBA,CAyBCD,EAAA8B,MAAAC,qBAED,SAAArB,EAAAsB,EAAAC,GACA,IAAAC,EAAApC,EAAAqC,qBAAAH,EAAAxB,YAqBA,SAAA4B,EAAAC,EAAAC,IAdA,SAAAD,EAAAC,GACA,OAAAD,EAAAhC,UAAAkC,QACAF,EAAAhC,UAAA,GAAAmC,OAAAzC,EAAA0C,WAAAC,kBACA7B,IAAAyB,EAAAK,oBACA9B,IAAAyB,EAAAM,WACA,SAEA,IAAAC,EAAAP,EAAAO,KACA,QAAAhC,IAAAgC,EACA,SAEA,IAAAC,EAAAZ,EAAAa,IAAAF,GACA,YAAAhC,IAAAiC,GAAA,IAAAA,EAAAE,KAAAT,QAGAU,CAAAZ,EAAAC,IAGAN,EAAAkB,iBAAAb,EAAApC,EAAA2B,yBAwBA,SAAAuB,EAAAC,GACA,IANA,SAAAA,GACA,YAAAvC,IAAAuC,EAAAC,QACAvD,EAAAwD,sBAAAF,EAAAC,cACAxC,IAAAuC,EAAAC,OAAAT,WAGAW,CAAAH,GAAA,CAGA,IAAAI,EAAAJ,EAAAK,WACA,GAoBA,SAAAL,GACA,OAAArD,EAAA2D,2BAAAN,IAAA,SAAAA,EAAAP,KAAAc,KArBAC,CAAAJ,GAAA,CAGA,IAAAK,EAAA7D,EAAA8D,kBAAAN,EAAAC,YACA,GAAA3D,EAAAiE,qBAAAF,GACAzB,EAAAgB,EAAAS,aAIAhD,IApCA,SAAAuC,GACA,QAAAvC,IAAAoB,EAAA,CAGA,IAAA+B,EAAA/B,EAAAgC,kBAAAb,GAAAY,OACA,QAAAnD,IAAAmD,EAAA,CAGA,IAAA1B,EAAA0B,EAAA1B,iBACA,QAAAzB,IAAAyB,GAGAxC,EAAAoE,gBAAA5B,GAGA,OAAAA,IAoBA6B,CAAAN,IA7DA,SAAAT,GACA,IAAAA,EAAA/C,UAAAkC,QAGAP,EAAAkB,iBAAAE,EAAAnD,EAAA4B,sBA2DAuC,CAAAhB,KAGA,OAAArD,EAAAsE,aAAArC,EAAAxB,WAAA,SAAA8D,EAAAlB,GAIA,OAHArD,EAAAwE,iBAAAnB,IACAD,EAAAC,GAEArD,EAAAsE,aAAAjB,EAAAkB,KAzEA7E,EAAAQ","file":"static/js/35.f060dd5e.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        return this.applyWithFunction(sourceFile, walk, undefined, program.getTypeChecker());\n    };\n    Rule.metadata = {\n        description: \"Prevents unnecessary and/or misleading scope bindings on functions.\",\n        optionExamples: [true],\n        options: null,\n        optionsDescription: \"Not configurable.\",\n        rationale: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            `function` expressions that are immediately bound to `this` are equivalent to `() =>` arrow lambdas.\\n            Additionally, there's no use in binding a scope to an arrow lambda, as it already has one.\\n        \"], [\"\\n            \\\\`function\\\\` expressions that are immediately bound to \\\\`this\\\\` are equivalent to \\\\`() =>\\\\` arrow lambdas.\\n            Additionally, there's no use in binding a scope to an arrow lambda, as it already has one.\\n        \"]))),\n        requiresTypeInfo: true,\n        ruleName: \"unnecessary-bind\",\n        type: \"style\",\n        typescriptOnly: false,\n    };\n    Rule.FAILURE_STRING_FUNCTION = \"Don't bind `this` without arguments as a scope to a function. Use an arrow lambda instead.\";\n    Rule.FAILURE_STRING_ARROW = \"Don't bind scopes to arrow lambdas, as they already have a bound scope.\";\n    return Rule;\n}(Lint.Rules.OptionallyTypedRule));\nexports.Rule = Rule;\nfunction walk(context, typeChecker) {\n    var variableUsage = tsutils.collectVariableUsage(context.sourceFile);\n    function checkArrowFunction(node) {\n        if (node.arguments.length !== 1) {\n            return;\n        }\n        context.addFailureAtNode(node, Rule.FAILURE_STRING_ARROW);\n    }\n    function canFunctionExpressionBeFixed(callExpression, valueDeclaration) {\n        if (callExpression.arguments.length !== 1 ||\n            callExpression.arguments[0].kind !== ts.SyntaxKind.ThisKeyword ||\n            valueDeclaration.asteriskToken !== undefined ||\n            valueDeclaration.decorators !== undefined) {\n            return false;\n        }\n        var name = valueDeclaration.name;\n        if (name === undefined) {\n            return true;\n        }\n        var nameInfo = variableUsage.get(name);\n        return nameInfo === undefined || nameInfo.uses.length === 0;\n    }\n    function checkFunctionExpression(callExpression, valueDeclaration) {\n        if (!canFunctionExpressionBeFixed(callExpression, valueDeclaration)) {\n            return;\n        }\n        context.addFailureAtNode(callExpression, Rule.FAILURE_STRING_FUNCTION);\n    }\n    function getArrowFunctionDeclaration(node) {\n        if (typeChecker === undefined) {\n            return undefined;\n        }\n        var symbol = typeChecker.getTypeAtLocation(node).symbol;\n        if (symbol === undefined) {\n            return undefined;\n        }\n        var valueDeclaration = symbol.valueDeclaration;\n        if (valueDeclaration === undefined) {\n            return undefined;\n        }\n        if (!tsutils.isArrowFunction(valueDeclaration)) {\n            return undefined;\n        }\n        return valueDeclaration;\n    }\n    function isDecoratedPropertyMember(node) {\n        return (node.parent !== undefined &&\n            tsutils.isPropertyDeclaration(node.parent) &&\n            node.parent.decorators !== undefined);\n    }\n    function checkCallExpression(node) {\n        if (isDecoratedPropertyMember(node)) {\n            return;\n        }\n        var bindExpression = node.expression;\n        if (!isBindPropertyAccess(bindExpression)) {\n            return;\n        }\n        var boundExpression = Lint.unwrapParentheses(bindExpression.expression);\n        if (tsutils.isFunctionExpression(boundExpression)) {\n            checkFunctionExpression(node, boundExpression);\n            return;\n        }\n        var valueDeclaration = getArrowFunctionDeclaration(boundExpression);\n        if (valueDeclaration !== undefined) {\n            checkArrowFunction(node);\n        }\n    }\n    return ts.forEachChild(context.sourceFile, function callback(node) {\n        if (ts.isCallExpression(node)) {\n            checkCallExpression(node);\n        }\n        return ts.forEachChild(node, callback);\n    });\n}\nfunction isBindPropertyAccess(node) {\n    return ts.isPropertyAccessExpression(node) && node.name.text === \"bind\";\n}\nvar templateObject_1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/unnecessaryBindRule.js\n// module id = 2153\n// module chunks = 35"],"sourceRoot":""}