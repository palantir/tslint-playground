{"version":3,"sources":["../node_modules/tslint/lib/rules/strictTypePredicatesRule.js"],"names":["Object","defineProperty","exports","value","tslib_1","__webpack_require__","tsutils_1","ts","error_1","Lint","Rule","_super","apply","this","arguments","__extends","FAILURE_STRING","FAILURE_STRICT_PREFER_STRICT_EQUALS","isPositive","prototype","applyWithProgram","sourceFile","program","isStrictNullChecksEnabled","getCompilerOptions","applyWithFunction","walk","undefined","getTypeChecker","showWarningOnce","metadata","ruleName","description","Utils","dedent","templateObject_1","__makeTemplateObject","optionsDescription","options","optionExamples","type","typescriptOnly","requiresTypeInfo","FAILURE_STRING_BAD_TYPEOF","Rules","TypedRule","ctx","checker","forEachChild","cb","node","isBinaryExpression","equals","getEqualsKind","operatorToken","_a","isStrict","exprPred","isStrictEquals","left","right","lr","getTypePredicateOneWay","getTypePredicate","kind","fail","exprType","getTypeAtLocation","expression","isTypeFlagSet","TypeFlags","Any","TypeParameter","predicate","isNullOrUndefined","anyTrue","anyFalse","_i","unionParts","length","ty","getConstantBoolean","typeToString","isEmptyType","result","anyNull","anyUndefined","anyOther","Null","undefinedFlags","testNonStrictNullUndefined","failure","addFailureAtNode","checkEquals","SyntaxKind","TypeOfExpression","isLiteralExpression","isIdentifier","text","NullKeyword","TrueKeyword","FalseKeyword","flagPredicate","BooleanLike","NumberLike","StringLike","ESSymbol","isFunction","allFlags_1","Undefined","Void","getTypePredicateForKind","nullOrUndefined","Identifier","originalKeywordKind","UndefinedKeyword","flags","testedFlag","t","getConstructSignatures","getCallSignatures","symbol","getSymbol","getName","isUnionType","types"],"mappings":"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","file":"static/js/27.f5d7c6fe.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2017 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar error_1 = require(\"../error\");\nvar Lint = require(\"../index\");\n// tslint:disable:no-bitwise\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.FAILURE_STRING = function (value) {\n        return \"Expression is always \" + value + \".\";\n    };\n    Rule.FAILURE_STRICT_PREFER_STRICT_EQUALS = function (value, isPositive) {\n        return \"Use '\" + (isPositive ? \"===\" : \"!==\") + \" \" + value + \"' instead.\";\n    };\n    Rule.prototype.applyWithProgram = function (sourceFile, program) {\n        if (!Lint.isStrictNullChecksEnabled(program.getCompilerOptions())) {\n            error_1.showWarningOnce(\"strict-type-predicates does not work without --strictNullChecks\");\n            return [];\n        }\n        return this.applyWithFunction(sourceFile, walk, undefined, program.getTypeChecker());\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"strict-type-predicates\",\n        description: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            Warns for type predicates that are always true or always false.\\n            Works for 'typeof' comparisons to constants (e.g. 'typeof foo === \\\"string\\\"'), and equality comparison to 'null'/'undefined'.\\n            (TypeScript won't let you compare '1 === 2', but it has an exception for '1 === undefined'.)\\n            Does not yet work for 'instanceof'.\\n            Does *not* warn for 'if (x.y)' where 'x.y' is always truthy. For that, see strict-boolean-expressions.\\n\\n            This rule requires `strictNullChecks` to work properly.\"], [\"\\n            Warns for type predicates that are always true or always false.\\n            Works for 'typeof' comparisons to constants (e.g. 'typeof foo === \\\"string\\\"'), and equality comparison to 'null'/'undefined'.\\n            (TypeScript won't let you compare '1 === 2', but it has an exception for '1 === undefined'.)\\n            Does not yet work for 'instanceof'.\\n            Does *not* warn for 'if (x.y)' where 'x.y' is always truthy. For that, see strict-boolean-expressions.\\n\\n            This rule requires \\\\`strictNullChecks\\\\` to work properly.\"]))),\n        optionsDescription: \"Not configurable.\",\n        options: null,\n        optionExamples: [true],\n        type: \"functionality\",\n        typescriptOnly: true,\n        requiresTypeInfo: true,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING_BAD_TYPEOF = \"Bad comparison for 'typeof'.\";\n    return Rule;\n}(Lint.Rules.TypedRule));\nexports.Rule = Rule;\nfunction walk(ctx, checker) {\n    return ts.forEachChild(ctx.sourceFile, function cb(node) {\n        if (tsutils_1.isBinaryExpression(node)) {\n            var equals = Lint.getEqualsKind(node.operatorToken);\n            if (equals !== undefined) {\n                checkEquals(node, equals);\n            }\n        }\n        return ts.forEachChild(node, cb);\n    });\n    function checkEquals(node, _a) {\n        var isStrict = _a.isStrict, isPositive = _a.isPositive;\n        var exprPred = getTypePredicate(node, isStrict);\n        if (exprPred === undefined) {\n            return;\n        }\n        if (exprPred.kind === 2 /* TypeofTypo */) {\n            fail(Rule.FAILURE_STRING_BAD_TYPEOF);\n            return;\n        }\n        var exprType = checker.getTypeAtLocation(exprPred.expression);\n        // TODO: could use checker.getBaseConstraintOfType to help with type parameters, but it's not publicly exposed.\n        if (tsutils_1.isTypeFlagSet(exprType, ts.TypeFlags.Any | ts.TypeFlags.TypeParameter)) {\n            return;\n        }\n        switch (exprPred.kind) {\n            case 0 /* Plain */: {\n                var predicate = exprPred.predicate, isNullOrUndefined = exprPred.isNullOrUndefined;\n                var value = getConstantBoolean(exprType, predicate);\n                // 'null'/'undefined' are the only two values *not* assignable to '{}'.\n                if (value !== undefined && (isNullOrUndefined || !isEmptyType(checker, exprType))) {\n                    fail(Rule.FAILURE_STRING(value === isPositive));\n                }\n                break;\n            }\n            case 1 /* NonStructNullUndefined */: {\n                var result = testNonStrictNullUndefined(exprType);\n                if (result !== undefined) {\n                    fail(typeof result === \"boolean\"\n                        ? Rule.FAILURE_STRING(result === isPositive)\n                        : Rule.FAILURE_STRICT_PREFER_STRICT_EQUALS(result, isPositive));\n                }\n            }\n        }\n        function fail(failure) {\n            ctx.addFailureAtNode(node, failure);\n        }\n    }\n}\n/** Detects a type predicate given `left === right`. */\nfunction getTypePredicate(node, isStrictEquals) {\n    var left = node.left, right = node.right;\n    var lr = getTypePredicateOneWay(left, right, isStrictEquals);\n    return lr !== undefined ? lr : getTypePredicateOneWay(right, left, isStrictEquals);\n}\n/** Only gets the type predicate if the expression is on the left. */\nfunction getTypePredicateOneWay(left, right, isStrictEquals) {\n    switch (right.kind) {\n        case ts.SyntaxKind.TypeOfExpression:\n            var expression = right.expression;\n            if (!tsutils_1.isLiteralExpression(left)) {\n                if (tsutils_1.isIdentifier(left) && left.text === \"undefined\" ||\n                    left.kind === ts.SyntaxKind.NullKeyword ||\n                    left.kind === ts.SyntaxKind.TrueKeyword ||\n                    left.kind === ts.SyntaxKind.FalseKeyword) {\n                    return { kind: 2 /* TypeofTypo */ };\n                }\n                return undefined;\n            }\n            var predicate = getTypePredicateForKind(left.text);\n            return predicate === undefined\n                ? { kind: 2 /* TypeofTypo */ }\n                : { kind: 0 /* Plain */, expression: expression, predicate: predicate, isNullOrUndefined: left.text === \"undefined\" };\n        case ts.SyntaxKind.NullKeyword:\n            return nullOrUndefined(ts.TypeFlags.Null);\n        case ts.SyntaxKind.Identifier:\n            if (right.originalKeywordKind === ts.SyntaxKind.UndefinedKeyword) {\n                return nullOrUndefined(undefinedFlags);\n            }\n            return undefined;\n        default:\n            return undefined;\n    }\n    function nullOrUndefined(flags) {\n        return isStrictEquals\n            ? { kind: 0 /* Plain */, expression: left, predicate: flagPredicate(flags), isNullOrUndefined: true }\n            : { kind: 1 /* NonStructNullUndefined */, expression: left };\n    }\n}\nfunction isEmptyType(checker, type) {\n    return checker.typeToString(type) === \"{}\";\n}\nvar undefinedFlags = ts.TypeFlags.Undefined | ts.TypeFlags.Void;\nfunction getTypePredicateForKind(kind) {\n    switch (kind) {\n        case \"undefined\":\n            return flagPredicate(undefinedFlags);\n        case \"boolean\":\n            return flagPredicate(ts.TypeFlags.BooleanLike);\n        case \"number\":\n            return flagPredicate(ts.TypeFlags.NumberLike);\n        case \"string\":\n            return flagPredicate(ts.TypeFlags.StringLike);\n        case \"symbol\":\n            return flagPredicate(ts.TypeFlags.ESSymbol);\n        case \"function\":\n            return isFunction;\n        case \"object\":\n            // It's an object if it's not any of the above.\n            var allFlags_1 = ts.TypeFlags.Undefined | ts.TypeFlags.Void | ts.TypeFlags.BooleanLike |\n                ts.TypeFlags.NumberLike | ts.TypeFlags.StringLike | ts.TypeFlags.ESSymbol;\n            return function (type) { return !tsutils_1.isTypeFlagSet(type, allFlags_1) && !isFunction(type); };\n        default:\n            return undefined;\n    }\n}\nfunction flagPredicate(testedFlag) {\n    return function (type) { return tsutils_1.isTypeFlagSet(type, testedFlag); };\n}\nfunction isFunction(t) {\n    if (t.getConstructSignatures().length !== 0 || t.getCallSignatures().length !== 0) {\n        return true;\n    }\n    var symbol = t.getSymbol();\n    return symbol !== undefined && symbol.getName() === \"Function\";\n}\n/** Returns a boolean value if that should always be the result of a type predicate. */\nfunction getConstantBoolean(type, predicate) {\n    var anyTrue = false;\n    var anyFalse = false;\n    for (var _i = 0, _a = unionParts(type); _i < _a.length; _i++) {\n        var ty = _a[_i];\n        if (predicate(ty)) {\n            anyTrue = true;\n        }\n        else {\n            anyFalse = true;\n        }\n        if (anyTrue && anyFalse) {\n            return undefined;\n        }\n    }\n    return anyTrue;\n}\n/** Returns bool for always/never true, or a string to recommend strict equality. */\nfunction testNonStrictNullUndefined(type) {\n    var anyNull = false;\n    var anyUndefined = false;\n    var anyOther = false;\n    for (var _i = 0, _a = unionParts(type); _i < _a.length; _i++) {\n        var ty = _a[_i];\n        if (tsutils_1.isTypeFlagSet(ty, ts.TypeFlags.Null)) {\n            anyNull = true;\n        }\n        else if (tsutils_1.isTypeFlagSet(ty, undefinedFlags)) {\n            anyUndefined = true;\n        }\n        else {\n            anyOther = true;\n        }\n    }\n    return !anyOther ? true\n        : anyNull && anyUndefined ? undefined\n            : anyNull ? \"null\"\n                : anyUndefined ? \"undefined\"\n                    : false;\n}\nfunction unionParts(type) {\n    return tsutils_1.isUnionType(type) ? type.types : [type];\n}\nvar templateObject_1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/strictTypePredicatesRule.js\n// module id = 2137\n// module chunks = 27"],"sourceRoot":""}