{"version":3,"sources":["../node_modules/tslint/lib/rules/jsdocFormatRule.js"],"names":["Object","defineProperty","exports","value","templateObject_1","templateObject_2","tslib_1","__webpack_require__","utils","ts","Lint","Rule","_super","apply","this","arguments","__extends","prototype","sourceFile","applyWithFunction","walk","firstLineOfMultiline","ruleArguments","indexOf","metadata","ruleName","description","descriptionDetails","Utils","dedent","__makeTemplateObject","rationale","optionsDescription","options","type","minItems","maxItems","items","enum","optionExamples","typescriptOnly","ALIGNMENT_FAILURE_STRING","FORMAT_FAILURE_STRING","Rules","AbstractRule","ctx","forEachComment","fullText","_a","kind","pos","end","SyntaxKind","MultiLineCommentTrivia","lines","slice","split","firstLine","length","alignColumn","result","getLineAndCharacterOfPosition","line","text","character","getAlignColumn","test","addFailureAt","lineStart","endIndex","i","endsWith","lastLine","search","addFailure"],"mappings":"sDAiBAA,OAAAC,eAAAC,EAAA,cAA8CC,OAAA,IAC9C,IA8FAC,EAAAC,EA9FAC,EAAAC,EAAA,GACAC,EAAAD,EAAA,KACAE,EAAAF,EAAA,IACAG,EAAAH,EAAA,MAEAI,EAAA,SAAAC,GAEA,SAAAD,IACA,cAAAC,KAAAC,MAAAC,KAAAC,YAAAD,KA8BA,OAhCAR,EAAAU,UAAAL,EAAAC,GAIAD,EAAAM,UAAAJ,MAAA,SAAAK,GACA,OAAAJ,KAAAK,kBAAAD,EAAAE,GACAC,sBAAA,IAAAP,KAAAQ,cAAAC,QARA,4BAYAZ,EAAAa,UACAC,SAAA,eACAC,YAAA,kDACAC,mBAAAjB,EAAAkB,MAAAC,OAAAzB,MAAAE,EAAAwB,sBAAA,6pCAfA,yBAgBAC,UAAA,kEACAC,mBAAAtB,EAAAkB,MAAAC,OAAAxB,MAAAC,EAAAwB,sBAAA,2TAjBA,yBAkBAG,SACAC,KAAA,QACAC,SAAA,EACAC,SAAA,EACAC,OACAH,KAAA,SACAI,MAxBA,2BA2BAC,iBAAA,MA3BA,0BA4BAL,KAAA,QACAM,gBAAA,GAGA7B,EAAA8B,yBAAA,qCACA9B,EAAA+B,sBAAA,gDACA/B,EAjCA,CAkCCD,EAAAiC,MAAAC,cAED,SAAAxB,EAAAyB,GACA,OAAArC,EAAAsC,eAAAD,EAAA3B,WAAA,SAAA6B,EAAAC,GACA,IAAAC,EAAAD,EAAAC,KAAAC,EAAAF,EAAAE,IAAAC,EAAAH,EAAAG,IACA,GAAAF,IAAAxC,EAAA2C,WAAAC,wBACA,MAAAN,EAAAG,EAAA,IACA,MAAAH,EAAAG,EAAA,IACA,MAAAH,EAAAG,EAAA,GAHA,CAMA,IAAAI,EAAAP,EAAAQ,MAAAL,EAAA,EAAAC,EAAA,GAAAK,MAAA,MACAC,EAAAH,EAAA,GACA,OAAAA,EAAAI,OAAA,CAMA,IAAAC,EA6BA,SAAAzC,EAAAgC,GACA,IAAAU,EAAAnD,EAAAoD,8BAAA3C,EAAAgC,GAEA,WAAAU,EAAAE,MAAA,WAAA5C,EAAA6C,KAAA,GACAH,EAAAI,UAAA,EACAJ,EAAAI,UAlCAC,CAAApB,EAAA3B,WAAAgC,EAAA,GACAL,EAAAZ,QAAAZ,sBAAA,KAAA6C,KAAAT,IAEAZ,EAAAsB,aAAAjB,EAAAO,EAAAC,OAAA,EAAA/C,EAAA+B,uBAIA,IAFA,IAAA0B,EAAAlB,EAAAO,EAAAC,OAAA,EACAW,EAAAf,EAAAI,OAAA,EACAY,EAAA,EAAuBA,EAAAD,IAAcC,EAAA,CACrC,IAAAR,EAAAR,EAAAgB,GAAAC,SAAA,MAAAjB,EAAAgB,GAAAf,MAAA,MAAAD,EAAAgB,GAGA,gBAAAJ,KAAAJ,IACAjB,EAAAsB,aAAAC,EAAAN,EAAAJ,OAAA/C,EAAA+B,uBAEAoB,EAAAvC,QAAA,OAAAoC,GACAd,EAAAsB,aAAAC,EAAAN,EAAAJ,OAAA/C,EAAA8B,0BAEA2B,GAAAd,EAAAgB,GAAAZ,OAAA,EAEA,IAAAc,EAAAlB,EAAAe,IAEA,IAAAG,EAAAC,OAAA,OACA5B,EAAA6B,WAAAN,EAAAjB,EAAAxC,EAAA+B,uBAEA8B,EAAAd,SAAAC,GACAd,EAAA6B,WAAAN,EAAAjB,EAAAxC,EAAA8B,8BA9BA,MAAAgB,EAAA,IAAAA,EAAAc,SAAA,MACA1B,EAAA6B,WAAAxB,EAAAC,EAAAxC,EAAA+B,0BAdAxC,EAAAS","file":"static/js/132.756af20a.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar OPTION_CHECK_MULTILINE_START = \"check-multiline-start\";\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk, {\n            firstLineOfMultiline: this.ruleArguments.indexOf(OPTION_CHECK_MULTILINE_START) !== -1,\n        });\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"jsdoc-format\",\n        description: \"Enforces basic format rules for JSDoc comments.\",\n        descriptionDetails: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            The following rules are enforced for JSDoc comments (comments starting with `/**`):\\n\\n            * each line contains an asterisk and asterisks must be aligned\\n            * each asterisk must be followed by either a space or a newline (except for the first and the last)\\n            * the only characters before the asterisk on each line must be whitespace characters\\n            * one line comments must start with `/** ` and end with `*/`\\n            * multiline comments don't allow text after `/** ` in the first line (with option `\\\"\", \"\\\"`)\\n        \"], [\"\\n            The following rules are enforced for JSDoc comments (comments starting with \\\\`/**\\\\`):\\n\\n            * each line contains an asterisk and asterisks must be aligned\\n            * each asterisk must be followed by either a space or a newline (except for the first and the last)\\n            * the only characters before the asterisk on each line must be whitespace characters\\n            * one line comments must start with \\\\`/** \\\\` and end with \\\\`*/\\\\`\\n            * multiline comments don't allow text after \\\\`/** \\\\` in the first line (with option \\\\`\\\"\", \"\\\"\\\\`)\\n        \"])), OPTION_CHECK_MULTILINE_START),\n        rationale: \"Helps maintain a consistent, readable style for JSDoc comments.\",\n        optionsDescription: Lint.Utils.dedent(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject([\"\\n            You can optionally specify the option `\\\"\", \"\\\"` to enforce the first line of a\\n            multiline JSDoc comment to be empty.\\n        \"], [\"\\n            You can optionally specify the option \\\\`\\\"\", \"\\\"\\\\` to enforce the first line of a\\n            multiline JSDoc comment to be empty.\\n        \"])), OPTION_CHECK_MULTILINE_START),\n        options: {\n            type: \"array\",\n            minItems: 0,\n            maxItems: 1,\n            items: {\n                type: \"string\",\n                enum: [OPTION_CHECK_MULTILINE_START],\n            },\n        },\n        optionExamples: [true, [true, OPTION_CHECK_MULTILINE_START]],\n        type: \"style\",\n        typescriptOnly: false,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.ALIGNMENT_FAILURE_STRING = \"asterisks in jsdoc must be aligned\";\n    Rule.FORMAT_FAILURE_STRING = \"jsdoc is not formatted correctly on this line\";\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nfunction walk(ctx) {\n    return utils.forEachComment(ctx.sourceFile, function (fullText, _a) {\n        var kind = _a.kind, pos = _a.pos, end = _a.end;\n        if (kind !== ts.SyntaxKind.MultiLineCommentTrivia ||\n            fullText[pos + 2] !== \"*\" ||\n            fullText[pos + 3] === \"*\" ||\n            fullText[pos + 3] === \"/\") {\n            return;\n        }\n        var lines = fullText.slice(pos + 3, end - 2).split(\"\\n\");\n        var firstLine = lines[0];\n        if (lines.length === 1) {\n            if (firstLine[0] !== \" \" || !firstLine.endsWith(\" \")) {\n                ctx.addFailure(pos, end, Rule.FORMAT_FAILURE_STRING);\n            }\n            return;\n        }\n        var alignColumn = getAlignColumn(ctx.sourceFile, pos + 1);\n        if (ctx.options.firstLineOfMultiline && /\\S/.test(firstLine)) {\n            // first line of multiline JSDoc should be empty, i.e. only contain whitespace\n            ctx.addFailureAt(pos, firstLine.length + 3, Rule.FORMAT_FAILURE_STRING);\n        }\n        var lineStart = pos + firstLine.length + 4; // +3 for the comment start \"/**\" and +1 for the newline\n        var endIndex = lines.length - 1;\n        for (var i = 1; i < endIndex; ++i) {\n            var line = lines[i].endsWith(\"\\r\") ? lines[i].slice(0, -1) : lines[i];\n            // regex is: start of string, followed by any amount of whitespace, followed by *,\n            // followed by either a space or the end of the string\n            if (!/^\\s*\\*(?: |$)/.test(line)) {\n                ctx.addFailureAt(lineStart, line.length, Rule.FORMAT_FAILURE_STRING);\n            }\n            if (line.indexOf(\"*\") !== alignColumn) {\n                ctx.addFailureAt(lineStart, line.length, Rule.ALIGNMENT_FAILURE_STRING);\n            }\n            lineStart += lines[i].length + 1; // + 1 for the splitted-out newline\n        }\n        var lastLine = lines[endIndex];\n        // last line should only consist of whitespace\n        if (lastLine.search(/\\S/) !== -1) {\n            ctx.addFailure(lineStart, end, Rule.FORMAT_FAILURE_STRING);\n        }\n        if (lastLine.length !== alignColumn) {\n            ctx.addFailure(lineStart, end, Rule.ALIGNMENT_FAILURE_STRING);\n        }\n    });\n}\nfunction getAlignColumn(sourceFile, pos) {\n    var result = ts.getLineAndCharacterOfPosition(sourceFile, pos);\n    // handle files starting with BOM\n    return result.line === 0 && sourceFile.text[0] === \"\\uFEFF\"\n        ? result.character - 1\n        : result.character;\n}\nvar templateObject_1, templateObject_2;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/jsdocFormatRule.js\n// module id = 2039\n// module chunks = 132"],"sourceRoot":""}