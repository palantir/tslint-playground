{"version":3,"sources":["../node_modules/tslint/lib/rules/preferForOfRule.js"],"names":["Object","defineProperty","exports","value","tslib_1","__webpack_require__","utils","ts","Lint","utils_1","Rule","_super","apply","this","arguments","__extends","prototype","sourceFile","applyWithFunction","walk","metadata","ruleName","description","rationale","optionsDescription","options","optionExamples","type","typescriptOnly","FAILURE_STRING","Rules","AbstractRule","ctx","variables","forEachChild","cb","node","isForStatement","arrayNodeInfo","forLoop","initializer","condition","incrementor","undefined","isVariableDeclarationList","declarations","length","_a","indexVariable","name","indexInit","kind","SyntaxKind","Identifier","isNumber","indexVariableName","PrefixUnaryExpression","PostfixUnaryExpression","operator","operand","PlusPlusToken","isVar","BinaryExpression","_b","operatorToken","updatedVar","left","rhs","right","PlusEqualsToken","isOne","EqualsToken","isBinaryExpression","rhsOp","PlusToken","id","isIdentifierNamed","isIncremented","text","LessThanToken","isPropertyAccessExpression","arrayExpr","expression","getForLoopHeaderInfo","collectVariableUsage","_i","get","uses","location","pos","end","statement","isNonSimpleIncrementorUse","addFailure","getStart","visitForStatement","parent","isElementAccessExpression","isReassignmentTarget","a","b","getText","nodeEquals","unwrapParentheses","isIdentifier","isNumericLiteral"],"mappings":"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","file":"static/js/55.7f4b8c1a.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2018 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar utils_1 = require(\"../language/utils\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk);\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"prefer-for-of\",\n        description: \"Recommends a 'for-of' loop over a standard 'for' loop if the index is only used to access the array being iterated.\",\n        rationale: \"A for(... of ...) loop is easier to implement and read when the index is not needed.\",\n        optionsDescription: \"Not configurable.\",\n        options: null,\n        optionExamples: [true],\n        type: \"typescript\",\n        typescriptOnly: false,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = \"Expected a 'for-of' loop instead of a 'for' loop with this simple iteration\";\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var sourceFile = ctx.sourceFile;\n    var variables;\n    return ts.forEachChild(sourceFile, function cb(node) {\n        if (utils.isForStatement(node)) {\n            visitForStatement(node);\n        }\n        return ts.forEachChild(node, cb);\n    });\n    function visitForStatement(node) {\n        var arrayNodeInfo = getForLoopHeaderInfo(node);\n        if (arrayNodeInfo === undefined) {\n            return;\n        }\n        var indexVariable = arrayNodeInfo.indexVariable, arrayExpr = arrayNodeInfo.arrayExpr;\n        if (variables === undefined) {\n            variables = utils.collectVariableUsage(sourceFile);\n        }\n        for (var _i = 0, _a = variables.get(indexVariable).uses; _i < _a.length; _i++) {\n            var location = _a[_i].location;\n            if (location.pos < node.initializer.end ||\n                location.pos >= node.end || // bail out on use outside of for loop\n                (location.pos >= node.statement.pos && // only check uses in loop body\n                    isNonSimpleIncrementorUse(location, arrayExpr, sourceFile))) {\n                return;\n            }\n        }\n        ctx.addFailure(node.getStart(sourceFile), node.statement.pos, Rule.FAILURE_STRING);\n    }\n}\nfunction isNonSimpleIncrementorUse(node, arrayExpr, sourceFile) {\n    // check if iterator is used for something other than reading data from array\n    var parent = node.parent;\n    return (!utils.isElementAccessExpression(parent) ||\n        // `a[i] = ...` or similar\n        utils.isReassignmentTarget(parent) ||\n        // `b[i]`\n        !nodeEquals(arrayExpr, utils_1.unwrapParentheses(parent.expression), sourceFile));\n}\nfunction nodeEquals(a, b, sourceFile) {\n    return a.getText(sourceFile) === b.getText(sourceFile);\n}\n// returns the iterator and array of a `for` loop if the `for` loop is basic.\nfunction getForLoopHeaderInfo(forLoop) {\n    var initializer = forLoop.initializer, condition = forLoop.condition, incrementor = forLoop.incrementor;\n    if (initializer === undefined || condition === undefined || incrementor === undefined) {\n        return undefined;\n    }\n    // Must start with `var i = 0;` or `let i = 0;`\n    if (!utils.isVariableDeclarationList(initializer) || initializer.declarations.length !== 1) {\n        return undefined;\n    }\n    var _a = initializer.declarations[0], indexVariable = _a.name, indexInit = _a.initializer;\n    if (indexVariable.kind !== ts.SyntaxKind.Identifier ||\n        indexInit === undefined ||\n        !isNumber(indexInit, \"0\")) {\n        return undefined;\n    }\n    // Must end with `i++`\n    if (!isIncremented(incrementor, indexVariable.text)) {\n        return undefined;\n    }\n    // Condition must be `i < arr.length;`\n    if (!utils.isBinaryExpression(condition)) {\n        return undefined;\n    }\n    var left = condition.left, operatorToken = condition.operatorToken, right = condition.right;\n    if (!isIdentifierNamed(left, indexVariable.text) ||\n        operatorToken.kind !== ts.SyntaxKind.LessThanToken ||\n        !utils.isPropertyAccessExpression(right)) {\n        return undefined;\n    }\n    var arrayExpr = right.expression, name = right.name;\n    if (name.text !== \"length\") {\n        return undefined;\n    }\n    return { indexVariable: indexVariable, arrayExpr: arrayExpr };\n}\nfunction isIncremented(node, indexVariableName) {\n    switch (node.kind) {\n        case ts.SyntaxKind.PrefixUnaryExpression:\n        case ts.SyntaxKind.PostfixUnaryExpression: {\n            var _a = node, operator = _a.operator, operand = _a.operand;\n            // `++x` or `x++`\n            return operator === ts.SyntaxKind.PlusPlusToken && isVar(operand);\n        }\n        case ts.SyntaxKind.BinaryExpression:\n            var _b = node, operatorToken = _b.operatorToken, updatedVar = _b.left, rhs = _b.right;\n            if (!isVar(updatedVar)) {\n                return false;\n            }\n            switch (operatorToken.kind) {\n                case ts.SyntaxKind.PlusEqualsToken:\n                    // x += 1\n                    return isOne(rhs);\n                case ts.SyntaxKind.EqualsToken: {\n                    if (!utils.isBinaryExpression(rhs)) {\n                        return false;\n                    }\n                    var rhsOp = rhs.operatorToken, left = rhs.left, right = rhs.right;\n                    // `x = 1 + x` or `x = x + 1`\n                    return (rhsOp.kind === ts.SyntaxKind.PlusToken &&\n                        ((isVar(left) && isOne(right)) || (isOne(left) && isVar(right))));\n                }\n                default:\n                    return false;\n            }\n        default:\n            return false;\n    }\n    function isVar(id) {\n        return isIdentifierNamed(id, indexVariableName);\n    }\n}\nfunction isIdentifierNamed(node, text) {\n    return utils.isIdentifier(node) && node.text === text;\n}\nfunction isOne(node) {\n    return isNumber(node, \"1\");\n}\nfunction isNumber(node, value) {\n    return utils.isNumericLiteral(node) && node.text === value;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/preferForOfRule.js\n// module id = 2126\n// module chunks = 55"],"sourceRoot":""}