{"version":3,"sources":["../node_modules/tslint/lib/rules/maxLineLengthRule.js"],"names":["Object","defineProperty","exports","value","templateObject_1","templateObject_2","tslib_1","__webpack_require__","tsutils_1","Lint","Rule","_super","apply","this","arguments","__extends","FAILURE_STRING_FACTORY","lineLimit","prototype","isEnabled","limit","getRuleOptions","call","sourceFile","applyWithFunction","walk","argument","ruleArguments","options","ignorePattern","RegExp","undefined","Number","metadata","ruleName","description","rationale","Utils","dedent","__makeTemplateObject","optionsDescription","type","items","oneOf","properties","ignore-pattern","additionalProperties","minLength","maxLength","optionExamples","typescriptOnly","Rules","AbstractRule","ctx","_i","_a","getLineRanges","length","line","contentLength","lineContent","text","substr","pos","test","addFailureAt"],"mappings":"sDAiBAA,OAAAC,eAAAC,EAAA,cAA8CC,OAAA,IAC9C,IAqFAC,EAAAC,EArFAC,EAAAC,EAAA,GACAC,EAAAD,EAAA,KACAE,EAAAF,EAAA,MACAG,EAAA,SAAAC,GAEA,SAAAD,IACA,cAAAC,KAAAC,MAAAC,KAAAC,YAAAD,KA6DA,OA/DAP,EAAAS,UAAAL,EAAAC,GAKAD,EAAAM,uBAAA,SAAAC,GACA,wCAAAA,GAEAP,EAAAQ,UAAAC,UAAA,WACA,IAAAC,EAAAP,KAAAQ,iBAAAD,MACA,OAAAT,EAAAO,UAAAC,UAAAG,KAAAT,OAAAO,EAAA,GAEAV,EAAAQ,UAAAN,MAAA,SAAAW,GACA,OAAAV,KAAAW,kBAAAD,EAAAE,EAAAZ,KAAAQ,mBAEAX,EAAAQ,UAAAG,eAAA,WACA,IAAAK,EAAAb,KAAAc,cAAA,GACAC,GAAuBR,MAAA,GACvB,qBAAAM,EACAE,EAAAR,MAAAM,MAEA,CACAE,EAAAF,EACA,IAAAG,EAAAH,EAAA,kBACAE,EAAAC,cAAA,kBAAAA,EACA,IAAAC,OAAA,QAAAC,EAGA,OADAH,EAAAR,MAAAY,OAAAJ,EAAAR,OACAQ,GAGAlB,EAAAuB,UACAC,SAAA,kBACAC,YAAA,mDACAC,UAAA3B,EAAA4B,MAAAC,OAAAlC,MAAAE,EAAAiC,sBAAA,gdACAC,mBAAA/B,EAAA4B,MAAAC,OAAAjC,MAAAC,EAAAiC,sBAAA,szBAA00B,o2BAC10BX,SACAa,KAAA,QACAC,OACAC,QAEAF,KAAA,WAGAA,KAAA,SACAG,YACAxB,OAAsCqB,KAAA,UACtCI,kBAA+CJ,KAAA,WAE/CK,sBAAA,KAIAC,UAAA,EACAC,UAAA,GAEAC,kBAAA,YACA7B,MAAA,IACAyB,iBAAA,8BAEAJ,KAAA,kBACAS,gBAAA,GAEAxC,EAhEA,CAiECD,EAAA0C,MAAAC,cAED,SAAA3B,EAAA4B,GAGA,IAFA,IAAAjC,EAAAiC,EAAAzB,QAAAR,MACAS,EAAAwB,EAAAzB,QAAAC,cACAyB,EAAA,EAAAC,EAAA/C,EAAAgD,cAAAH,EAAA9B,YAAkE+B,EAAAC,EAAAE,OAAgBH,IAAA,CAClF,IAAAI,EAAAH,EAAAD,GACA,KAAAI,EAAAC,eAAAvC,GAAA,CAGA,IAAAwC,EAAAP,EAAA9B,WAAAsC,KAAAC,OAAAJ,EAAAK,IAAAL,EAAAC,oBACA5B,IAAAF,KAAAmC,KAAAJ,IAGAP,EAAAY,aAAAP,EAAAK,IAAAL,EAAAC,cAAAjD,EAAAM,uBAAAI,MAbAlB,EAAAQ","file":"static/js/119.0ab0d498.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils_1 = require(\"tsutils\");\nvar Lint = require(\"../index\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING_FACTORY = function (lineLimit) {\n        return \"Exceeds maximum line length of \" + lineLimit;\n    };\n    Rule.prototype.isEnabled = function () {\n        var limit = this.getRuleOptions().limit;\n        return _super.prototype.isEnabled.call(this) && (limit > 0);\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        return this.applyWithFunction(sourceFile, walk, this.getRuleOptions());\n    };\n    Rule.prototype.getRuleOptions = function () {\n        var argument = this.ruleArguments[0];\n        var options = { limit: 0 };\n        if (typeof argument === \"number\") {\n            options.limit = argument;\n        }\n        else {\n            options = argument;\n            var ignorePattern = argument[\"ignore-pattern\"];\n            options.ignorePattern = (typeof ignorePattern === \"string\") ?\n                new RegExp((ignorePattern)) : undefined;\n        }\n        options.limit = Number(options.limit); // user can pass a string instead of number\n        return options;\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"max-line-length\",\n        description: \"Requires lines to be under a certain max length.\",\n        rationale: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            Limiting the length of a line of code improves code readability.\\n            It also makes comparing code side-by-side easier and improves compatibility with\\n            various editors, IDEs, and diff viewers.\"], [\"\\n            Limiting the length of a line of code improves code readability.\\n            It also makes comparing code side-by-side easier and improves compatibility with\\n            various editors, IDEs, and diff viewers.\"]))),\n        optionsDescription: Lint.Utils.dedent(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject([\"\\n        It can take one argument, which can be any of the following:\\n        * integer indicating maximum length of lines.\\n        * object with keys:\\n          * `limit` - number < 0 defining max line length\\n          * `ignore-pattern` - string defining ignore pattern for this rule, being parsed by `new RegExp()`.\\n            For example:\\n             * `// ` pattern will ignore all in-line comments.\\n             * `^import ` pattern will ignore all import statements.\\n             * `^export {(.*?)}` pattern will ignore all multiple export statements.\\n             * `class [a-zA-Z]+ implements ` pattern will ignore all class declarations implementing interfaces.\\n             * `^import |^export {(.*?)}|class [a-zA-Z]+ implements |// ` pattern will ignore all the cases listed above.\\n         \"], [\"\\n        It can take one argument, which can be any of the following:\\n        * integer indicating maximum length of lines.\\n        * object with keys:\\n          * \\\\`limit\\\\` - number < 0 defining max line length\\n          * \\\\`ignore-pattern\\\\` - string defining ignore pattern for this rule, being parsed by \\\\`new RegExp()\\\\`.\\n            For example:\\n             * \\\\`\\\\/\\\\/ \\\\` pattern will ignore all in-line comments.\\n             * \\\\`^import \\\\` pattern will ignore all import statements.\\n             * \\\\`^export \\\\{(.*?)\\\\}\\\\` pattern will ignore all multiple export statements.\\n             * \\\\`class [a-zA-Z]+ implements \\\\` pattern will ignore all class declarations implementing interfaces.\\n             * \\\\`^import |^export \\\\{(.*?)\\\\}|class [a-zA-Z]+ implements |// \\\\` pattern will ignore all the cases listed above.\\n         \"]))),\n        options: {\n            type: \"array\",\n            items: {\n                oneOf: [\n                    {\n                        type: \"number\",\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            \"limit\": { type: \"number\" },\n                            \"ignore-pattern\": { type: \"string\" },\n                        },\n                        additionalProperties: false,\n                    },\n                ],\n            },\n            minLength: 1,\n            maxLength: 2,\n        },\n        optionExamples: [[true, 120], [true, {\n                    \"limit\": 120,\n                    \"ignore-pattern\": \"^import |^export \\{(.*?)\\}\"\n                }]],\n        type: \"maintainability\",\n        typescriptOnly: false,\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var limit = ctx.options.limit;\n    var ignorePattern = ctx.options.ignorePattern;\n    for (var _i = 0, _a = tsutils_1.getLineRanges(ctx.sourceFile); _i < _a.length; _i++) {\n        var line = _a[_i];\n        if (line.contentLength <= limit) {\n            continue;\n        }\n        var lineContent = ctx.sourceFile.text.substr(line.pos, line.contentLength);\n        if (ignorePattern !== undefined && ignorePattern.test(lineContent)) {\n            continue;\n        }\n        ctx.addFailureAt(line.pos, line.contentLength, Rule.FAILURE_STRING_FACTORY(limit));\n    }\n}\nvar templateObject_1, templateObject_2;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/maxLineLengthRule.js\n// module id = 2040\n// module chunks = 119"],"sourceRoot":""}