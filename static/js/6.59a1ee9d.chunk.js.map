{"version":3,"sources":["../node_modules/tslint/lib/rules/noConsecutiveBlankLinesRule.js","../node_modules/tslint/lib/rules/noTrailingWhitespaceRule.js"],"names":["Object","defineProperty","exports","value","templateObject_1","templateObject_2","tslib_1","__webpack_require__","utils","ts","Lint","Rule","_super","apply","this","arguments","__extends","FAILURE_STRING_FACTORY","allowed","prototype","isEnabled","option","ruleArguments","call","undefined","sourceFile","limit","applyWithFunction","walk","DEFAULT_ALLOWED_BLANKS","metadata","ruleName","description","hasFix","rationale","Utils","dedent","__makeTemplateObject","optionsDescription","options","type","minimum","optionExamples","typescriptOnly","Rules","AbstractRule","ctx","sourceText","text","threshold","possibleFailures","consecutiveBlankLines","_i","_a","getLineRanges","length","line","contentLength","substr","pos","search","push","end","failureString","templateRanges","getTemplateRanges","_loop_1","possibleFailure","some","template","addFailureAt","Replacement","deleteFromTo","getStartOfLineBreak","_b","possibleFailures_1","intervals","cb","node","kind","SyntaxKind","FirstTemplateToken","LastTemplateToken","forEachChild","getStart","tsutils_1","noConsecutiveBlankLinesRule_1","ignoreComments","indexOf","ignoreBlankLines","ignoreJsDoc","ignoreTemplates","items","enum","FAILURE_STRING","match","index","excludedRanges","forEachTokenWithTrivia","range","SingleLineCommentTrivia","MultiLineCommentTrivia","isJsDoc","getExcludedRanges","forEachComment","comment","getExcludedComments","addFailure"],"mappings":"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","file":"static/js/6.59a1ee9d.chunk.js","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar utils = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING_FACTORY = function (allowed) {\n        return allowed === 1\n            ? \"Consecutive blank lines are forbidden\"\n            : \"Exceeds the \" + allowed + \" allowed consecutive blank lines\";\n    };\n    /**\n     * Disable the rule if the option is provided but non-numeric or less than the minimum.\n     */\n    Rule.prototype.isEnabled = function () {\n        var option = this.ruleArguments[0];\n        return _super.prototype.isEnabled.call(this) && (option === undefined || option > 0);\n    };\n    Rule.prototype.apply = function (sourceFile) {\n        var limit = this.ruleArguments[0];\n        return this.applyWithFunction(sourceFile, walk, limit !== undefined ? limit : Rule.DEFAULT_ALLOWED_BLANKS);\n    };\n    Rule.DEFAULT_ALLOWED_BLANKS = 1;\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"no-consecutive-blank-lines\",\n        description: \"Disallows one or more blank lines in a row.\",\n        hasFix: true,\n        rationale: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            Helps maintain a readable style in your codebase.\\n\\n            Extra blank lines take up extra space and add little to a semantic understanding of the code.\\n            It can be harder to read through files when fewer components can fit into the screen.\\n            If you find a file is so large you feel a need to split them up with extra blank lines or comments,\\n            consider splitting your file into smaller files.\\n        \"], [\"\\n            Helps maintain a readable style in your codebase.\\n\\n            Extra blank lines take up extra space and add little to a semantic understanding of the code.\\n            It can be harder to read through files when fewer components can fit into the screen.\\n            If you find a file is so large you feel a need to split them up with extra blank lines or comments,\\n            consider splitting your file into smaller files.\\n        \"]))),\n        optionsDescription: Lint.Utils.dedent(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject([\"\\n            An optional number of maximum allowed sequential blanks can be specified. If no value\\n            is provided, a default of \", \" will be used.\"], [\"\\n            An optional number of maximum allowed sequential blanks can be specified. If no value\\n            is provided, a default of \", \" will be used.\"])), Rule.DEFAULT_ALLOWED_BLANKS),\n        options: {\n            type: \"number\",\n            minimum: \"1\",\n        },\n        optionExamples: [true, [true, 2]],\n        type: \"style\",\n        typescriptOnly: false,\n    };\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var sourceText = ctx.sourceFile.text;\n    var threshold = ctx.options + 1;\n    var possibleFailures = [];\n    var consecutiveBlankLines = 0;\n    for (var _i = 0, _a = utils.getLineRanges(ctx.sourceFile); _i < _a.length; _i++) {\n        var line = _a[_i];\n        if (line.contentLength === 0 || sourceText.substr(line.pos, line.contentLength).search(/\\S/) === -1) {\n            ++consecutiveBlankLines;\n            if (consecutiveBlankLines === threshold) {\n                possibleFailures.push({\n                    end: line.end,\n                    pos: line.pos,\n                });\n            }\n            else if (consecutiveBlankLines > threshold) {\n                possibleFailures[possibleFailures.length - 1].end = line.end;\n            }\n        }\n        else {\n            consecutiveBlankLines = 0;\n        }\n    }\n    if (possibleFailures.length === 0) {\n        return;\n    }\n    var failureString = Rule.FAILURE_STRING_FACTORY(ctx.options);\n    var templateRanges = getTemplateRanges(ctx.sourceFile);\n    var _loop_1 = function (possibleFailure) {\n        if (!templateRanges.some(function (template) { return template.pos < possibleFailure.pos && possibleFailure.pos < template.end; })) {\n            ctx.addFailureAt(possibleFailure.pos, 1, failureString, [\n                Lint.Replacement.deleteFromTo(\n                // special handling for fixing blank lines at the end of the file\n                // to fix this we need to cut off the line break of the last allowed blank line, too\n                possibleFailure.end === sourceText.length ? getStartOfLineBreak(sourceText, possibleFailure.pos) : possibleFailure.pos, possibleFailure.end),\n            ]);\n        }\n    };\n    for (var _b = 0, possibleFailures_1 = possibleFailures; _b < possibleFailures_1.length; _b++) {\n        var possibleFailure = possibleFailures_1[_b];\n        _loop_1(possibleFailure);\n    }\n}\nfunction getStartOfLineBreak(sourceText, pos) {\n    return sourceText[pos - 2] === \"\\r\" ? pos - 1 : pos - 1;\n}\nfunction getTemplateRanges(sourceFile) {\n    var intervals = [];\n    var cb = function (node) {\n        if (node.kind >= ts.SyntaxKind.FirstTemplateToken &&\n            node.kind <= ts.SyntaxKind.LastTemplateToken) {\n            intervals.push({\n                end: node.end,\n                pos: node.getStart(sourceFile),\n            });\n        }\n        else {\n            return ts.forEachChild(node, cb);\n        }\n    };\n    ts.forEachChild(sourceFile, cb);\n    return intervals;\n}\nexports.getTemplateRanges = getTemplateRanges;\nvar templateObject_1, templateObject_2;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/noConsecutiveBlankLinesRule.js\n// module id = 1957\n// module chunks = 6 107","\"use strict\";\n/**\n * @license\n * Copyright 2013 Palantir Technologies, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar tsutils_1 = require(\"tsutils\");\nvar ts = require(\"typescript\");\nvar Lint = require(\"../index\");\nvar noConsecutiveBlankLinesRule_1 = require(\"./noConsecutiveBlankLinesRule\");\nvar OPTION_IGNORE_COMMENTS = \"ignore-comments\";\nvar OPTION_IGNORE_JSDOC = \"ignore-jsdoc\";\nvar OPTION_IGNORE_TEMPLATE_STRINGS = \"ignore-template-strings\";\nvar OPTION_IGNORE_BLANK_LINES = \"ignore-blank-lines\";\nvar Rule = /** @class */ (function (_super) {\n    tslib_1.__extends(Rule, _super);\n    function Rule() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Rule.prototype.apply = function (sourceFile) {\n        var ignoreComments = this.ruleArguments.indexOf(OPTION_IGNORE_COMMENTS) !== -1;\n        return this.applyWithFunction(sourceFile, walk, {\n            ignoreBlankLines: this.ruleArguments.indexOf(OPTION_IGNORE_BLANK_LINES) !== -1,\n            ignoreComments: ignoreComments,\n            ignoreJsDoc: ignoreComments || this.ruleArguments.indexOf(OPTION_IGNORE_JSDOC) !== -1,\n            ignoreTemplates: this.ruleArguments.indexOf(OPTION_IGNORE_TEMPLATE_STRINGS) !== -1,\n        });\n    };\n    /* tslint:disable:object-literal-sort-keys */\n    Rule.metadata = {\n        ruleName: \"no-trailing-whitespace\",\n        description: \"Disallows trailing whitespace at the end of a line.\",\n        rationale: \"Keeps version control diffs clean as it prevents accidental whitespace from being committed.\",\n        optionsDescription: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"\\n            Possible settings are:\\n\\n            * `\\\"\", \"\\\"`: Allows trailing whitespace in template strings.\\n            * `\\\"\", \"\\\"`: Allows trailing whitespace in comments.\\n            * `\\\"\", \"\\\"`: Allows trailing whitespace only in JSDoc comments.\\n            * `\\\"\", \"\\\"`: Allows trailing whitespace on empty lines.\"], [\"\\n            Possible settings are:\\n\\n            * \\\\`\\\"\", \"\\\"\\\\`: Allows trailing whitespace in template strings.\\n            * \\\\`\\\"\", \"\\\"\\\\`: Allows trailing whitespace in comments.\\n            * \\\\`\\\"\", \"\\\"\\\\`: Allows trailing whitespace only in JSDoc comments.\\n            * \\\\`\\\"\", \"\\\"\\\\`: Allows trailing whitespace on empty lines.\"])), OPTION_IGNORE_TEMPLATE_STRINGS, OPTION_IGNORE_COMMENTS, OPTION_IGNORE_JSDOC, OPTION_IGNORE_BLANK_LINES),\n        hasFix: true,\n        options: {\n            type: \"array\",\n            items: {\n                type: \"string\",\n                enum: [OPTION_IGNORE_COMMENTS, OPTION_IGNORE_JSDOC, OPTION_IGNORE_TEMPLATE_STRINGS, OPTION_IGNORE_BLANK_LINES],\n            },\n        },\n        optionExamples: [\n            true,\n            [true, OPTION_IGNORE_COMMENTS],\n            [true, OPTION_IGNORE_JSDOC],\n        ],\n        type: \"style\",\n        typescriptOnly: false,\n    };\n    /* tslint:enable:object-literal-sort-keys */\n    Rule.FAILURE_STRING = \"trailing whitespace\";\n    return Rule;\n}(Lint.Rules.AbstractRule));\nexports.Rule = Rule;\nfunction walk(ctx) {\n    var possibleFailures = [];\n    var sourceFile = ctx.sourceFile;\n    var text = sourceFile.text;\n    for (var _i = 0, _a = tsutils_1.getLineRanges(sourceFile); _i < _a.length; _i++) {\n        var line = _a[_i];\n        // \\s matches any whitespace character (equal to [\\r\\n\\t\\f\\v ])\n        var match = text.substr(line.pos, line.contentLength).match(/\\s+$/);\n        if (match !== null && !(ctx.options.ignoreBlankLines && match.index === 0)) {\n            possibleFailures.push({\n                end: line.pos + line.contentLength,\n                pos: line.pos + match.index,\n            });\n        }\n    }\n    if (possibleFailures.length === 0) {\n        return;\n    }\n    var excludedRanges = ctx.options.ignoreTemplates\n        ? ctx.options.ignoreJsDoc ? getExcludedRanges(sourceFile, ctx.options) : noConsecutiveBlankLinesRule_1.getTemplateRanges(sourceFile)\n        : ctx.options.ignoreJsDoc ? getExcludedComments(sourceFile, ctx.options) : [];\n    var _loop_1 = function (possibleFailure) {\n        if (!excludedRanges.some(function (range) { return range.pos < possibleFailure.pos && possibleFailure.pos < range.end; })) {\n            ctx.addFailure(possibleFailure.pos, possibleFailure.end, Rule.FAILURE_STRING, Lint.Replacement.deleteFromTo(possibleFailure.pos, possibleFailure.end));\n        }\n    };\n    for (var _b = 0, possibleFailures_1 = possibleFailures; _b < possibleFailures_1.length; _b++) {\n        var possibleFailure = possibleFailures_1[_b];\n        _loop_1(possibleFailure);\n    }\n}\nfunction getExcludedRanges(sourceFile, options) {\n    var intervals = [];\n    tsutils_1.forEachTokenWithTrivia(sourceFile, function (text, kind, range) {\n        if (kind >= ts.SyntaxKind.FirstTemplateToken && kind <= ts.SyntaxKind.LastTemplateToken) {\n            intervals.push(range);\n        }\n        else if (options.ignoreComments) {\n            if (kind === ts.SyntaxKind.SingleLineCommentTrivia || kind === ts.SyntaxKind.MultiLineCommentTrivia) {\n                intervals.push(range);\n            }\n        }\n        else if (options.ignoreJsDoc) {\n            if (isJsDoc(text, kind, range)) {\n                intervals.push(range);\n            }\n        }\n    });\n    return intervals;\n}\nfunction getExcludedComments(sourceFile, options) {\n    var intervals = [];\n    tsutils_1.forEachComment(sourceFile, function (text, comment) {\n        if (options.ignoreComments ||\n            options.ignoreJsDoc && isJsDoc(text, comment.kind, comment)) {\n            intervals.push(comment);\n        }\n    });\n    return intervals;\n}\nfunction isJsDoc(sourceText, kind, range) {\n    return kind === ts.SyntaxKind.MultiLineCommentTrivia && sourceText[range.pos + 2] === \"*\" && sourceText[range.pos + 3] !== \"*\";\n}\nvar templateObject_1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/tslint/lib/rules/noTrailingWhitespaceRule.js\n// module id = 2095\n// module chunks = 6"],"sourceRoot":""}